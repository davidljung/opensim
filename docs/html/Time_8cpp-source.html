<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/Time.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/Time.cpp</h1><a href="Time_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Time.cpp 1046 2004-02-27 19:20:16Z jungd $</span>
00019 <span class="comment">  $Revision: 1.4 $</span>
00020 <span class="comment">  $Date: 2004-02-27 14:20:16 -0500 (Fri, 27 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="Time.html">base/Time</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="Serializer.html">base/Serializer</a>&gt;</span>
00028 
00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
00030 
00031 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00032 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00033 <span class="preprocessor">#include &lt;sys/uio.h&gt;</span>
00034 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00035 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00036 }
00037 
00038 <span class="keyword">using</span> <a class="code" href="classbase_1_1Time.html">base::Time</a>;
00039 
00040 
00041 Time* Time::time=0;
00042 <span class="keywordtype">long</span> Time::baseSecs;
00043 <span class="keywordtype">long</span> Time::baseMicros;
00044 Time Time::lastNow;
00045 <span class="keywordtype">long</span> Time::resolution;
00046 
00047 
00048 Time::Time()
00049 {
00050   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a1">SInt</a> minResolution = 20000; <span class="comment">// 1/50th sec</span>
00051   
00052   <span class="keywordflow">if</span> (time==0) {
00053     <span class="comment">// initialise statics</span>
00054     time = <span class="keyword">this</span>;
00055     
00056     <span class="comment">/*</span>
00057 <span class="comment">    // We use itimers to monitor passing time - but don't make use of signals for notification</span>
00058 <span class="comment">    //  set the itimer SIGALRM to be ignored</span>
00059 <span class="comment">    struct sigaction act;</span>
00060 <span class="comment">    act.sa_handler = SIG_IGN;</span>
00061 <span class="comment">    sigemptyset(&amp;act.sa_mask);</span>
00062 <span class="comment">    act.sa_flags=0;</span>
00063 <span class="comment">    sigaction(SIGALRM, &amp;act, 0);</span>
00064 <span class="comment">    */</span>
00065 
00066     <span class="comment">// Get current system time to use as base (so the real-time starts at 0)</span>
00067     <span class="keyword">struct </span>timeval now;
00068     gettimeofday(&amp;now,0);
00069     baseSecs = now.tv_sec;
00070     baseMicros = now.tv_usec;
00071 
00072     usleep(1);
00073     
00074     gettimeofday(&amp;now,0);
00075     resolution = (now.tv_usec - baseMicros) + microsPerSec*(now.tv_sec - baseSecs);
00076 
00077     <span class="keywordflow">if</span> (resolution &gt; minResolution) {
00078       
00079       <span class="comment">// it is possible the timer wrapped, so just do the calculation again, just in case</span>
00080       gettimeofday(&amp;now,0);
00081       baseSecs = now.tv_sec;
00082       baseMicros = now.tv_usec;
00083       usleep(1);
00084       
00085       gettimeofday(&amp;now,0);
00086       resolution = (now.tv_usec - baseMicros) + microsPerSec*(now.tv_sec - baseSecs);
00087       
00088       <span class="keywordflow">if</span> (resolution &gt; minResolution) {   
00089         <a class="code" href="base.html#a3">Logln</a>(<span class="stringliteral">"WARNING: time resolution is only "</span> &lt;&lt; resolution &lt;&lt; <span class="stringliteral">"us.  It may be too coarse."</span>);
00090       }
00091       
00092     }
00093     <span class="comment">//Logln("Time resolution: " &lt;&lt; resolution &lt;&lt; "us ; " &lt;&lt; (Real(resolution)/Real(1000000)) &lt;&lt; "s" &lt;&lt; " ; 1/" &lt;&lt; 1.0/(Real(resolution)/Real(1000000)) &lt;&lt; "th of a sec" );</span>
00094   }
00095 
00096   secs=micros=0;
00097 }
00098 
00099 
00100 
00101 Time::Time(Real secs)
00102 {
00103   this-&gt;secs = long(secs);
00104   micros = long((secs-<a class="code" href="namespacebase.html#a5">Real</a>(this-&gt;secs))*<a class="code" href="namespacebase.html#a5">Real</a>(microsPerSec));
00105 }
00106 
00107 
00108 Time::~Time()
00109 {
00110   <span class="keywordflow">if</span> (<span class="keyword">this</span>==time) {
00111     <span class="comment">// cleanup statics</span>
00112 
00113     time=0;
00114   }
00115 }
00116 
00117 
00118 <span class="keyword">const</span> Time&amp; Time::now()
00119 {
00120   <span class="keyword">struct </span>timeval now;
00121   gettimeofday(&amp;now,0);
00122   lastNow.secs = now.tv_sec - baseSecs;
00123   lastNow.micros = now.tv_usec - baseMicros;
00124   <span class="keywordflow">if</span> (lastNow.micros &lt; 0) {
00125     lastNow.micros += microsPerSec;
00126     lastNow.secs--;
00127   }
00128   <span class="keywordflow">return</span> lastNow;
00129 }
00130 
00131 
00132 <span class="keywordtype">bool</span> Time::less(<span class="keyword">const</span> Time&amp; t1, <span class="keyword">const</span> Time&amp; t2)
00133 {
00134   <span class="keywordflow">if</span> (t1.secs &lt; t2.secs)
00135     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00136   <span class="keywordflow">else</span>
00137     <span class="keywordflow">if</span> (t1.secs == t2.secs)
00138       <span class="keywordflow">return</span> (t1.micros &lt; t2.micros);
00139 
00140   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00141 }
00142 
00143 
00144 <span class="keywordtype">bool</span> Time::greater(<span class="keyword">const</span> Time&amp; t1, <span class="keyword">const</span> Time&amp; t2)
00145 {
00146   <span class="keywordflow">if</span> (t1.secs &gt; t2.secs)
00147     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00148   <span class="keywordflow">else</span>
00149     <span class="keywordflow">if</span> (t1.secs == t2.secs)
00150       <span class="keywordflow">return</span> (t1.micros &gt; t2.micros);
00151 
00152   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00153 }
00154 
00155 
00156 <span class="keywordtype">void</span> Time::sleep(<span class="keyword">const</span> Time&amp; t)
00157 {
00158   <span class="keywordflow">if</span> (t.secs &gt; 0) ::sleep(t.secs);
00159   <span class="keywordflow">if</span> (t.micros &gt; 0) usleep(t.micros);
00160 }
00161 
00162 
00163 <span class="keywordtype">void</span> Time::sleep(<span class="keywordtype">long</span> secs, <span class="keywordtype">long</span> micros)
00164 {
00165   sleep(Time(secs,micros));
00166 }
00167 
00168 
00169 <span class="keywordtype">void</span> Time::normalize()
00170 {
00171   <span class="keywordflow">if</span> (secs &gt; 0) {
00172     <span class="keywordflow">while</span> (micros &lt; 0) {
00173       micros+= microsPerSec;
00174       secs--;
00175     }
00176     <span class="keywordflow">while</span> (micros &gt;= microsPerSec) {
00177       micros-= microsPerSec;
00178       secs++;
00179     }
00180   }
00181   
00182   <span class="keywordflow">if</span> (secs == 0) {
00183     <span class="keywordflow">while</span> (micros &gt;= microsPerSec) {
00184       micros-= microsPerSec;
00185       secs++;
00186     }
00187     <span class="keywordflow">while</span> (micros &lt;= -microsPerSec) {
00188       micros+= microsPerSec;
00189       secs--;
00190     }
00191   }
00192 
00193   <span class="keywordflow">if</span> (secs &lt; 0) {
00194     <span class="keywordflow">while</span> (micros &gt; 0) {
00195       micros-= microsPerSec;
00196       secs++;
00197     }
00198     <span class="keywordflow">while</span> (micros &lt;= -microsPerSec) {
00199       micros+= microsPerSec;
00200       secs--;
00201     }
00202   }
00203 
00204   <span class="keywordflow">if</span> (secs!=0) {
00205     <span class="keywordflow">if</span> ((secs&gt;0) &amp;&amp; (micros&lt;0)) {
00206       micros+=microsPerSec;
00207       secs--;
00208     }
00209     <span class="keywordflow">if</span> ((secs&lt;0) &amp;&amp; (micros&gt;0)) {
00210       micros-=microsPerSec;
00211       secs++;
00212     }
00213   }
00214 
00215 }
00216 
00217 
<a name="l00218"></a><a class="code" href="namespacebase.html#a187">00218</a> std::ostream&amp; <a class="code" href="namespacebase.html#a66">base::operator&lt;&lt;</a>(std::ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classbase_1_1Time.html">Time</a>&amp; t)
00219 {
00220   <span class="keywordflow">return</span> out &lt;&lt; t.<a class="code" href="classbase_1_1Time.html#base_1_1Timeo0">secs</a> &lt;&lt; <span class="stringliteral">"s:"</span> &lt;&lt; t.<a class="code" href="classbase_1_1Time.html#base_1_1Timeo1">micros</a> &lt;&lt; <span class="stringliteral">"us"</span>;
00221 }
00222 
00223 
00224 Time&amp; Time::operator-=(<span class="keyword">const</span> Time&amp; t)
00225 {
00226   <span class="keywordtype">long</span> ds = secs - t.secs;
00227   <span class="keywordtype">long</span> dm = micros - t.micros;
00228 
00229   Time r(ds,dm);
00230   r.normalize();
00231   *<span class="keyword">this</span> = r;
00232   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00233 }
00234 
00235 
00236 Time&amp; Time::operator+=(<span class="keyword">const</span> Time&amp; t)
00237 {
00238   <span class="keywordtype">long</span> ss = secs + t.secs;
00239   <span class="keywordtype">long</span> sm = micros + t.micros;
00240 
00241   Time r(ss,sm);
00242   r.normalize();
00243   *<span class="keyword">this</span> = r;
00244   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00245 }
00246 
00247 
00248 Time&amp; Time::operator*=(Real s)
00249 {
00250   <a class="code" href="namespacebase.html#a5">Real</a> rs = <a class="code" href="namespacebase.html#a5">Real</a>(secs)*s;
00251   <span class="keywordtype">long</span> ss = long(rs);
00252   <a class="code" href="namespacebase.html#a5">Real</a> ds = rs - ss;
00253   
00254   <span class="keywordtype">long</span> sm = long( <a class="code" href="namespacebase.html#a5">Real</a>(micros)*s );
00255   sm += long( ds*microsPerSec );
00256 
00257   Time r(ss,sm);
00258   r.normalize();
00259   *<span class="keyword">this</span> = r;
00260   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00261 }
00262 
00263 
00264 <span class="keywordtype">void</span> Time::serialize(Serializer&amp; s)
00265 { 
00266   s(<a class="code" href="namespacebase.html#a3">LInt</a>(secs),<span class="stringliteral">"secs"</span>); s(<a class="code" href="namespacebase.html#a3">LInt</a>(micros),<span class="stringliteral">"micros"</span>); 
00267 }
00268 
00269 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:15 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
