<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: physics/OBBCollisionModel.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>physics/OBBCollisionModel.cpp</h1><a href="OBBCollisionModel_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: OBBCollisionModel.cpp 1031 2004-02-11 20:46:36Z jungd $</span>
00019 <span class="comment">  $Revision: 1.6 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:46:36 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="OBBCollisionModel.html">physics/OBBCollisionModel</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="Box.html">physics/Box</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="TriangleContainer.html">gfx/TriangleContainer</a>&gt;</span>
00029 <span class="preprocessor">#include &lt;<a class="code" href="TriangleIterator.html">gfx/TriangleIterator</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;<a class="code" href="Triangle3.html">gfx/Triangle3</a>&gt;</span>
00031 <span class="preprocessor">#include &lt;<a class="code" href="Color4.html">gfx/Color4</a>&gt;</span>
00032 
00033 <span class="preprocessor">#include &lt;osg/Node&gt;</span>
00034 <span class="preprocessor">#include &lt;osg/Group&gt;</span>
00035 <span class="preprocessor">#include &lt;osg/MatrixTransform&gt;</span>
00036 <span class="preprocessor">#include &lt;osg/StateSet&gt;</span>
00037 <span class="preprocessor">#include &lt;osg/Material&gt;</span>
00038 <span class="preprocessor">#include &lt;osg/Vec4&gt;</span>
00039 <span class="preprocessor">#include &lt;osg/PolygonMode&gt;</span>
00040 
00041 
00042 
00043 <span class="keyword">using</span> <a class="code" href="classphysics_1_1OBBCollisionModel.html">physics::OBBCollisionModel</a>;
00044 <span class="keyword">using</span> <a class="code" href="classphysics_1_1Box.html">physics::Box</a>;
00045 
00046 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>;
00047 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Color4.html">gfx::Color4</a>;
00048 <span class="keyword">using</span> <a class="code" href="classgfx_1_1TriangleContainer.html">gfx::TriangleContainer</a>;
00049 <span class="keyword">using</span> <a class="code" href="classgfx_1_1TriangleIterator.html">gfx::TriangleIterator</a>;
00050 
00051 <span class="keyword">using</span> <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a>;
00052 <span class="keyword">using</span> base::transpose;
00053 <span class="keyword">using</span> base::cross;
00054 <span class="keyword">using</span> <a class="code" href="classbase_1_1array.html">base::array</a>;
00055 
00056 <span class="keyword">using</span> osg::Vec4;
00057 <span class="keyword">using</span> osg::StateSet;
00058 
00059 
00060 OBBCollisionModel::OBBCollisionModel(<span class="keyword">const</span> <a class="code" href="classgfx_1_1TriangleContainer.html">gfx::TriangleContainer</a>&amp; triangles)
00061   : b(*new <a class="code" href="base_2Jamfile_8ft.html#a0">base</a>::array&lt;OBB&gt;()), tris(*new <a class="code" href="base_2Jamfile_8ft.html#a0">base</a>::array&lt;Triangle3&gt;())
00062 {
00063   <span class="comment">// Copy all the triangles into an array (tris)</span>
00064   <a class="code" href="namespacebase.html#a2">Int</a> <span class="keywordtype">id</span>=0;
00065   
00066   TriangleContainer::const_iterator t = triangles.<a class="code" href="classgfx_1_1TriangleContainer.html#gfx_1_1VisualTrianglesa5">begin</a>();
00067   TriangleContainer::const_iterator end = triangles.<a class="code" href="classgfx_1_1TriangleContainer.html#gfx_1_1VisualTrianglesa6">end</a>();
00068   <span class="keywordflow">while</span> (t != end) {
00069     <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.at(<span class="keywordtype">id</span>++) = (*t);
00070     ++t;
00071   }
00072   <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.trim();
00073 
00074   <span class="keywordflow">if</span> (!<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.empty()) {
00075     <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelb0">buildHierarchy</a>(); <span class="comment">// Build the model</span>
00076   }
00077 
00078 }
00079 
00080 OBBCollisionModel::OBBCollisionModel(<span class="keyword">const</span> OBBCollisionModel&amp; cm)
00081   : b(*new <a class="code" href="base_2Jamfile_8ft.html#a0">base</a>::array&lt;OBB&gt;(cm.b)),
00082     tris(*new <a class="code" href="base_2Jamfile_8ft.html#a0">base</a>::array&lt;Triangle3&gt;(cm.tris))
00083 {
00084 }
00085 
00086 OBBCollisionModel::~OBBCollisionModel()
00087 {
00088   <span class="keyword">delete</span> &amp;<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>;
00089   <span class="keyword">delete</span> &amp;<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp0">b</a>;
00090 }
00091 
00092 
00093 <span class="keywordtype">void</span> OBBCollisionModel::buildHierarchy()
00094 {
00095   array&lt;Moment&gt; moment(<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size());
00096   array&lt;OBB&gt;&amp; boxes(b);
00097   <a class="code" href="namespacebase.html#a2">Int</a> OBBsInited = 1; 
00098   boxes.resize(<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size()*2);
00099   
00100   <span class="comment">// Determine initial orientation, mean point, and splitting axis.</span>
00101   Moment  <a class="code" href="general_8h.html#a54">M</a>;
00102   Matrix3 C;
00103   
00104   Moment::computeMoment(moment, tris, 0, <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size());
00105 
00106   <a class="code" href="general_8h.html#a54">M</a>.clear();
00107   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size(); i++) {
00108     <a class="code" href="general_8h.html#a54">M</a>.accumulate(moment[i]);
00109   }
00110 
00111   <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp0">b</a>[0].pT = <a class="code" href="general_8h.html#a54">M</a>.meanFromAccum();
00112   C = <a class="code" href="general_8h.html#a54">M</a>.covariance();
00113   
00114   <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelf0">eigenAndSort1</a>(b[0].pR, C);
00115   
00116   <span class="comment">// create the index list</span>
00117   <a class="code" href="namespacebase.html#a2">Int</a>* t = <span class="keyword">new</span> <a class="code" href="namespacebase.html#a2">Int</a>[<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size()];
00118   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size(); i++) t[i]=i;
00119   
00120   <span class="comment">// do the build</span>
00121   OBBsInited = <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp0">b</a>[0].splitRecurse(tris,moment,boxes,OBBsInited,t,0,<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.size());
00122   
00123   <span class="keyword">delete</span>[] t;
00124 }
00125 
00126 
00127 <a class="code" href="namespacebase.html#a2">Int</a> OBBCollisionModel::eigenAndSort1(Matrix3&amp; evecs, <span class="keyword">const</span> Matrix3&amp; cov, Int maxIterations)
00128 {
00129   Vector3 evals;
00130   
00131   <a class="code" href="namespacebase.html#a2">Int</a> n = cov.eigenJacobi(evecs, evals, maxIterations);
00132 
00133   <span class="comment">// not a full sort -- just makes column 1 the largest</span>
00134   <span class="keywordflow">if</span> (evals.z &gt; evals.x) {
00135     <span class="keywordflow">if</span> (evals.z &gt; evals.y) {
00136       <span class="comment">// 3 is largest, swap with column 1</span>
00137       evecs.swapColumns(3,1);
00138     }
00139     <span class="keywordflow">else</span> {
00140       <span class="comment">// 2 is largest, swap with column 1</span>
00141       evecs.swapColumns(2,1);
00142     }
00143   }
00144   <span class="keywordflow">else</span> {
00145     <span class="keywordflow">if</span> (evals.x &gt; evals.y) {
00146       <span class="comment">// 1 is largest, do nothing</span>
00147     }
00148     <span class="keywordflow">else</span> {
00149       <span class="comment">// 2 is largest</span>
00150       evecs.swapColumns(1,2);
00151     }
00152   }
00153   
00154   <span class="comment">// we are returning the number of iterations eigenJacobi took.</span>
00155   <span class="comment">// too many iterations means our chosen orientation is bad.</span>
00156   <span class="keywordflow">return</span> n; 
00157 }
00158 
00159 
00160 
00161 
00162 
00163 
00164 
00165 
00166 
00167 <span class="comment">// OBB implementation</span>
00168 
00169 <span class="keywordtype">void</span> OBBCollisionModel::OBB::reaccumMoments(Moment&amp; A, <a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; moment,
00170                                             Int t[], Int f, Int n)
00171 {
00172   A.clear();
00173   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0;i&lt;n;i++) 
00174     A.accumulate(moment[t[f+i]]);
00175 }
00176 
00177 
00178 <a class="code" href="namespacebase.html#a2">Int</a> OBBCollisionModel::OBB::splitRecurse(<a class="code" href="classbase_1_1array.html">base::array&lt;gfx::Triangle3&gt;</a>&amp; tri, 
00179                                          <a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; moment, 
00180                                          <a class="code" href="classbase_1_1array.html">base::array&lt;OBB&gt;</a>&amp; boxes,
00181                                          Int OBBsInited, Int t[], Int f, Int n)
00182 {
00183   <span class="comment">// The orientation for the parent box is already assigned to this-&gt;pR.</span>
00184   <span class="comment">// The axis along which to split will be column 0 of this-&gt;pR.</span>
00185   <span class="comment">// The mean point is passed in on this-&gt;pT.</span>
00186   
00187   <span class="comment">// When this routine completes, the position and orientation in model</span>
00188   <span class="comment">// space will be established, as well as its dimensions.  Child boxes</span>
00189   <span class="comment">// will be constructed and placed in the parent's CS.</span>
00190   
00191   <span class="keywordflow">if</span> (n == 1)
00192     <span class="keywordflow">return</span> splitRecurse(tri,moment,boxes,OBBsInited,t,f);
00193   
00194   
00195   <span class="comment">// walk along the tris for the box, and do the following:</span>
00196   <span class="comment">//   1. collect the max and min of the vertices along the axes of &lt;or&gt;.</span>
00197   <span class="comment">//   2. decide which group the triangle goes in, performing appropriate swap.</span>
00198   <span class="comment">//   3. accumulate the mean point and covariance data for that triangle.</span>
00199   
00200   Moment M1, M2;
00201   Matrix3 C;
00202   Vector3 c;
00203   Vector3 minval, maxval;
00204   
00205   <a class="code" href="namespacebase.html#a2">Int</a> in;
00206   <a class="code" href="namespacebase.html#a2">Int</a> i;
00207   <a class="code" href="namespacebase.html#a5">Real</a> axdmp;
00208   <a class="code" href="namespacebase.html#a2">Int</a> n1 = 0;  <span class="comment">// The number of tris in group 1.  </span>
00209   <span class="comment">// Group 2 will have n - n1 tris.</span>
00210         
00211   <span class="comment">// project approximate mean point onto splitting axis, and get coord.</span>
00212   axdmp = (pR.e(1,1) * pT.x + pR.e(2,1) * pT.y + pR.e(3,1) * pT.z);
00213   
00214   M1.clear();
00215   M2.clear();
00216 
00217   Matrix3 pRT = <a class="code" href="namespacebase.html#a98">transpose</a>(pR);
00218   
00219   c = pRT * tri[t[<a class="code" href="Makefile_8in.html#a5">f</a>]].p1();
00220   
00221   minval = c;
00222   maxval = c;
00223 
00224   <span class="keywordflow">for</span>(i=0; i&lt;n; i++) {
00225     in = t[<a class="code" href="Makefile_8in.html#a5">f</a>+i];
00226     Triangle3&amp; ptr(tri[in]);
00227     
00228     c = pRT*ptr.p1();
00229     minmax(minval, maxval, c);
00230     
00231     c = pRT*ptr.p2();
00232     minmax(minval, maxval, c);
00233     
00234     c = pRT*ptr.p3();
00235     minmax(minval, maxval, c);
00236     
00237     <span class="comment">// grab the mean point of the in'th triangle, project</span>
00238     <span class="comment">// it onto the splitting axis (1st column of pR) and</span>
00239     <span class="comment">// see where it lies with respect to axdmp.</span>
00240     c = moment[in].meanFromMoment();
00241     
00242     <span class="keywordflow">if</span> ( (((pR.e(1,1)*c.x + pR.e(2,1)*c.y + pR.e(3,1)*c.z) &lt; axdmp)
00243           &amp;&amp; (n!=2)) || ((n==2) &amp;&amp; (i==0)) ) {
00244       <span class="comment">// accumulate first and second order moments for group 1</span>
00245       M1.accumulate(moment[in]);
00246       
00247       <span class="comment">// put it in group 1 by swapping t[i] with t[n1]</span>
00248       <a class="code" href="namespacebase.html#a2">Int</a> temp = t[<a class="code" href="Makefile_8in.html#a5">f</a>+i];
00249       t[<a class="code" href="Makefile_8in.html#a5">f</a>+i] = t[<a class="code" href="Makefile_8in.html#a5">f</a>+n1];
00250       t[<a class="code" href="Makefile_8in.html#a5">f</a>+n1] = temp;
00251       n1++;
00252     }
00253     <span class="keywordflow">else</span> {
00254       <span class="comment">// accumulate first and second order moments for group 2</span>
00255       M2.accumulate(moment[in]);
00256       
00257       <span class="comment">// leave it in group 2</span>
00258       <span class="comment">// do nothing...it happens by default</span>
00259     }
00260   }
00261   
00262   <span class="comment">// done using this.pT as a mean point.</span>
00263   
00264   <span class="comment">// error check!</span>
00265   <span class="keywordflow">if</span> ((n1 == 0) || (n1 == n)) {
00266     <span class="comment">// our partitioning has failed: all the triangles fell into just</span>
00267     <span class="comment">// one of the groups.  So, we arbitrarily partition them into</span>
00268     <span class="comment">// equal parts, and proceed.</span>
00269     <span class="comment">//Debugln("Warning: Triangle partitioning failed. Partitioning equally.");    </span>
00270     n1 = n/2;
00271     
00272     <span class="comment">// now recompute accumulated stuff</span>
00273     reaccumMoments(M1, moment, t, f, n1);
00274     reaccumMoments(M2, moment, t, f + n1, n - n1);
00275   }
00276   
00277   <span class="comment">// With the max and min data, determine the center point and dimensions</span>
00278   <span class="comment">// of the parent box.</span>
00279   
00280   c = (minval+maxval)/2.0;
00281   
00282   pT = pR*c; <span class="comment">// equiv of above?? !!!</span>
00283   d = (maxval-minval)/2.0;
00284   
00285   <span class="comment">// allocate new boxes</span>
00286   P = &amp;boxes[OBBsInited++];
00287   <a class="code" href="general_8h.html#a53">N</a> = &amp;boxes[OBBsInited++];
00288         
00289   <span class="comment">// Compute the orienations for the child boxes (eigenvectors of</span>
00290   <span class="comment">// covariance matrix).  Select the direction of maximum spread to be</span>
00291   <span class="comment">// the split axis for each child.</span>
00292   
00293   Matrix3 tR;
00294   
00295   <span class="comment">// do the P child</span>
00296   <span class="keywordflow">if</span> (n1 &gt; 1) {
00297     P-&gt;pT = M1.meanFromAccum();
00298     C = M1.covariance();
00299     
00300     <span class="keywordflow">if</span> (OBBCollisionModel::eigenAndSort1(tR, C, 30) &gt;= 30) {
00301       <span class="comment">// unable to find an orientation.  We'll just pick identity.</span>
00302       tR.setIdentity();
00303     }
00304     
00305     P-&gt;pR = tR;
00306     OBBsInited = P-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f, n1);
00307   }
00308   <span class="keywordflow">else</span> {
00309     OBBsInited = P-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f);
00310   }
00311   C = P-&gt;pR; P-&gt;pR = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*C;  <span class="comment">// and F1 </span>
00312   c = P-&gt;pT - pT; P-&gt;pT = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*c;
00313   
00314   <span class="comment">// do the N child</span>
00315   <span class="keywordflow">if</span> ((n-n1) &gt; 1) {
00316     <a class="code" href="general_8h.html#a53">N</a>-&gt;pT = M2.meanFromAccum();
00317     C = M2.covariance();
00318     
00319     <span class="keywordflow">if</span> (OBBCollisionModel::eigenAndSort1(tR, C) &gt; 30) {
00320       <span class="comment">// unable to find an orientation.  We'll just pick identity.</span>
00321       tR.setIdentity();
00322     }
00323     
00324     <a class="code" href="general_8h.html#a53">N</a>-&gt;pR = tR;
00325     OBBsInited = <a class="code" href="general_8h.html#a53">N</a>-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f + n1, n - n1);
00326   }
00327   <span class="keywordflow">else</span> {
00328     OBBsInited = <a class="code" href="general_8h.html#a53">N</a>-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f+n1);
00329   }
00330   C = <a class="code" href="general_8h.html#a53">N</a>-&gt;pR; <a class="code" href="general_8h.html#a53">N</a>-&gt;pR = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*C;
00331   c = <a class="code" href="general_8h.html#a53">N</a>-&gt;pT-pT; <a class="code" href="general_8h.html#a53">N</a>-&gt;pT = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*c;
00332   
00333   <span class="keywordflow">return</span> OBBsInited;
00334 }
00335 
00336 
00337 <span class="comment">// specialized for leaf nodes</span>
00338 <a class="code" href="namespacebase.html#a2">Int</a> OBBCollisionModel::OBB::splitRecurse(<a class="code" href="classbase_1_1array.html">base::array&lt;gfx::Triangle3&gt;</a>&amp; tri, 
00339                                          <a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; moment, 
00340                                          <a class="code" href="classbase_1_1array.html">base::array&lt;OBB&gt;</a>&amp; boxes,
00341                                          Int OBBsInited, Int t[], Int f)
00342 {
00343   <span class="comment">// For a single triangle, orientation is easily determined.</span>
00344   <span class="comment">// The major axis is parallel to the longest edge.</span>
00345   <span class="comment">// The minor axis is normal to the triangle.</span>
00346   <span class="comment">// The in-between axis is determine by these two.</span>
00347   
00348   <span class="comment">// this.pR, this.d, and this.pT are set herein.</span>
00349   
00350   P = <a class="code" href="general_8h.html#a53">N</a> = 0;
00351   Triangle3&amp; ptr(tri[t[f]]);
00352   
00353   <span class="comment">// Find the major axis: parallel to the longest edge.</span>
00354   Vector3 u12, u23, u31;
00355   
00356   <span class="comment">// First compute the squared-lengths of each edge</span>
00357   u12 = ptr.p1()-ptr.p2();
00358   <a class="code" href="namespacebase.html#a5">Real</a> d12 = u12.norm();
00359   u23 = ptr.p2()-ptr.p3();  
00360   <a class="code" href="namespacebase.html#a5">Real</a> d23 = u23.norm();
00361   u31 = ptr.p3()-ptr.p1();  
00362   <a class="code" href="namespacebase.html#a5">Real</a> d31 = u31.norm();
00363   
00364   <span class="comment">// Find the edge of longest squared-length, normalize it to</span>
00365   <span class="comment">// unit length, and put result into a0.</span>
00366   Vector3 a0;
00367   <span class="keywordflow">if</span> (d12 &gt; d23) {
00368     <span class="keywordflow">if</span> (d12 &gt; d31) 
00369       a0 = u12 / <a class="code" href="namespacebase.html#a63">base::sqrt</a>(d12);
00370     <span class="keywordflow">else</span> 
00371       a0 = u31 / <a class="code" href="namespacebase.html#a63">base::sqrt</a>(d31);
00372   }
00373   <span class="keywordflow">else</span> {
00374     <span class="keywordflow">if</span> (d23 &gt; d31) 
00375       a0 = u23 / <a class="code" href="namespacebase.html#a63">base::sqrt</a>(d23);
00376     <span class="keywordflow">else</span> 
00377       a0 = u31 / <a class="code" href="namespacebase.html#a63">base::sqrt</a>(d31);
00378   }
00379   
00380   <span class="comment">// Now compute unit normal to triangle, and put into a2.</span>
00381   Vector3 a2;
00382   a2 = <a class="code" href="namespacebase.html#a243">cross</a>(u12,u23);
00383   a2.normalize();
00384   
00385   <span class="comment">// a1 is a2 cross a0.</span>
00386   Vector3 a1;
00387   a1 = <a class="code" href="namespacebase.html#a243">cross</a>(a2,a0);
00388   
00389   <span class="comment">// Now make the columns of this.pR the vectors a0, a1, and a2.</span>
00390   pR.e(1,1) = a0.x;  pR.e(1,2) = a1.x;  pR.e(1,3) = a2.x;
00391   pR.e(2,1) = a0.y;  pR.e(2,2) = a1.y;  pR.e(2,3) = a2.y;
00392   pR.e(3,1) = a0.z;  pR.e(3,2) = a1.z;  pR.e(3,3) = a2.z;
00393   
00394   <span class="comment">// Now compute the maximum and minimum extents of each vertex </span>
00395   <span class="comment">// along each of the box axes.  From this we will compute the </span>
00396   <span class="comment">// box center and box dimensions.</span>
00397   Vector3 minval, maxval;
00398   Vector3 c;
00399   
00400   c = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*ptr.p1();
00401   minval=c; maxval=c;
00402   
00403   c = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*ptr.p2();
00404   minmax(minval, maxval, c);
00405   
00406   c = <a class="code" href="namespacebase.html#a98">transpose</a>(pR)*ptr.p3();
00407   minmax(minval, maxval, c);
00408   
00409   <span class="comment">// With the max and min data, determine the center point and dimensions</span>
00410   <span class="comment">// of the box</span>
00411   c = (minval+maxval)/2.0;
00412   
00413   pT = pR*c; <span class="comment">// !!! check equiv of above        </span>
00414   d = (maxval-minval)/2.0;
00415   
00416   <span class="comment">// Assign the one triangle to this box</span>
00417   tr = ptr;
00418   
00419   <span class="keywordflow">return</span> OBBsInited;
00420 }
00421 
00422 
00423 <span class="keywordtype">void</span> OBBCollisionModel::OBB::minmax(gfx::Vector3&amp; min, gfx::Vector3&amp; max, 
00424                                     <span class="keyword">const</span> gfx::Vector3&amp; v)
00425 {
00426   <span class="keywordflow">if</span> (v.x &lt; min.x) 
00427     min.x = v.x;
00428   <span class="keywordflow">else</span>
00429     <span class="keywordflow">if</span> (v.x &gt; max.x)
00430       max.x = v.x;
00431   <span class="keywordflow">if</span> (v.y &lt; min.y) 
00432     min.y = v.y;
00433   <span class="keywordflow">else</span>
00434     <span class="keywordflow">if</span> (v.y &gt; max.y)
00435       max.y = v.y;
00436   <span class="keywordflow">if</span> (v.z &lt; min.z) 
00437     min.z = v.z;
00438   <span class="keywordflow">else</span>
00439     <span class="keywordflow">if</span> (v.z &gt; max.z)
00440       max.z = v.z;
00441 }
00442 
00443 
00444 
00445 <span class="comment">// Moment implementation</span>
00446 
00447 <span class="keywordtype">void</span> OBBCollisionModel::Moment::clear()
00448 {
00449   A = 0;
00450   m.setZero();
00451   s.setZero();
00452 }
00453 
00454 
00455 <span class="keywordtype">void</span> OBBCollisionModel::Moment::accumulate(<span class="keyword">const</span> Moment&amp; b)
00456 {
00457   m += b.m*b.A;
00458   s += b.s;
00459   A += b.A;
00460 }
00461 
00462 
00463 <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a> OBBCollisionModel::Moment::covariance()<span class="keyword"> const </span>
00464 <span class="keyword"></span>{
00465   <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a> C = s;
00466   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(1,1) -= m.x*m.x/A;
00467   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(1,2) -= m.x*m.y/A;
00468   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(1,3) -= m.x*m.z/A;
00469   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(2,1) -= m.y*m.x/A;
00470   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(2,2) -= m.y*m.y/A;
00471   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(2,3) -= m.y*m.z/A;
00472   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(3,1) -= m.z*m.x/A;
00473   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(3,2) -= m.z*m.y/A;
00474   C.<a class="code" href="classbase_1_1Matrix3.html#base_1_1Matrix3a7">e</a>(3,3) -= m.z*m.z/A;
00475   <span class="keywordflow">return</span> C;
00476 }
00477 
00478 
00479 <span class="keywordtype">void</span> OBBCollisionModel::Moment::computeMoment(Moment&amp; M, <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; p,
00480                                               <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; q, <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; r)
00481 {
00482   Vector3 u,v,w;
00483   
00484   <span class="comment">// compute the area of the triangle</span>
00485   u = q-p;
00486   v = r-p;
00487   w = <a class="code" href="namespacebase.html#a243">cross</a>(u,v);
00488   <a class="code" href="general_8h.html#a54">M</a>.A = 0.5*w.length();
00489   
00490   <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a54">M</a>.A == 0.0) {
00491     <span class="comment">// This triangle has zero area.  The second order components</span>
00492     <span class="comment">// would be eliminated with the usual formula, so, for the </span>
00493     <span class="comment">// sake of robustness we use an alternative form.  These are the </span>
00494     <span class="comment">// centroid and second-order components of the triangle's vertices.</span>
00495     
00496     <span class="comment">// centroid</span>
00497     <a class="code" href="general_8h.html#a54">M</a>.m = (p+q+r)/3.0;
00498     
00499     <span class="comment">// second-order components</span>
00500     <a class="code" href="general_8h.html#a54">M</a>.s.e(1,1) = (p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a> + q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a> + r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>);
00501     <a class="code" href="general_8h.html#a54">M</a>.s.e(1,2) = (p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a> + q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a> + r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>);
00502     <a class="code" href="general_8h.html#a54">M</a>.s.e(1,3) = (p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a> + q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a> + r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>);
00503     <a class="code" href="general_8h.html#a54">M</a>.s.e(2,2) = (p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a> + q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a> + r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>);
00504     <a class="code" href="general_8h.html#a54">M</a>.s.e(2,3) = (p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a> + q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a> + r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>);
00505     <a class="code" href="general_8h.html#a54">M</a>.s.e(3,3) = (p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a> + q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a> + r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>);      
00506     <a class="code" href="general_8h.html#a54">M</a>.s.e(3,2) = <a class="code" href="general_8h.html#a54">M</a>.s.e(2,3);
00507     <a class="code" href="general_8h.html#a54">M</a>.s.e(2,1) = <a class="code" href="general_8h.html#a54">M</a>.s.e(1,2);
00508     <a class="code" href="general_8h.html#a54">M</a>.s.e(3,1) = <a class="code" href="general_8h.html#a54">M</a>.s.e(1,3);
00509     
00510     <span class="keywordflow">return</span>;
00511   }
00512   
00513   <span class="comment">// get the centroid</span>
00514   <a class="code" href="general_8h.html#a54">M</a>.m = (p+q+r)/3.0;
00515   
00516   <span class="comment">// get the second order components -- note the weighting by the area</span>
00517   <a class="code" href="general_8h.html#a54">M</a>.s.e(1,1) = <a class="code" href="general_8h.html#a54">M</a>.A*(9.0*<a class="code" href="general_8h.html#a54">M</a>.m.x*<a class="code" href="general_8h.html#a54">M</a>.m.x+p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>+q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>+r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>)/12.0;
00518   <a class="code" href="general_8h.html#a54">M</a>.s.e(1,2) = <a class="code" href="general_8h.html#a54">M</a>.A*(9.0*<a class="code" href="general_8h.html#a54">M</a>.m.x*<a class="code" href="general_8h.html#a54">M</a>.m.y+p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>+q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>+r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>)/12.0;
00519   <a class="code" href="general_8h.html#a54">M</a>.s.e(1,3) = <a class="code" href="general_8h.html#a54">M</a>.A*(9.0*<a class="code" href="general_8h.html#a54">M</a>.m.x*<a class="code" href="general_8h.html#a54">M</a>.m.z+p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>+q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>+r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>)/12.0;
00520   <a class="code" href="general_8h.html#a54">M</a>.s.e(2,2) = <a class="code" href="general_8h.html#a54">M</a>.A*(9.0*<a class="code" href="general_8h.html#a54">M</a>.m.y*<a class="code" href="general_8h.html#a54">M</a>.m.y+p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>+q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>+r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>)/12.0;
00521   <a class="code" href="general_8h.html#a54">M</a>.s.e(2,3) = <a class="code" href="general_8h.html#a54">M</a>.A*(9.0*<a class="code" href="general_8h.html#a54">M</a>.m.y*<a class="code" href="general_8h.html#a54">M</a>.m.z+p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>+q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>+r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>)/12.0;
00522   <a class="code" href="general_8h.html#a54">M</a>.s.e(3,3) = <a class="code" href="general_8h.html#a54">M</a>.A*(9.0*<a class="code" href="general_8h.html#a54">M</a>.m.z*<a class="code" href="general_8h.html#a54">M</a>.m.z+p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>+q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*q.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>+r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*r.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>)/12.0;
00523   <a class="code" href="general_8h.html#a54">M</a>.s.e(3,2) = <a class="code" href="general_8h.html#a54">M</a>.s.e(2,3);
00524   <a class="code" href="general_8h.html#a54">M</a>.s.e(2,1) = <a class="code" href="general_8h.html#a54">M</a>.s.e(1,2);
00525   <a class="code" href="general_8h.html#a54">M</a>.s.e(3,1) = <a class="code" href="general_8h.html#a54">M</a>.s.e(1,3);
00526 }
00527 
00528 
00529 <span class="keywordtype">void</span> OBBCollisionModel::Moment::computeMoment(<a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; M,
00530                                               <a class="code" href="classbase_1_1array.html">base::array&lt;gfx::Triangle3&gt;</a>&amp; tris,
00531                                               Int firstTri, Int numTris)
00532 {
00533   <span class="comment">// check implementation. (tri *tris, int num_tris)</span>
00534   
00535   <span class="comment">// first collect all the moments, and obtain the area of the </span>
00536   <span class="comment">// smallest nonzero area triangle.</span>
00537   <a class="code" href="namespacebase.html#a5">Real</a> Amin = 0.0;
00538   <span class="keywordtype">bool</span> zero=<span class="keyword">false</span>;
00539 
00540   Triangle3 tri;
00541   Moment m;
00542   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=firstTri; i&lt;firstTri+numTris; i++) {
00543     Moment&amp; m(M[i]);
00544     tri = tris[i];
00545     computeMoment(m, tri.p1(), tri.p2(), tri.p3());
00546 
00547     <span class="keywordflow">if</span> (m.A == 0.0)
00548       zero=<span class="keyword">true</span>;
00549     <span class="keywordflow">else</span> {
00550       <span class="keywordflow">if</span> (Amin == 0.0) 
00551         Amin = m.A;
00552       <span class="keywordflow">else</span> 
00553         <span class="keywordflow">if</span> (m.A &lt; Amin)
00554           Amin = m.A;
00555     }
00556     
00557   }
00558   
00559   <span class="keywordflow">if</span> (zero) {
00560     <a class="code" href="base.html#a7">Logfln</a>(<span class="stringliteral">"Warning: Some triangles have zero area."</span>);
00561 
00562     <span class="comment">// if there are any zero area triangles, go back and set their area</span>
00563     <span class="comment">// if ALL the triangles have zero area, then set the area thingy</span>
00564     <span class="comment">// to some arbitrary value.</span>
00565     <span class="keywordflow">if</span> (Amin == 0.0) Amin = 1.0;
00566     
00567     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=firstTri; i&lt;firstTri+numTris; i++) {
00568       Moment&amp; m(M[i]);
00569       <span class="keywordflow">if</span> ( m.A == 0.0) 
00570         m.A = Amin;
00571     }
00572   }
00573 }
00574 
00575 
00576 
00577 osg::Node* OBBCollisionModel::createOSGVisual(Visual::Attributes visualAttributes)<span class="keyword"> const</span>
00578 <span class="keyword"></span>{
00579   <span class="keywordflow">if</span> (!(visualAttributes &amp; <a class="code" href="classgfx_1_1Visual.html#gfx_1_1VisualPathw14gfx_1_1VisualPathw9">ShowCollisionModel</a>)
00580       || <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelp1">tris</a>.empty() ) 
00581     <span class="keywordflow">return</span> <span class="keyword">new</span> osg::Node();
00582   
00583   osg::Node* node = <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelb1">createOBBVisualRecurse</a>(b[0], 0);
00584   node-&gt;setName(<span class="stringliteral">"debug"</span>);
00585 
00586   <span class="comment">// Set state to be transparent, random colour</span>
00587   StateSet* state = <span class="keyword">new</span> osg::StateSet();
00588   osg::Material* mat = <span class="keyword">new</span> osg::Material();
00589   Vec4 col( Math::random(), Math::random(), Math::random(), 1.0);
00590   mat-&gt;setEmission( osg::Material::FRONT_AND_BACK, Vec4(0,0,0,0) );
00591   mat-&gt;setAmbient( osg::Material::FRONT_AND_BACK, col );
00592   mat-&gt;setDiffuse( osg::Material::FRONT_AND_BACK, col );
00593   mat-&gt;setSpecular( osg::Material::FRONT_AND_BACK, Vec4(1,1,1,0) );
00594   mat-&gt;setShininess( osg::Material::FRONT_AND_BACK, 0.3);
00595   state-&gt;setAttribute( mat );
00596   state-&gt;setMode(GL_CULL_FACE,osg::StateAttribute::OFF);
00597 
00598   osg::PolygonMode* polyMode = <span class="keyword">new</span> osg::PolygonMode;
00599   polyMode-&gt;setMode( osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE );
00600   state-&gt;setAttributeAndModes(polyMode,osg::StateAttribute::ON);
00601 
00602   node-&gt;setStateSet(state);
00603   
00604   <span class="keywordflow">return</span> node;
00605 }
00606 
00607 osg::Node* OBBCollisionModel::createOBBVisualRecurse(OBB&amp; obb, Int level)<span class="keyword"> const</span>
00608 <span class="keyword"></span>{
00609   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a> epsOffset = 0.01;
00610 
00611   osg::MatrixTransform* tn = <span class="keyword">new</span> osg::MatrixTransform();
00612   tn-&gt;setName(<span class="stringliteral">"OBB"</span>);
00613   <span class="comment">//  tn-&gt;setType(osg::Transform::STATIC); // is there an equiv??? !!!</span>
00614   Matrix4 m(obb.pR);
00615   m.setTranslationComponent(obb.pT);
00616   tn-&gt;setMatrix(m);
00617   
00618   <span class="keywordflow">if</span> (!<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelt2">onlyOneLevel</a> || (<a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelt1">onlyLevel</a>==level)) {
00619     ref&lt;Box&gt; box(NewObj Box(2*obb.d.x+epsOffset,2*obb.d.y+epsOffset,2*obb.d.z+epsOffset));
00620     <a class="code" href="debugtools.html#a7">Debugln</a>(Physics,<span class="stringliteral">"box leaf "</span> &lt;&lt; level);
00621     StateSet* state = <span class="keyword">new</span> osg::StateSet();
00622     osg::Material* mat = <span class="keyword">new</span> osg::Material();
00623     Vec4 col( Math::random(), Math::random(), Math::random(), 1.0);
00624     mat-&gt;setAmbient( osg::Material::FRONT_AND_BACK, col );
00625     mat-&gt;setDiffuse( osg::Material::FRONT_AND_BACK, col );
00626     state-&gt;setAttribute( mat );
00627 
00628     osg::PolygonMode* polyMode = <span class="keyword">new</span> osg::PolygonMode;
00629     polyMode-&gt;setMode( osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE );
00630     state-&gt;setAttributeAndModes(polyMode,osg::StateAttribute::ON);
00631 
00632     osg::Node* boxNode = box-&gt;createOSGVisual();
00633     boxNode-&gt;setStateSet(state);
00634     tn-&gt;addChild(boxNode);
00635   }
00636   
00637   <span class="keywordflow">if</span> (level &lt; <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelt0">maxLevels</a>) {
00638     <span class="keywordflow">if</span> (obb.N != 0) {
00639       tn-&gt;addChild( <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelb1">createOBBVisualRecurse</a>(*obb.N, level+1) );
00640     }
00641     <span class="keywordflow">if</span> (obb.P != 0) {
00642       tn-&gt;addChild( <a class="code" href="classphysics_1_1OBBCollisionModel.html#physics_1_1OBBCollisionModelb1">createOBBVisualRecurse</a>(*obb.P, level+1) );
00643     }
00644   }
00645   
00646   <span class="keywordflow">return</span> tn;
00647 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:25 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
