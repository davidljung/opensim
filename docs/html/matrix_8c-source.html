<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: robot/control/oldikor/UTILS/matrix.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>robot/control/oldikor/UTILS/matrix.c</h1><a href="matrix_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">*</span>
00003 <span class="comment">* File          : matrix.c</span>
00004 <span class="comment">* Author        : Ole Henry Dorum</span>
00005 <span class="comment">* Created       : January 28'th 1992</span>
00006 <span class="comment">* Purpose       : Perform matrix operations.</span>
00007 <span class="comment">* </span>
00008 <span class="comment">*****************************************************************************/</span>
00009 
00010 <span class="preprocessor">#include &lt;<a class="code" href="matrix_8h.html">UTILS/matrix.h</a>&gt;</span>
00011 
00012 <span class="comment">/****************************************************************************</span>
00013 <span class="comment"> **                                                                        **</span>
00014 <span class="comment"> **   Num Rec in C:    LU-decomp        &amp;   LU-backsubstitution            **</span>
00015 <span class="comment"> **                    SV-decomposition &amp;   SVD-backsubstitution           **</span>
00016 <span class="comment"> **                                                                        **</span>
00017 <span class="comment"> ****************************************************************************/</span>
<a name="l00018"></a><a class="code" href="matrix_8c.html#a0">00018</a> <span class="keyword">extern</span> FILE* <a class="code" href="fsp_8c.html#a3">gcheck</a>;     
00019 
00020 <span class="keyword">static</span> <span class="keywordtype">float</span> at,bt,ct;
00021 
00022               <span class="comment">/**************************************************/</span>
00023 
00024 
00025      <span class="comment">/***************************************************/</span>
00026      <span class="comment">/* Return the null space of a matrix using svd.    */</span>
00027      <span class="comment">/***************************************************/</span>
<a name="l00028"></a><a class="code" href="matrix_8h.html#a24">00028</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a24">mat_null</a>(a, n_rank, n, K2)
00029 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *n;
00030 <span class="keywordtype">int</span>    *n_rank;
00031 <span class="keywordtype">float</span>  *K2;
00032 {
00033   <a class="code" href="structMATRIX.html">MATRIX</a> *a_sqr,
00034          *v,
00035          *S_temp;
00036   <span class="keywordtype">float</span> **U, *S, **V,
00037         *<a class="code" href="nrutil_8h.html#a14">vector</a>(),
00038         **<a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>();
00039   <span class="keywordtype">float</span> s_min, s_max, temp;
00040   <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a25">free_vector</a>(),
00041        <a class="code" href="nrutil_8h.html#a27">free_ivector</a>();
00042   <span class="keywordtype">int</span> i, j, R, C, *order;
00043   <span class="keywordtype">int</span> *<a class="code" href="nrutil_8h.html#a21">ivector</a>();
00044 
00045   R = a-&gt;<a class="code" href="structMATRIX.html#MATRIXo1">rows</a>;
00046   C = a-&gt;cols;
00047 
00048   <span class="keywordflow">if</span> ((R==0) || (C==0)) {
00049       fprintf(stderr, <span class="stringliteral">"Can't calculate null-space of a 0x0 matrix.\n"</span>);
00050       <span class="keywordflow">return</span>;
00051   }
00052 
00053   S_temp = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(C+1,1);
00054   v      = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(C,C);
00055   V      = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(v);
00056   S      = <a class="code" href="nrutil_8h.html#a14">vector</a>(1,C);
00057   order  = <a class="code" href="nrutil_8h.html#a21">ivector</a>(1,C);
00058      
00059 
00060   <span class="keywordflow">if</span> (R &lt; C)
00061      {
00062      a_sqr = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(C,C);
00063      <span class="keywordflow">for</span> (i=0; i&lt;R; i++)
00064         <span class="keywordflow">for</span> (j=0; j&lt;C; j++)
00065            a_sqr-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][j]=a-&gt;p[i][j];
00066      <span class="keywordflow">for</span> (i=R; i&lt;C; i++)
00067         <span class="keywordflow">for</span> (j=0; j&lt;C; j++)
00068            a_sqr-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][j]=0.0;
00069      }
00070   <span class="keywordflow">else</span>
00071      {
00072      a_sqr = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(R,C);
00073      <a class="code" href="matrix_8h.html#a20">mat_cp</a>(a, a_sqr);
00074      }
00075 
00076   U = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(a_sqr);
00077 
00078   <a class="code" href="matrix_8h.html#a6">svdcmp</a>(U, C, C, S, V);
00079 
00080   <span class="keywordflow">for</span> (i=1; i&lt;(C+1); i++)
00081      {
00082      S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][0] = S[i];
00083      order[i] = i;
00084      }
00085   <span class="keywordflow">for</span> (i=C; i&gt;1; i--)
00086      <span class="keywordflow">for</span> (j=i-1; j&gt;=1; j--)
00087         <span class="keywordflow">if</span> (fabs(S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][0])&gt;fabs(S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[j][0]))
00088            {
00089            temp = S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][0];
00090            S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][0] = S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[j][0];
00091            S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[j][0] = temp;
00092            temp = order[i];
00093            order[i] = order[j];
00094            order[j] = temp;
00095            }
00096   <span class="keywordflow">if</span> (R&lt;=C)
00097      s_min = fabs(S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[R][0]);
00098   <span class="keywordflow">else</span>
00099      s_min = fabs(S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[C][0]);
00100   s_max = fabs(S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[1][0]);
00101 
00102   *n_rank = 0;
00103   <span class="keywordflow">while</span> (fabs(S_temp-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[C-*n_rank][0]) &lt; <a class="code" href="matrix_8h.html#a3">SV_SMALL</a>)
00104      {
00105      <span class="keywordflow">for</span> (j=1; j&lt;=C; j++)
00106         n-&gt;p[j-1][*n_rank]
00107           = V[j][order[C-*n_rank]];
00108      *n_rank = *n_rank + 1;
00109      }
00110  
00111   <span class="keywordflow">if</span> ((fabs(s_min)&gt;=<a class="code" href="matrix_8h.html#a3">SV_SMALL</a>) &amp;&amp; (fabs(s_min/s_max) &lt; <a class="code" href="matrix_8h.html#a3">SV_SMALL</a>))
00112      {
00113      <span class="keywordflow">for</span> (j=1; j&lt;=C; j++)
00114         n-&gt;p[j-1][*n_rank] = V[order[j]][C-*n_rank];
00115      *n_rank = *n_rank+1;
00116      }
00117 
00118   *K2 = s_max/s_min;
00119 
00120   <a class="code" href="matrix_8h.html#a8">mat_free</a>(v);
00121   <a class="code" href="matrix_8h.html#a8">mat_free</a>(a_sqr);
00122   <a class="code" href="matrix_8h.html#a8">mat_free</a>(S_temp);
00123   <a class="code" href="nrutil_8h.html#a25">free_vector</a>(S,1,C);
00124   <a class="code" href="nrutil_8h.html#a27">free_ivector</a>(order,1,C);
00125   free(V);
00126   free(U);
00127 }
00128 
00129 
00130 
<a name="l00131"></a><a class="code" href="matrix_8c.html#a5">00131</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a4">ludcmp</a>(a,n,indx,d)
00132 <span class="keywordtype">int</span> n,*indx;
00133 <span class="keywordtype">float</span> **a,*d;
00134 {
00135         <span class="keywordtype">int</span> i,imax,j,k;
00136         <span class="keywordtype">float</span> big,dum,sum,temp;
00137         <span class="keywordtype">float</span> *vv,*<a class="code" href="nrutil_8h.html#a14">vector</a>();
00138         <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a13">nrerror</a>(),<a class="code" href="nrutil_8h.html#a25">free_vector</a>();
00139 
00140         vv=<a class="code" href="nrutil_8h.html#a14">vector</a>(1,n);
00141         *d=1.0;
00142         <span class="keywordflow">for</span> (i=1;i&lt;=n;i++) {
00143                 big=0.0;
00144                 <span class="keywordflow">for</span> (j=1;j&lt;=n;j++)
00145                         <span class="keywordflow">if</span> ((temp=fabs(a[i][j])) &gt; big) big=temp;
00146                 <span class="keywordflow">if</span> (big == 0.0) <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"Singular matrix in routine LUDCMP"</span>);
00147                 vv[i]=1.0/big;
00148         }
00149         <span class="keywordflow">for</span> (j=1;j&lt;=n;j++) {
00150                 <span class="keywordflow">for</span> (i=1;i&lt;j;i++) {
00151                         sum=a[i][j];
00152                         <span class="keywordflow">for</span> (k=1;k&lt;i;k++) sum -= a[i][k]*a[k][j];
00153                         a[i][j]=sum;
00154                 }
00155                 big=0.0;
00156                 <span class="keywordflow">for</span> (i=j;i&lt;=n;i++) {
00157                         sum=a[i][j];
00158                         <span class="keywordflow">for</span> (k=1;k&lt;j;k++)
00159                                 sum -= a[i][k]*a[k][j];
00160                         a[i][j]=sum;
00161                         <span class="keywordflow">if</span> ( (dum=vv[i]*fabs(sum)) &gt;= big) {
00162                                 big=dum;
00163                                 imax=i;
00164                         }
00165                 }
00166                 <span class="keywordflow">if</span> (j != imax) {
00167                         <span class="keywordflow">for</span> (k=1;k&lt;=n;k++) {
00168                                 dum=a[imax][k];
00169                                 a[imax][k]=a[j][k];
00170                                 a[j][k]=dum;
00171                         }
00172                         *d = -(*d);
00173                         vv[imax]=vv[j];
00174                 }
00175                 indx[j]=imax;
00176                 <span class="keywordflow">if</span> (a[j][j] == 0.0) a[j][j]=<a class="code" href="matrix_8h.html#a2">TINY</a>;
00177                 <span class="keywordflow">if</span> (j != n) {
00178                         dum=1.0/(a[j][j]);
00179                         <span class="keywordflow">for</span> (i=j+1;i&lt;=n;i++) a[i][j] *= dum;
00180                 }
00181         }
00182         <a class="code" href="nrutil_8h.html#a25">free_vector</a>(vv,1,n);
00183 }
00184 
00185 
<a name="l00186"></a><a class="code" href="matrix_8c.html#a6">00186</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a5">lubksb</a>(a,n,indx,b)
00187 <span class="keywordtype">float</span> **a,b[];
00188 <span class="keywordtype">int</span> n,*indx;
00189 {
00190         <span class="keywordtype">int</span> i,ii=0,ip,j;
00191         <span class="keywordtype">float</span> sum;
00192 
00193         <span class="keywordflow">for</span> (i=1;i&lt;=n;i++) {
00194                 ip=indx[i];
00195                 sum=b[ip];
00196                 b[ip]=b[i];
00197                 <span class="keywordflow">if</span> (ii)
00198                         <span class="keywordflow">for</span> (j=ii;j&lt;=i-1;j++) sum -= a[i][j]*b[j];
00199                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sum) ii=i;
00200                 b[i]=sum;
00201         }
00202         <span class="keywordflow">for</span> (i=n;i&gt;=1;i--) {
00203                 sum=b[i];
00204                 <span class="keywordflow">for</span> (j=i+1;j&lt;=n;j++) sum -= a[i][j]*b[j];
00205                 b[i]=sum/a[i][i];
00206         }
00207 }
00208 
00209 
<a name="l00210"></a><a class="code" href="matrix_8c.html#a7">00210</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a7">svbksb</a>(u,w,v,m,n,b,x)
00211 <span class="keywordtype">float</span> **u,w[],**v,b[],x[];
00212 <span class="keywordtype">int</span> m,n;
00213 {
00214         <span class="keywordtype">int</span> jj,j,i;
00215         <span class="keywordtype">float</span> s,*tmp,*<a class="code" href="nrutil_8h.html#a14">vector</a>();
00216         <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a25">free_vector</a>();
00217 
00218         tmp=<a class="code" href="nrutil_8h.html#a14">vector</a>(1,n);
00219         <span class="keywordflow">for</span> (j=1;j&lt;=n;j++) {
00220                 s=0.0;
00221                 <span class="keywordflow">if</span> (w[j]) {
00222                         <span class="keywordflow">for</span> (i=1;i&lt;=m;i++) s += u[i][j]*b[i];
00223                         s /= w[j];
00224                 }
00225                 tmp[j]=s;
00226         }
00227         <span class="keywordflow">for</span> (j=1;j&lt;=n;j++) {
00228                 s=0.0;
00229                 <span class="keywordflow">for</span> (jj=1;jj&lt;=n;jj++) s += v[j][jj]*tmp[jj];
00230                 x[j]=s;
00231         }
00232         <a class="code" href="nrutil_8h.html#a25">free_vector</a>(tmp,1,n);
00233 }
00234 
00235 
<a name="l00236"></a><a class="code" href="matrix_8h.html#a6">00236</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a6">svdcmp</a>(a, m, n, w, v)
00237   <span class="keywordtype">float</span> **a, *w, **v;
00238   <span class="keywordtype">int</span> m, n;
00239 {
00240   <span class="keywordtype">int</span> flag, i, its, j, jj, k, l, nm;
00241   <span class="keywordtype">float</span> c, <a class="code" href="Makefile_8in.html#a5">f</a>, h, s, x, y, z;
00242   <span class="keywordtype">float</span> anorm = 0.0, g = 0.0, scale = 0.0;
00243   <span class="keywordtype">float</span> *rv1, *<a class="code" href="nrutil_8h.html#a14">vector</a>();
00244   <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a13">nrerror</a>(), <a class="code" href="nrutil_8h.html#a25">free_vector</a>();
00245   <span class="keywordflow">if</span> (m &lt; n)
00246     <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"SVDCMP: You must augment A with extra zero rows"</span>);
00247   rv1 = <a class="code" href="nrutil_8h.html#a14">vector</a>(1, n);
00248   <span class="keywordflow">for</span> (i = 1; i &lt;= n; i++)
00249   {
00250     l = i + 1;
00251     rv1[i] = scale * g;
00252     g = s = scale = 0.0;
00253     <span class="keywordflow">if</span> (i &lt;= m)
00254     {
00255       <span class="keywordflow">for</span> (k = i; k &lt;= m; k++)
00256         scale += fabs(a[k][i]);
00257       <span class="keywordflow">if</span> (scale)
00258       {
00259         <span class="keywordflow">for</span> (k = i; k &lt;= m; k++)
00260         {
00261           a[k][i] /= scale;
00262           s += a[k][i] * a[k][i];
00263         }
00264         <a class="code" href="Makefile_8in.html#a5">f</a> = a[i][i];
00265         g = -<a class="code" href="SVD_8cpp.html#a2">SIGN</a>(sqrt(s), <a class="code" href="Makefile_8in.html#a5">f</a>);
00266         h = <a class="code" href="Makefile_8in.html#a5">f</a> * g - s;
00267         a[i][i] = <a class="code" href="Makefile_8in.html#a5">f</a> - g;
00268         <span class="keywordflow">if</span> (i != n)
00269         {
00270           <span class="keywordflow">for</span> (j = l; j &lt;= n; j++)
00271           {
00272             <span class="keywordflow">for</span> (s = 0.0, k = i; k &lt;= m; k++)
00273               s += a[k][i] * a[k][j];
00274             <a class="code" href="Makefile_8in.html#a5">f</a> = s / h;
00275             <span class="keywordflow">for</span> (k = i; k &lt;= m; k++)
00276               a[k][j] += <a class="code" href="Makefile_8in.html#a5">f</a> * a[k][i];
00277           }
00278         }
00279         <span class="keywordflow">for</span> (k = i; k &lt;= m; k++)
00280           a[k][i] *= scale;
00281       }
00282     }
00283     w[i] = scale * g;
00284     g = s = scale = 0.0;
00285     <span class="keywordflow">if</span> (i &lt;= m &amp;&amp; i != n)
00286     {
00287       <span class="keywordflow">for</span> (k = l; k &lt;= n; k++)
00288         scale += fabs(a[i][k]);
00289       <span class="keywordflow">if</span> (scale)
00290       {
00291         <span class="keywordflow">for</span> (k = l; k &lt;= n; k++)
00292         {
00293           a[i][k] /= scale;
00294           s += a[i][k] * a[i][k];
00295         }
00296         <a class="code" href="Makefile_8in.html#a5">f</a> = a[i][l];
00297         g = -<a class="code" href="SVD_8cpp.html#a2">SIGN</a>(sqrt(s), <a class="code" href="Makefile_8in.html#a5">f</a>);
00298         h = <a class="code" href="Makefile_8in.html#a5">f</a> * g - s;
00299         a[i][l] = <a class="code" href="Makefile_8in.html#a5">f</a> - g;
00300         <span class="keywordflow">for</span> (k = l; k &lt;= n; k++)
00301           rv1[k] = a[i][k] / h;
00302         <span class="keywordflow">if</span> (i != m)
00303         {
00304           <span class="keywordflow">for</span> (j = l; j &lt;= m; j++)
00305           {
00306             <span class="keywordflow">for</span> (s = 0.0, k = l; k &lt;= n; k++)
00307               s += a[j][k] * a[i][k];
00308             <span class="keywordflow">for</span> (k = l; k &lt;= n; k++)
00309               a[j][k] += s * rv1[k];
00310           }
00311         }
00312         <span class="keywordflow">for</span> (k = l; k &lt;= n; k++)
00313           a[i][k] *= scale;
00314       }
00315     }
00316     anorm = <a class="code" href="general_8h.html#a7">MAX</a>(anorm, (fabs(w[i]) + fabs(rv1[i])));
00317   }
00318   <span class="keywordflow">for</span> (i = n; i &gt;= 1; i--)
00319   {
00320     <span class="keywordflow">if</span> (i &lt; n)
00321     {
00322       <span class="keywordflow">if</span> (g)
00323       {
00324         <span class="keywordflow">for</span> (j = l; j &lt;= n; j++)
00325           v[j][i] = (a[i][j] / a[i][l]) / g;
00326         <span class="keywordflow">for</span> (j = l; j &lt;= n; j++)
00327         {
00328           <span class="keywordflow">for</span> (s = 0.0, k = l; k &lt;= n; k++)
00329             s += a[i][k] * v[k][j];
00330           <span class="keywordflow">for</span> (k = l; k &lt;= n; k++)
00331             v[k][j] += s * v[k][i];
00332         }
00333       }
00334       <span class="keywordflow">for</span> (j = l; j &lt;= n; j++)
00335         v[i][j] = v[j][i] = 0.0;
00336     }
00337     v[i][i] = 1.0;
00338     g = rv1[i];
00339     l = i;
00340   }
00341   <span class="keywordflow">for</span> (i = n; i &gt;= 1; i--)
00342   {
00343     l = i + 1;
00344     g = w[i];
00345     <span class="keywordflow">if</span> (i &lt; n)
00346       <span class="keywordflow">for</span> (j = l; j &lt;= n; j++)
00347         a[i][j] = 0.0;
00348     <span class="keywordflow">if</span> (g)
00349     {
00350       g = 1.0 / g;
00351       <span class="keywordflow">if</span> (i != n)
00352       {
00353         <span class="keywordflow">for</span> (j = l; j &lt;= n; j++)
00354         {
00355           <span class="keywordflow">for</span> (s = 0.0, k = l; k &lt;= m; k++)
00356             s += a[k][i] * a[k][j];
00357           <a class="code" href="Makefile_8in.html#a5">f</a> = (s / a[i][i]) * g;
00358           <span class="keywordflow">for</span> (k = i; k &lt;= m; k++)
00359             a[k][j] += <a class="code" href="Makefile_8in.html#a5">f</a> * a[k][i];
00360         }
00361       }
00362       <span class="keywordflow">for</span> (j = i; j &lt;= m; j++)
00363         a[j][i] *= g;
00364     }
00365     <span class="keywordflow">else</span>
00366     {
00367       <span class="keywordflow">for</span> (j = i; j &lt;= m; j++)
00368         a[j][i] = 0.0;
00369     }
00370     ++a[i][i];
00371   }
00372   <span class="keywordflow">for</span> (k = n; k &gt;= 1; k--)
00373   {
00374     <span class="keywordflow">for</span> (its = 1; its &lt;= 30; its++)
00375     {
00376       flag = 1;
00377       <span class="keywordflow">for</span> (l = k; l &gt;= 1; l--)
00378       {
00379         nm = l - 1;
00380         <span class="keywordflow">if</span> (fabs(rv1[l]) + anorm == anorm)
00381         {
00382           flag = 0;
00383           <span class="keywordflow">break</span>;
00384         }
00385         <span class="keywordflow">if</span> (fabs(w[nm]) + anorm == anorm)
00386           <span class="keywordflow">break</span>;
00387       }
00388       <span class="keywordflow">if</span> (flag)
00389       {
00390         c = 0.0;
00391         s = 1.0;
00392         <span class="keywordflow">for</span> (i = l; i &lt;= k; i++)
00393         {
00394           <a class="code" href="Makefile_8in.html#a5">f</a> = s * rv1[i];
00395           <span class="keywordflow">if</span> (fabs(<a class="code" href="Makefile_8in.html#a5">f</a>) + anorm != anorm)
00396           {
00397             g = w[i];
00398             h = <a class="code" href="general_8h.html#a9">PYTHAG</a>(<a class="code" href="Makefile_8in.html#a5">f</a>, g);
00399             w[i] = h;
00400             h = 1.0 / h;
00401             c = g * h;
00402             s = (-<a class="code" href="Makefile_8in.html#a5">f</a> * h);
00403             <span class="keywordflow">for</span> (j = 1; j &lt;= m; j++)
00404             {
00405               y = a[j][nm];
00406               z = a[j][i];
00407               a[j][nm] = y * c + z * s;
00408               a[j][i] = z * c - y * s;
00409             }
00410           }
00411         }
00412       }
00413       z = w[k];
00414       <span class="keywordflow">if</span> (l == k)
00415       {
00416         <span class="keywordflow">if</span> (z &lt; 0.0)
00417         {
00418           w[k] = -z;
00419           <span class="keywordflow">for</span> (j = 1; j &lt;= n; j++)
00420             v[j][k] = (-v[j][k]);
00421         }
00422         <span class="keywordflow">break</span>;
00423       }
00424       <span class="keywordflow">if</span> (its == 30)
00425         <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"No convergence in 30 SVDCMP iterations"</span>);
00426       x = w[l];
00427       nm = k - 1;
00428       y = w[nm];
00429       g = rv1[nm];
00430       h = rv1[k];
00431       <a class="code" href="Makefile_8in.html#a5">f</a> = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
00432       g = <a class="code" href="general_8h.html#a9">PYTHAG</a>(<a class="code" href="Makefile_8in.html#a5">f</a>, 1.0);
00433       <a class="code" href="Makefile_8in.html#a5">f</a> = ((x - z) * (x + z) + h * ((y / (<a class="code" href="Makefile_8in.html#a5">f</a> + <a class="code" href="SVD_8cpp.html#a2">SIGN</a>(g, <a class="code" href="Makefile_8in.html#a5">f</a>))) - h)) / x;
00434       c = s = 1.0;
00435       <span class="keywordflow">for</span> (j = l; j &lt;= nm; j++)
00436       {
00437         i = j + 1;
00438         g = rv1[i];
00439         y = w[i];
00440         h = s * g;
00441         g = c * g;
00442         z = <a class="code" href="general_8h.html#a9">PYTHAG</a>(<a class="code" href="Makefile_8in.html#a5">f</a>, h);
00443         rv1[j] = z;
00444         c = <a class="code" href="Makefile_8in.html#a5">f</a> / z;
00445         s = h / z;
00446         <a class="code" href="Makefile_8in.html#a5">f</a> = x * c + g * s;
00447         g = g * c - x * s;
00448         h = y * s;
00449         y = y * c;
00450         <span class="keywordflow">for</span> (jj = 1; jj &lt;= n; jj++)
00451         {
00452           x = v[jj][j];
00453           z = v[jj][i];
00454           v[jj][j] = x * c + z * s;
00455           v[jj][i] = z * c - x * s;
00456         }
00457         z = <a class="code" href="general_8h.html#a9">PYTHAG</a>(<a class="code" href="Makefile_8in.html#a5">f</a>, h);
00458         w[j] = z;
00459         <span class="keywordflow">if</span> (z)
00460         {
00461           z = 1.0 / z;
00462           c = <a class="code" href="Makefile_8in.html#a5">f</a> * z;
00463           s = h * z;
00464         }
00465         <a class="code" href="Makefile_8in.html#a5">f</a> = (c * g) + (s * y);
00466         x = (c * y) - (s * g);
00467         <span class="keywordflow">for</span> (jj = 1; jj &lt;= m; jj++)
00468         {
00469           y = a[jj][j];
00470           z = a[jj][i];
00471           a[jj][j] = y * c + z * s;
00472           a[jj][i] = z * c - y * s;
00473         }
00474       }
00475       rv1[l] = 0.0;
00476       rv1[k] = <a class="code" href="Makefile_8in.html#a5">f</a>;
00477       w[k] = x;
00478     }
00479   }
00480   <a class="code" href="nrutil_8h.html#a25">free_vector</a>(rv1, 1, n);
00481 }
00482 
00483 
00484 <span class="preprocessor">#undef SIGN</span>
00485 <span class="preprocessor"></span><span class="preprocessor">#undef PYTHAG</span>
00486 <span class="preprocessor"></span><span class="preprocessor">#undef TINY</span>
00487 <span class="preprocessor"></span>
00488 <span class="comment">/****************************************************************************/</span>
00489 
00490 
<a name="l00491"></a><a class="code" href="matrix_8h.html#a25">00491</a> <a class="code" href="structMATRIX.html">MATRIX</a> *<a class="code" href="matrix_8h.html#a25">mat_malloc</a>(rows, cols)
00492 <span class="keywordtype">int</span> rows, cols;
00493 {
00494   <span class="keywordtype">int</span>    i;
00495   <span class="keywordtype">float</span>  *mat, **row;
00496   <a class="code" href="structMATRIX.html">MATRIX</a> *matrix;
00497 
00498   <span class="comment">/* Allocate space for structure, elements and pointers.</span>
00499 <span class="comment">   *</span>
00500 <span class="comment">   * Note, that the allocated number of row pointers is MAX(row, cols)</span>
00501 <span class="comment">   * because it facilitates transposing rectangular matrices.</span>
00502 <span class="comment">   */</span>
00503  <span class="keywordflow">if</span> ((rows &gt; 0) &amp;&amp; (cols &gt; 0)) {
00504    mat = (<span class="keywordtype">float</span> * ) malloc(rows * cols * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00505    row = (<span class="keywordtype">float</span> **) malloc((<a class="code" href="general_8h.html#a7">MAX</a>(rows, cols)) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span> *));
00506  }
00507  <span class="keywordflow">else</span> {
00508    mat = (<span class="keywordtype">float</span> * ) malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00509    row = (<span class="keywordtype">float</span> **) malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">float</span> *));
00510    row[0]=mat;
00511  }
00512    matrix = (<a class="code" href="structMATRIX.html">MATRIX</a> *) malloc( <span class="keyword">sizeof</span>( <a class="code" href="structMATRIX.html">MATRIX</a> ) );
00513 
00514   <span class="keywordflow">if</span>(!mat || !row || !matrix)
00515     {
00516  <span class="comment">/*     IKerrror(18, FATAL);*/</span>
00517       fprintf(stderr, <span class="stringliteral">"Matrix allocation failed\n"</span>);
00518       <span class="keywordflow">return</span>(NULL);
00519     }
00520 
00521   matrix-&gt;p = row;
00522   matrix-&gt;rows = rows;
00523   matrix-&gt;cols = cols;
00524 
00525   <span class="comment">/* The Nth element of the array row points to the 1st element </span>
00526 <span class="comment">   * on the Nth row. Thus, **m = *m[0] = m[0][0]</span>
00527 <span class="comment">   *</span>
00528 <span class="comment">   * Calculate the addresses of the pointers pointing to the </span>
00529 <span class="comment">   * rows of the matrix</span>
00530 <span class="comment">   */</span>
00531 
00532   <span class="keywordflow">for</span>(i = 0; i &lt; rows; i++)
00533   {
00534     row[i] = mat; 
00535     mat += cols;
00536   }
00537 
00538   <span class="keywordflow">return</span>(matrix);
00539 }
00540 
00541 
00542 
<a name="l00543"></a><a class="code" href="matrix_8h.html#a8">00543</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a8">mat_free</a>(m)
00544 <a class="code" href="structMATRIX.html">MATRIX</a> *m;
00545 {
00546   free( (<span class="keywordtype">char</span> *) *m-&gt;p);
00547   free( (<span class="keywordtype">char</span> *)  m-&gt;p);
00548   free( (<span class="keywordtype">char</span> *)  m);
00549 }
00550 
00551 
<a name="l00552"></a><a class="code" href="matrix_8h.html#a9">00552</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a9">mat_pr</a>(a)
00553 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00554 {
00555   <span class="keywordtype">int</span> i, j;
00556 
00557   printf(<span class="stringliteral">"\n"</span>);
00558   <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;rows; i++)
00559   {
00560     <span class="keywordflow">for</span> (j = 0; j &lt; a-&gt;cols; j++)
00561       {
00562         <span class="keywordflow">if</span> (fabs(a-&gt;p[i][j]) &gt;= <a class="code" href="matrix_8h.html#a1">PrintIfBiggerThan</a>)
00563           printf(<span class="stringliteral">"\t% .8f"</span>, a-&gt;p[i][j]);
00564         <span class="keywordflow">else</span>
00565           printf(<span class="stringliteral">"\t  - "</span>);
00566       }
00567     printf(<span class="stringliteral">"\n"</span>);
00568   }
00569   printf(<span class="stringliteral">"\n"</span>);
00570 }
00571 
00572 
<a name="l00573"></a><a class="code" href="matrix_8h.html#a10">00573</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a10">mat_prf</a>(a)
00574 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00575 {
00576   <span class="keywordtype">int</span> i, j;
00577 
00578   printf(<span class="stringliteral">"\n"</span>);
00579   <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;rows; i++)
00580   {
00581     <span class="keywordflow">for</span> (j = 0; j &lt; a-&gt;cols; j++)
00582     {
00583       printf(<span class="stringliteral">"\t% f"</span>, a-&gt;p[i][j]);
00584       }
00585     printf(<span class="stringliteral">"\n"</span>);
00586   }
00587   printf(<span class="stringliteral">"\n"</span>);
00588 }
00589 
00590 
00591 
00592 <span class="comment">/* The inverted matrix will still reside in a */</span>
<a name="l00593"></a><a class="code" href="matrix_8h.html#a15">00593</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a15">mat_LU_inv</a>(a)
00594 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00595 {
00596   <a class="code" href="structMATRIX.html">MATRIX</a> *y;
00597   <span class="keywordtype">float</span>  **A, **Y, d, *col;
00598   <span class="keywordtype">int</span>    N, i, j, *indx;
00599   <span class="keywordtype">float</span>  **<a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>();
00600 
00601   N = a-&gt;rows;
00602 
00603   <span class="comment">/* Allocate space for y matrix to hold result, column vector col,</span>
00604 <span class="comment">   * and indx array.</span>
00605 <span class="comment">   */</span>
00606   y    = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(a-&gt;rows, a-&gt;cols);
00607   col  = <a class="code" href="nrutil_8h.html#a14">vector</a>(1, N);
00608   indx = (<span class="keywordtype">int</span> *) malloc(N * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00609 
00610   <span class="comment">/* Create pointers to a and y conforming with Num-Rec-in-C format.</span>
00611 <span class="comment">   * A and Y is from [1..N][1..N]</span>
00612 <span class="comment">   */</span>
00613   A = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(a);
00614   Y = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(y);
00615 
00616   <span class="comment">/* LU decompose A</span>
00617 <span class="comment">   */</span>
00618   <a class="code" href="matrix_8h.html#a4">ludcmp</a>(A, N, indx, &amp;d);
00619 
00620   <span class="comment">/* Find inverse by columns. (There is no better way to do it.)</span>
00621 <span class="comment">   */</span>
00622   <span class="keywordflow">for</span> (j = 1; j &lt;= N; j++)
00623     {
00624       <span class="keywordflow">for</span> (i = 1; i &lt;= N; i++)
00625         col[i] = 0.0;
00626 
00627       col[j] = 1.0;
00628       <a class="code" href="matrix_8h.html#a5">lubksb</a>(A, N, indx, col);
00629 
00630       <span class="keywordflow">for</span> (i = 1; i &lt;= N; i++)
00631         Y[i][j] = col[i];
00632     }
00633 
00634   <span class="comment">/* Inverted matrix is now in y. Copy y into a and free matrix y</span>
00635 <span class="comment">   */</span>
00636   <a class="code" href="matrix_8h.html#a20">mat_cp</a>(y, a);
00637 
00638   <a class="code" href="matrix_8h.html#a8">mat_free</a>(y);
00639   <a class="code" href="nrutil_8h.html#a25">free_vector</a>(col, 1, N);
00640   free( (<span class="keywordtype">char</span> *) indx);
00641   free( (<span class="keywordtype">char</span> *) A);
00642   free( (<span class="keywordtype">char</span> *) Y);
00643 }
00644 
00645 
00646 <span class="comment">/* The pseudoinverted matrix will still reside in a. In the case of a</span>
00647 <span class="comment"> * square matrix, the result will actually be the inverted matrix. If</span>
00648 <span class="comment"> * the matrix is rectangular, the pseudoinverse will have the correct </span>
00649 <span class="comment"> * dimension.</span>
00650 <span class="comment"> */</span>
<a name="l00651"></a><a class="code" href="matrix_8h.html#a16">00651</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a16">mat_pseudoinv</a>(a)
00652 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00653 {
00654   <a class="code" href="structMATRIX.html">MATRIX</a> *q2, *z, *tmp;
00655   <span class="keywordtype">float</span>  **A, **Q2, *Z;
00656   <span class="keywordtype">float</span>  z_min, z_max;
00657   <span class="keywordtype">int</span>    M, N, i, j;
00658   <span class="keywordtype">float</span>  **<a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>();
00659 
00660   M = a-&gt;rows; N = a-&gt;cols;
00661 
00662   <span class="comment">/* Allocate space for q2 matrix, vector Z[1..N], z and tmp</span>
00663 <span class="comment">   */</span>
00664   q2 = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(N, N);
00665   z  = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(N, N);
00666   Z  = <a class="code" href="nrutil_8h.html#a14">vector</a>(1, N);
00667 
00668   <span class="comment">/* Create pointers to a and q2 conforming with Num-Rec-in-C format.</span>
00669 <span class="comment">   */</span>
00670   A  = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(a);
00671   Q2 = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(q2);
00672 
00673   <span class="comment">/* Compute A[1..M][1..N]`s singular value decomposition (SVD): A = Q1*Z*Q2_tra</span>
00674 <span class="comment">   *</span>
00675 <span class="comment">   * Q1  will replace A, and the diagonal value of singular values Z is output</span>
00676 <span class="comment">   * as a vector Z[1..N]. The matrix Q2 (not the transpose Q2_tra) is output </span>
00677 <span class="comment">   * as Q2[1..N][1..N]. M must be greater than or equal to N; If it is smaller, </span>
00678 <span class="comment">   * then A should be filled up to square with zero rows.</span>
00679 <span class="comment">   */</span>
00680   <a class="code" href="matrix_8h.html#a6">svdcmp</a>(A, M, N, Z, Q2);
00681 
00682   <span class="comment">/* (Singular values = squareroot of the eigenvalues), find maximum.</span>
00683 <span class="comment">   */</span>
00684   z_max = 0.0;
00685   <span class="keywordflow">for</span> (i = 1; i &lt;= N; i++) if (Z[i] &gt; z_max) z_max = Z[i];
00686 
00687   <span class="comment">/* Set threshold value of the minimum singular value allowed </span>
00688 <span class="comment">   * to be nonzero.</span>
00689 <span class="comment">   */</span>
00690   z_min = z_max*<a class="code" href="matrix_8h.html#a0">SVD_THRESHOLD</a>;
00691 
00692   <span class="comment">/* Invert while copying from the Z vector into the z+ matrix, and weed out </span>
00693 <span class="comment">   * the too small singular values.</span>
00694 <span class="comment">   */</span>
00695   <span class="keywordflow">for</span> (i = 0; i &lt; N; i++)
00696     <span class="keywordflow">for</span> (j = 0; j &lt; N; j++)
00697       z-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][j] = ((i == j) &amp;&amp; Z[i+1] &gt; z_min) ? 1.0/Z[i+1] : 0.0; 
00698      <span class="comment">/* z-&gt;p[i][j] = 1.0/Z[i+1];*/</span>
00699 
00700 
00701   <span class="comment">/*                               </span>
00702 <span class="comment">   * A_pseudoinv = Q2 * Z_pseudoinv * Q1_tra</span>
00703 <span class="comment">   *</span>
00704 <span class="comment">   * Returned matrix A from svdcmp() is actually Q1, therefore:</span>
00705 <span class="comment">   */</span>
00706 
00707 <span class="comment">/* </span>
00708 <span class="comment">  printf("Testing the inverse:\n");</span>
00709 <span class="comment">  q1t = mat_tra2(a);</span>
00710 <span class="comment">  qq = mat_mul2(a,q1t);</span>
00711 <span class="comment">  printf("Q1t*q1 = \n");</span>
00712 <span class="comment">  mat_pr(qq);</span>
00713 <span class="comment">  mat_free(qq);</span>
00714 <span class="comment">  mat_free(q1t);</span>
00715 <span class="comment">*/</span>
00716 
00717 
00718   <a class="code" href="matrix_8h.html#a19">mat_tra</a>(a);              <span class="comment">/* Transpose Q1 to Q1_tra                          */</span>
00719   tmp = <a class="code" href="matrix_8h.html#a26">mat_mul2</a>(z, a);    <span class="comment">/* tmp = Z_pseudoinv * Q1_tra                      */</span>
00720   <a class="code" href="matrix_8h.html#a11">mat_mul</a>(q2, tmp, a);     <span class="comment">/* A_pseudoinv = Q2 * tmp = Q2 * Z_pseudo * Q1_tra */</span>
00721 
00722 <span class="comment">/*</span>
00723 <span class="comment">  q2t = mat_tra2(q2);</span>
00724 <span class="comment">  qq2 = mat_mul2(q2,q2t);</span>
00725 <span class="comment">  printf("Q2t*Q2 = \n");</span>
00726 <span class="comment">  mat_pr(qq2);</span>
00727 <span class="comment">  mat_free(qq2);</span>
00728 <span class="comment">  mat_free(q2t);</span>
00729 <span class="comment">*/</span>
00730 
00731 
00732 
00733   <a class="code" href="matrix_8h.html#a8">mat_free</a>(q2);
00734   <a class="code" href="matrix_8h.html#a8">mat_free</a>(z);
00735   <a class="code" href="matrix_8h.html#a8">mat_free</a>(tmp);
00736   <a class="code" href="nrutil_8h.html#a25">free_vector</a>(Z, 1, N);
00737   free( (<span class="keywordtype">char</span> *) A);
00738   free( (<span class="keywordtype">char</span> *) Q2);
00739 
00740 }
00741 
00742 
00743 <span class="comment">/* The pseudoinverted matrix will still reside in a. In the case of a</span>
00744 <span class="comment"> * square matrix, the result will actually be the inverted matrix. If</span>
00745 <span class="comment"> * the matrix is rectangular, the pseudoinverse will have the correct </span>
00746 <span class="comment"> * dimension.</span>
00747 <span class="comment"> */</span>
00748 
00749 
<a name="l00750"></a><a class="code" href="matrix_8h.html#a17">00750</a> <span class="keywordtype">double</span> <a class="code" href="matrix_8h.html#a17">mat_det</a>(a)
00751 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00752 {
00753   <a class="code" href="structMATRIX.html">MATRIX</a> *q2, *cp;
00754   <span class="keywordtype">float</span>  **A, **Q2, *Z;
00755   <span class="keywordtype">int</span>    M, N, i, j;
00756   <span class="keywordtype">float</span>  **<a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>();
00757   <span class="keywordtype">double</span> det;
00758 
00759   M = a-&gt;rows; N = a-&gt;cols;
00760 
00761   <span class="comment">/* Allocate space for q2 matrix, vector Z[1..N], z and tmp */</span>
00762   cp = <a class="code" href="matrix_8h.html#a27">mat_cp2</a>(a);
00763   q2 = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(N, N);
00764   Z  = <a class="code" href="nrutil_8h.html#a14">vector</a>(1, N);
00765 
00766   <span class="comment">/* Create pointers to a and q2 conforming with Num-Rec-in-C format.</span>
00767 <span class="comment">   */</span>
00768   A  = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(cp);
00769   Q2 = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(q2);
00770 
00771   <span class="comment">/* Compute A[1..M][1..N]`s singular value decomposition (SVD): A = Q1*Z*Q2_tra</span>
00772 <span class="comment">   *</span>
00773 <span class="comment">   * Q1 will replace A, and the diagonal value of singular values Z is output</span>
00774 <span class="comment">   * as a vector Z[1..N]. The matrix Q2 (not the transpose Q2_tra) is output </span>
00775 <span class="comment">   * as Q2[1..N][1..N]. M must be greater than or equal to N; If it is smaller, </span>
00776 <span class="comment">   * then A should be filled up to square with zero rows.</span>
00777 <span class="comment">   */</span>
00778   <a class="code" href="matrix_8h.html#a6">svdcmp</a>(A, M, N, Z, Q2);
00779 
00780   <span class="comment">/* (Singular values = squareroot of the eigenvalues of AtA), find maximum. */</span>
00781     
00782   <span class="keywordflow">for</span>(det=1.0,i=1;i&lt;=N;i++)
00783        det *= (<span class="keywordtype">double</span>) Z[i];
00784 
00785   <a class="code" href="matrix_8h.html#a8">mat_free</a>(q2);
00786   <a class="code" href="matrix_8h.html#a8">mat_free</a>(cp);
00787   free( (<span class="keywordtype">char</span> *) A);
00788   free( (<span class="keywordtype">char</span> *) Q2);
00789   <a class="code" href="nrutil_8h.html#a25">free_vector</a>(Z, 1, N);
00790 
00791   <span class="keywordflow">return</span>(det);
00792 }
00793 
00794 
<a name="l00795"></a><a class="code" href="matrix_8h.html#a18">00795</a> <span class="keywordtype">double</span> <a class="code" href="matrix_8h.html#a18">mat_eigen</a>(a)
00796 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00797 {
00798   <a class="code" href="structMATRIX.html">MATRIX</a> *q2;
00799   <span class="keywordtype">float</span>  **A, **Q2, *Z;
00800   <span class="keywordtype">float</span>  z_min, z_max;
00801   <span class="keywordtype">int</span>    M, N, i, j;
00802   <span class="keywordtype">float</span>  **<a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>();
00803 
00804   M = a-&gt;rows; N = a-&gt;cols;
00805 
00806   <span class="comment">/* Allocate space for q2 matrix, vector Z[1..N]</span>
00807 <span class="comment">   */</span>
00808   q2 = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(N, N);
00809   Z  = <a class="code" href="nrutil_8h.html#a14">vector</a>(1, N);
00810 
00811   <span class="comment">/* Create pointers to a and q2 conforming with Num-Rec-in-C format.</span>
00812 <span class="comment">   */</span>
00813   A  = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(a);
00814   Q2 = <a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(q2);
00815 
00816   <span class="comment">/* Compute A[1..M][1..N]`s singular value decomposition (SVD): A = Q1*Z*Q2_tra</span>
00817 <span class="comment">   *</span>
00818 <span class="comment">   * Q1  will replace A, and the diagonal value of singular values Z is output</span>
00819 <span class="comment">   * as a vector Z[1..N]. The matrix Q2 (not the transpose Q2_tra) is output </span>
00820 <span class="comment">   * as Q2[1..N][1..N]. M must be greater than or equal to N; If it is smaller, </span>
00821 <span class="comment">   * then A should be filled up to square with zero rows.</span>
00822 <span class="comment">   */</span>
00823   <a class="code" href="matrix_8h.html#a6">svdcmp</a>(A, M, N, Z, Q2);
00824 
00825   <span class="comment">/* (Singular values = squareroot of the eigenvalues), find maximum.</span>
00826 <span class="comment">   */</span>
00827   z_max = 0.0;
00828   <span class="keywordflow">for</span> (i = 1; i &lt;= N; i++) if (Z[i] &gt; z_max) z_max = Z[i];
00829 
00830   <a class="code" href="matrix_8h.html#a8">mat_free</a>(q2);
00831   <a class="code" href="nrutil_8h.html#a25">free_vector</a>(Z, 1, N);
00832   free( (<span class="keywordtype">char</span> *) A);
00833   free( (<span class="keywordtype">char</span> *) Q2);
00834 
00835   <span class="keywordflow">return</span>(z_max);
00836 }
00837 
00838 
00839 
00840 
00841 <span class="comment">/* The 'c' matrix must already be declared float of size: arows x bcols.</span>
00842 <span class="comment"> */</span>
<a name="l00843"></a><a class="code" href="matrix_8h.html#a11">00843</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a11">mat_mul</a>(a, b, c)
00844 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b, *c;
00845 {
00846   <span class="keywordtype">int</span> i, j, k;
00847 
00848   <span class="keywordflow">for</span> (k = 0; k &lt; b-&gt;cols; k++)
00849     <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;rows; i++)
00850     {
00851       c-&gt;p[i][k] = 0;
00852       <span class="keywordflow">for</span> (j = 0; j &lt; a-&gt;cols; j++)
00853         c-&gt;p[i][k] += a-&gt;p[i][j]*b-&gt;p[j][k];
00854     }
00855 }
00856 
00857 
00858 <span class="comment">/* The function will automatically create the result matrix of correct</span>
00859 <span class="comment"> * dimension. The pointer to this matrix structure is returned.</span>
00860 <span class="comment"> */</span>
<a name="l00861"></a><a class="code" href="matrix_8h.html#a26">00861</a> <a class="code" href="structMATRIX.html">MATRIX</a> *<a class="code" href="matrix_8h.html#a26">mat_mul2</a>(a, b)
00862 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b;
00863 {
00864   <a class="code" href="structMATRIX.html">MATRIX</a> *c;
00865 
00866   c = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(a-&gt;rows, b-&gt;cols);
00867 
00868   <a class="code" href="matrix_8h.html#a11">mat_mul</a>(a, b, c);
00869 
00870   <span class="keywordflow">return</span>(c);
00871 }
00872 
00873 
00874 <span class="comment">/* The 'c' matrix must already be declared float of size: arows x bcols.</span>
00875 <span class="comment"> *</span>
00876 <span class="comment"> * c = a + b;</span>
00877 <span class="comment"> */</span>
<a name="l00878"></a><a class="code" href="matrix_8h.html#a12">00878</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a12">mat_add</a>(a, b, c)
00879 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b, *c;
00880 {
00881   <span class="keywordtype">float</span> *p, *q, *r;
00882   <span class="keywordtype">int</span>   i;
00883 
00884   p = *a-&gt;p; q = *b-&gt;p; r = *c-&gt;p;
00885 
00886   <span class="keywordflow">for</span> (i = a-&gt;rows*a-&gt;cols; i--;)
00887     *r++ = *p++ + *q++; 
00888 }
00889 
00890 
00891 <span class="comment">/* The function will automatically create the result matrix of correct</span>
00892 <span class="comment"> * dimension. The pointer to this matrix structure is returned.</span>
00893 <span class="comment"> *</span>
00894 <span class="comment"> * c = a + b;</span>
00895 <span class="comment"> */</span>
<a name="l00896"></a><a class="code" href="matrix_8h.html#a28">00896</a> <a class="code" href="structMATRIX.html">MATRIX</a> *<a class="code" href="matrix_8h.html#a28">mat_add2</a>(a, b)
00897 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b;
00898 {
00899   <a class="code" href="structMATRIX.html">MATRIX</a> *c;
00900 
00901   c = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(a-&gt;rows, a-&gt;cols);
00902 
00903   <a class="code" href="matrix_8h.html#a12">mat_add</a>(a, b, c);
00904 
00905   <span class="keywordflow">return</span>(c);
00906 }
00907 
00908 
00909 <span class="comment">/* The 'c' matrix must already be declared float of size: arows x acols.</span>
00910 <span class="comment"> *</span>
00911 <span class="comment"> * c = a - b;</span>
00912 <span class="comment"> */</span>
<a name="l00913"></a><a class="code" href="matrix_8h.html#a13">00913</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a13">mat_sub</a>(a, b, c)
00914 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b, *c;
00915 {
00916   <span class="keywordtype">float</span> *p, *q, *r;
00917   <span class="keywordtype">int</span>   i;
00918 
00919   p = *a-&gt;p; q = *b-&gt;p; r = *c-&gt;p;
00920 
00921   <span class="keywordflow">for</span> (i = a-&gt;rows*a-&gt;cols; i--;)
00922     *r++ = *p++ - *q++; 
00923 }
00924 
00925 
00926 
00927 <span class="comment">/* The function will automatically create the result matrix of correct</span>
00928 <span class="comment"> * dimension. The pointer to this matrix structure is returned.</span>
00929 <span class="comment"> *</span>
00930 <span class="comment"> * c = a - b;</span>
00931 <span class="comment"> */</span>
<a name="l00932"></a><a class="code" href="matrix_8h.html#a29">00932</a> <a class="code" href="structMATRIX.html">MATRIX</a> *<a class="code" href="matrix_8h.html#a29">mat_sub2</a>(a, b)
00933 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b;
00934 {
00935   <a class="code" href="structMATRIX.html">MATRIX</a> *c;
00936 
00937   c = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(a-&gt;rows, a-&gt;cols);
00938 
00939   <a class="code" href="matrix_8h.html#a13">mat_sub</a>(a, b, c);
00940 
00941   <span class="keywordflow">return</span>(c);
00942 }
00943 
00944 
00945 
00946 <span class="comment">/* The matrix 'a' is scaled by the factor 'c'</span>
00947 <span class="comment"> */</span>
<a name="l00948"></a><a class="code" href="matrix_8h.html#a14">00948</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a14">mat_sca</a>(a, c)
00949 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00950 <span class="keywordtype">float</span>  c;
00951 {
00952   <span class="keywordtype">float</span> *p;
00953   <span class="keywordtype">int</span>   i;
00954 
00955   p = *a-&gt;p;
00956 
00957   <span class="keywordflow">for</span> (i = a-&gt;rows*a-&gt;cols; i--;)
00958     *p++ *= c; 
00959 }
00960 
00961 
00962 
00963 <span class="comment">/* The transposed matrix still resides in 'a' after transposition</span>
00964 <span class="comment"> */</span>
<a name="l00965"></a><a class="code" href="matrix_8h.html#a19">00965</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a19">mat_tra</a>(a)
00966 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
00967 {
00968   <span class="keywordtype">int</span>   i, j, temp;
00969   <span class="keywordtype">float</span> *p;
00970 
00971   <span class="keywordflow">if</span> (a-&gt;rows == a-&gt;cols)              <span class="comment">/* Square matrix */</span>
00972   {
00973     <span class="keywordflow">for</span> (i = a-&gt;rows-1; i--;)
00974       <span class="keywordflow">for</span> (j = a-&gt;cols-1; j &gt; i; j--)
00975         <a class="code" href="general_8h.html#a6">SWAP</a>(a-&gt;p[i][j], a-&gt;p[j][i]);
00976   }
00977   <span class="keywordflow">else</span>                                 <span class="comment">/* Rectangular matrix */</span>
00978   {
00979     temp = a-&gt;rows; 
00980     a-&gt;rows = a-&gt;cols; 
00981     a-&gt;cols = temp;
00982 
00983     <span class="comment">/* Recompute pointers to the new rows of the matrix</span>
00984 <span class="comment">     */</span>
00985     p = *a-&gt;p;
00986     <span class="keywordflow">for</span>(i = 0; i &lt; a-&gt;rows; i++)
00987     {
00988       a-&gt;p[i] = p; 
00989       p += a-&gt;cols;
00990     }
00991 
00992     <span class="comment">/* No need to swap elements if the matrix has only one row or column.</span>
00993 <span class="comment">     */</span>
00994     <span class="keywordflow">if</span> (!((a-&gt;rows == 1) || (a-&gt;cols == 1)))
00995     {
00996       <a class="code" href="structMATRIX.html">MATRIX</a> *m;
00997 
00998       <span class="comment">/*...otherwise put elements in temporary matrix and</span>
00999 <span class="comment">       * copy from it into the columns of the transposed matrix.</span>
01000 <span class="comment">       */</span>
01001       m = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(a-&gt;rows, a-&gt;cols);
01002       <a class="code" href="matrix_8h.html#a20">mat_cp</a>(a,m);
01003       p = *m-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>;
01004 
01005       <span class="keywordflow">for</span> (j = 0; j &lt; a-&gt;cols; j++)
01006         <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;rows; i++)
01007           a-&gt;p[i][j] = *p++;
01008 
01009       <a class="code" href="matrix_8h.html#a8">mat_free</a>(m);
01010     }    
01011   }
01012 }
01013 
01014 
01015 <span class="comment">/* The function will automatically create the result matrix of correct</span>
01016 <span class="comment"> * dimension which will be the transpose of A. The pointer to this matrix </span>
01017 <span class="comment"> * structure is returned.</span>
01018 <span class="comment"> */</span>
<a name="l01019"></a><a class="code" href="matrix_8h.html#a30">01019</a> <a class="code" href="structMATRIX.html">MATRIX</a> *<a class="code" href="matrix_8h.html#a30">mat_tra2</a>(A)
01020 <a class="code" href="structMATRIX.html">MATRIX</a> *A;
01021 {
01022   <span class="keywordtype">int</span>   i, j;
01023   <a class="code" href="structMATRIX.html">MATRIX</a> *At;
01024 
01025   At = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(A-&gt;cols, A-&gt;rows);
01026 
01027   <span class="keywordflow">for</span> (i = A-&gt;rows-1; i--;)
01028     <span class="keywordflow">for</span> (j = A-&gt;cols-1; j &gt; i; j--)
01029       At-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[i][j] = A-&gt;p[j][i];
01030 
01031   <span class="keywordflow">return</span>(At);
01032 }
01033 
01034 
01035 <span class="comment">/* The copied matrix 'cpy' must already be declared float of </span>
01036 <span class="comment"> * same size as 'a'.</span>
01037 <span class="comment"> */</span>
<a name="l01038"></a><a class="code" href="matrix_8h.html#a20">01038</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a20">mat_cp</a>(a, cpy)
01039 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *cpy;
01040 {
01041   <span class="keywordtype">float</span> *p, *q;
01042   <span class="keywordtype">int</span>   i;
01043 
01044   p = *a-&gt;p; q = *cpy-&gt;p;
01045 
01046   <span class="keywordflow">for</span> (i = a-&gt;rows*a-&gt;cols; i--;)
01047     *q++ = *p++; 
01048 }
01049 
01050 
01051 
01052 <span class="comment">/* The function will automatically create the result matrix of correct</span>
01053 <span class="comment"> * dimension . The pointer to this matrix structure is returned.</span>
01054 <span class="comment"> */</span>
<a name="l01055"></a><a class="code" href="matrix_8c.html#a27">01055</a> <a class="code" href="structMATRIX.html">MATRIX</a> *<a class="code" href="matrix_8h.html#a27">mat_cp2</a>(a)
01056 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
01057 {
01058   <span class="keywordtype">int</span>   i;
01059   <span class="keywordtype">float</span> *p, *q;
01060   <a class="code" href="structMATRIX.html">MATRIX</a> *cpy;
01061 
01062   cpy = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(a-&gt;rows, a-&gt;cols);
01063 
01064   <a class="code" href="matrix_8h.html#a20">mat_cp</a>(a, cpy);
01065 
01066   <span class="keywordflow">return</span>(cpy);
01067 }
01068 
01069 
01070 
01071 <span class="comment">/* Returns an pointer which points to an array of pointers to matrix row </span>
01072 <span class="comment"> * elements in a way so that the matrix a-&gt;p[0..n][0..m] can be accessed</span>
01073 <span class="comment"> * from [1..n-1][1..m-1] which is required by the Numerical Rec. i C.</span>
01074 <span class="comment"> */</span>
<a name="l01075"></a><a class="code" href="matrix_8c.html#a28">01075</a> <span class="keywordtype">float</span> **<a class="code" href="matrix_8c.html#a28">conv_2_nric_ptr</a>(a)
01076 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
01077 {
01078   <span class="keywordtype">float</span> **new_ptr_2_row;
01079   <span class="keywordtype">int</span>   i;
01080 
01081   <span class="comment">/* Allocate space for an array of OFFSET pointers.</span>
01082 <span class="comment">   */</span>
01083   new_ptr_2_row = (<span class="keywordtype">float</span> **) malloc((a-&gt;rows + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span> *));
01084 
01085   <span class="comment">/* The array of pointers to row must be offset by -1</span>
01086 <span class="comment">   */</span>
01087   <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;rows; i++)
01088     new_ptr_2_row[i+1] = a-&gt;p[i] - 1;
01089 
01090   <span class="comment">/* To not have element[0][] dangling, let it point to a-&gt;p[0][0].</span>
01091 <span class="comment">   */</span>
01092   new_ptr_2_row[0] = a-&gt;p[0];
01093 
01094   <span class="keywordflow">return</span>( new_ptr_2_row );
01095 }
01096 
01097 
01098 
01099 <span class="comment">/* Free pointer pointing to the matrix in Numerical-Rec.-in-C-format</span>
01100 <span class="comment"> */</span>
<a name="l01101"></a><a class="code" href="matrix_8c.html#a29">01101</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8c.html#a29">free_nric_ptr</a>(p)
01102 <span class="keywordtype">float</span> **p;
01103 {
01104   free( (<span class="keywordtype">char</span> *)  p);
01105 }
01106 
01107 
01108 
01109 <span class="comment">/* Returns vector dot product of the two vectors: row 0 of matrix a and b.</span>
01110 <span class="comment"> */</span>
<a name="l01111"></a><a class="code" href="matrix_8c.html#a30">01111</a> <span class="keywordtype">float</span> <a class="code" href="matrix_8h.html#a21">mat_vec_dot</a>(a, ar, b, br)
01112 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b;
01113 <span class="keywordtype">int</span> ar, br;
01114 {
01115   <span class="keywordtype">int</span> i;
01116   <span class="keywordtype">float</span> d = 0;
01117 
01118   <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;cols; i++) 
01119     d += a-&gt;p[ar][i] * b-&gt;p[br][i];
01120 
01121   <span class="keywordflow">return</span>( d );
01122 }
01123 
01124 
01125 
01126 <span class="comment">/* Returns vector cross product of the two vectors: row ra, rb of matrix a and b.</span>
01127 <span class="comment"> * Result vector matrix c must be of size [1][m] or [n][m].</span>
01128 <span class="comment"> */</span>
<a name="l01129"></a><a class="code" href="matrix_8c.html#a31">01129</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a22">mat_vec_cross</a>(a, ar, b, br, c)
01130 <a class="code" href="structMATRIX.html">MATRIX</a> *a, *b, *c;
01131 <span class="keywordtype">int</span> ar, br;
01132 {
01133   c-&gt;p[0][0] = a-&gt;p[ar][1] * b-&gt;p[br][2] - a-&gt;p[ar][2] * b-&gt;p[br][1];
01134   c-&gt;p[0][1] = a-&gt;p[ar][2] * b-&gt;p[br][0] - a-&gt;p[ar][0] * b-&gt;p[br][2];
01135   c-&gt;p[0][2] = a-&gt;p[ar][0] * b-&gt;p[br][1] - a-&gt;p[ar][1] * b-&gt;p[br][0];
01136 }
01137 
01138 
01139 
01140 <span class="comment">/* returns length (absolute value) of the vector: row r of matrix a.</span>
01141 <span class="comment"> */</span>
<a name="l01142"></a><a class="code" href="matrix_8c.html#a32">01142</a> <span class="keywordtype">float</span> <a class="code" href="matrix_8h.html#a23">mat_vec_abs</a>(a, r)
01143 <a class="code" href="structMATRIX.html">MATRIX</a> *a;
01144 <span class="keywordtype">int</span> r;
01145 {
01146   <span class="keywordtype">int</span> i;
01147   <span class="keywordtype">float</span> d = 0;
01148 
01149   <span class="keywordflow">for</span> (i = 0; i &lt; a-&gt;cols; i++) 
01150     d += a-&gt;p[r][i] * a-&gt;p[r][i];
01151 
01152   <span class="keywordflow">return</span>( sqrt(d) );
01153 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:35 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
