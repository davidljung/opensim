<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>opensim/base/SVD.cpp~ Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>opensim/base/SVD.cpp~</h1><a href="SVD_8cpp~.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/****************************************************************************</font>
00002 <font class="comment">  Copyright (C)2002 David Jung &lt;djung@pobox.com&gt;</font>
00003 <font class="comment"></font>
00004 <font class="comment">  This program/file is free software; you can redistribute it and/or modify</font>
00005 <font class="comment">  it under the terms of the GNU General Public License as published by</font>
00006 <font class="comment">  the Free Software Foundation; either version 2 of the License, or</font>
00007 <font class="comment">  (at your option) any later version.</font>
00008 <font class="comment">  </font>
00009 <font class="comment">  This program is distributed in the hope that it will be useful,</font>
00010 <font class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00011 <font class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
00012 <font class="comment">  GNU General Public License for more details. (http://www.gnu.org)</font>
00013 <font class="comment">  </font>
00014 <font class="comment">  You should have received a copy of the GNU General Public License</font>
00015 <font class="comment">  along with this program; if not, write to the Free Software</font>
00016 <font class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</font>
00017 <font class="comment">  </font>
00018 <font class="comment">  $Id: SVD.cpp,v 1.1 2002/07/12 19:40:03 jungd Exp $</font>
00019 <font class="comment">  $Revision: 1.1 $</font>
00020 <font class="comment">  $Date: 2002/07/12 19:40:03 $</font>
00021 <font class="comment">  $Author: jungd $</font>
00022 <font class="comment"> </font>
00023 <font class="comment">****************************************************************************/</font>
00024 
00025 
00039 <font class="preprocessor">#include &lt;<a class="code" href="SVD.html">base/SVD</a>&gt;</font>
00040 
00041 <font class="keyword">using</font> <a class="code" href="classbase_1_1SVD.html">base::SVD</a>;
00042 <font class="keyword">using</font> base::Matrix;
00043 <font class="keyword">using</font> base::DenseMatrix;
00044 <font class="keyword">using</font> base::Vector;
00045 
00046 
00047 <font class="comment">/*</font>
00048 <font class="comment">*------------------------------------------------------------------------</font>
00049 <font class="comment">*                               Bidiagonalization</font>
00050 <font class="comment">*/</font>
00051 <font class="comment">/*</font>
00052 <font class="comment">*                       Left Hausholder Transformations</font>
00053 <font class="comment">*</font>
00054 <font class="comment">* Zero out an entire subdiagonal of the i-th column of A and compute the</font>
00055 <font class="comment">* modified A[i,i] by multiplication (UP' * A) with a matrix UP'</font>
00056 <font class="comment">*   (1)  UP' = E - UPi * UPi' / beta</font>
00057 <font class="comment">*</font>
00058 <font class="comment">* where a column-vector UPi is as follows</font>
00059 <font class="comment">*   (2)  UPi = [ (i-1) zeros, A[i,i] + Norm, vector A[i+1:M,i] ]</font>
00060 <font class="comment">* where beta = UPi' * A[,i] and Norm is the norm of a vector A[i:M,i]</font>
00061 <font class="comment">* (sub-diag part of the i-th column of A). Note we assign the Norm the</font>
00062 <font class="comment">* same sign as that of A[i,i].</font>
00063 <font class="comment">* By construction, (1) does not affect the first (i-1) rows of A. Since</font>
00064 <font class="comment">* A[*,1:i-1] is bidiagonal (the result of the i-1 previous steps of</font>
00065 <font class="comment">* the bidiag algorithm), transform (1) doesn't affect these i-1 columns</font>
00066 <font class="comment">* either as one can easily verify.</font>
00067 <font class="comment">* The i-th column of A is transformed as</font>
00068 <font class="comment">*   (3)  UP' * A[*,i] = A[*,i] - UPi</font>
00069 <font class="comment">* (since UPi'*A[*,i]/beta = 1 by construction of UPi and beta)</font>
00070 <font class="comment">* This means effectively zeroing out A[i+1:M,i] (the entire subdiagonal</font>
00071 <font class="comment">* of the i-th column of A) and replacing A[i,i] with the -Norm. Thus</font>
00072 <font class="comment">* modified A[i,i] is returned by the present function.</font>
00073 <font class="comment">* The other (i+1:N) columns of A are transformed as</font>
00074 <font class="comment">*       (4)  UP' * A[,j] = A[,j] - UPi * ( UPi' * A[,j] / beta )</font>
00075 <font class="comment">* Note, due to (2), only elements of rows i+1:M actually  participate</font>
00076 <font class="comment">* in above transforms; the upper i-1 rows of A are not affected.</font>
00077 <font class="comment">* As was mentioned earlier,</font>
00078 <font class="comment">* (5)  beta = UPi' * A[,i] = (A[i,i] + Norm)*A[i,i] + A[i+1:M,i]*A[i+1:M,i]</font>
00079 <font class="comment">*       = ||A[i:M,i]||^2 + Norm*A[i,i] = Norm^2 + Norm*A[i,i]</font>
00080 <font class="comment">* (note the sign of the Norm is the same as A[i,i])</font>
00081 <font class="comment">* For extra precision, vector UPi (and so is Norm and beta) are scaled,</font>
00082 <font class="comment">* which would not affect (4) as easy to see.</font>
00083 <font class="comment">*</font>
00084 <font class="comment">* To satisfy the definition</font>
00085 <font class="comment">*   (6)  .SIG = U' A V</font>
00086 <font class="comment">* the result of consecutive transformations (1) over matrix A is accumulated</font>
00087 <font class="comment">* in matrix U' (which is initialized to be a unit matrix). At each step,</font>
00088 <font class="comment">* U' is left-multiplied by UP' = UP (UP is symmetric by construction,</font>
00089 <font class="comment">* see (1)). That is, U is right-multiplied by UP, that is, rows of U are</font>
00090 <font class="comment">* transformed similarly to columns of A, see eq. (4). We also keep in mind</font>
00091 <font class="comment">* that multiplication by UP at the i-th step does not affect the first i-1</font>
00092 <font class="comment">* columns of U.</font>
00093 <font class="comment">* Note that the vector UPi doesn't have to be allocated explicitly: its</font>
00094 <font class="comment">* first i-1 components are zeros (which we can always imply in computations),</font>
00095 <font class="comment">* and the rest of the components (but the UPi[i]) are the same as those</font>
00096 <font class="comment">* of A[i:M,i], the subdiagonal of A[,i]. This column, A[,i] is affected only</font>
00097 <font class="comment">* trivially as explained above, that is, we don't need to carry this</font>
00098 <font class="comment">* transformation explicitly (only A[i,i] is going to be non-trivially</font>
00099 <font class="comment">* affected, that is, replaced by -Norm, but we will use sig[i] to store</font>
00100 <font class="comment">* the result).</font>
00101 <font class="comment">*</font>
00102 <font class="comment">*/</font>
00103 <font class="keyword">inline</font> Real SVD::leftHausholder ( DenseMatrix &amp;A, sizet i )<font class="keyword"></font>
00104 <font class="keyword"></font>{
00105         ColRef UPi = mtl::columns(A)[i]; <font class="comment">// Note that only UPi[i:M] matter</font>
00106         sizet j, k ;
00107         Real            sfactor = 0 ;  <font class="comment">// Compute the scaling factor</font>
00108         
00109         <font class="keywordflow">for</font> ( k = i ; k &lt; M ; k++ ) 
00110                 sfactor += fabs(UPi[k]);
00111 
00112         <font class="keywordflow">if</font> ( sfactor == 0 ) 
00113         {
00114                 <font class="comment">// If A[,i] is a null vector, no transform is required</font>
00115                 <font class="keywordflow">return</font> 0;
00116         }
00117 
00118         Real  Norm_sqr = 0 ; <font class="comment">// Scale UPi (that is, A[,i])</font>
00119 
00120         <font class="keywordflow">for</font> ( k = i ; k &lt; M ; k++ ) 
00121         {
00122                 <font class="comment">// and compute its norm, Norm^2</font>
00123                 Norm_sqr += <a class="code" href="namespace__base.html#a59">sqr</a>(UPi[k] /= sfactor);
00124         }
00125         
00126         Real  new_Aii = <a class="code" href="namespace__base.html#a60">sqrt</a>(Norm_sqr); <font class="comment">// new_Aii = -Norm, Norm has the</font>
00127         
00128         <font class="keywordflow">if</font> ( UPi[i] &gt; 0 ) 
00129                 new_Aii = - new_Aii ; <font class="comment">// same sign as Aii (that is, UPi[i])</font>
00130         
00131         <font class="keyword">const</font> Real beta = - UPi[i] * new_Aii + Norm_sqr ;
00132         
00133         UPi[i] -= new_Aii ; <font class="comment">// UPi[i] = A[i,i] - (-Norm)</font>
00134         <font class="keywordflow">for</font> ( j = i + 1 ; j &lt; N ; j++ ) <font class="comment">// Transform i+1:N columns of A</font>
00135         {
00136                 Real    factor = 0 ;
00137                 <font class="keywordflow">for</font> ( k = i ; k &lt; M ; k++ ) 
00138                         factor += UPi[k] * A(k,j); <font class="comment">// Compute UPi' * A[,j]</font>
00139 
00140                 factor /= beta ;
00141                 <font class="keywordflow">for</font> ( k = i ; k &lt; M ; k++ ) 
00142                         A(k,j) -= UPi[k] * factor ;
00143         }
00144 
00145         <font class="keywordflow">for</font> ( j = 0 ; j &lt; M ; j++ ) <font class="comment">// Accumulate the transform in U</font>
00146         {
00147                 Real            factor = 0 ;
00148                 <font class="keywordflow">for</font> ( k = i ; k &lt; M ; k++ ) 
00149                         factor += UPi[k] * UMat(j,k); <font class="comment">// Compute  U[j,] * UPi</font>
00150 
00151                 factor /= beta ;
00152                 <font class="keywordflow">for</font> ( k = i ; k &lt; M ; k++ ) 
00153                         UMat(j,k) -= UPi[k] * factor ;
00154         }
00155         <font class="keywordflow">return</font> new_Aii * sfactor ; <font class="comment">// Scale new Aii back (our new Sig[i])</font>
00156 }
00157 
00158 <font class="comment">/*</font>
00159 <font class="comment">*                       Right Hausholder Transformations</font>
00160 <font class="comment">*</font>
00161 <font class="comment">* Zero out i+2:N elements of a row A[i,] of matrix A by right</font>
00162 <font class="comment">* multiplication (A * VP) with a matrix VP</font>
00163 <font class="comment">*   (1)  VP = E - VPi * VPi' / beta</font>
00164 <font class="comment">*</font>
00165 <font class="comment">* where a vector-column .VPi is as follows</font>
00166 <font class="comment">*   (2)  VPi = [ i zeros, A[i,i+1] + Norm, vector A[i,i+2:N] ]</font>
00167 <font class="comment">* where beta = A[i,] * VPi and Norm is the norm of a vector A[i,i+1:N]</font>
00168 <font class="comment">* (right-diag part of the i-th row of A). Note we assign the Norm the</font>
00169 <font class="comment">* same sign as that of A[i,i+1].</font>
00170 <font class="comment">* By construction, (1) does not affect the first i columns of A. Since</font>
00171 <font class="comment">* A[1:i-1,] is bidiagonal (the result of the previous steps of</font>
00172 <font class="comment">* the bidiag algorithm), transform (1) doesn't affect these i-1 rows</font>
00173 <font class="comment">* either as one can easily verify.</font>
00174 <font class="comment">* The i-th row of A is transformed as</font>
00175 <font class="comment">*  (3)  A[i,*] * VP = A[i,*] - VPi'</font>
00176 <font class="comment">* (since A[i,*]*VPi/beta = 1 by construction of VPi and beta)</font>
00177 <font class="comment">* This means effectively zeroing out A[i,i+2:N] (the entire right super-</font>
00178 <font class="comment">* diagonal of the i-th row of A, but ONE superdiag element) and replacing</font>
00179 <font class="comment">* A[i,i+1] with - Norm. Thus modified A[i,i+1] is returned as the result of</font>
00180 <font class="comment">* the present function.</font>
00181 <font class="comment">* The other (i+1:M) rows of A are transformed as</font>
00182 <font class="comment">*       (4)  A[j,] * VP = A[j,] - VPi' * ( A[j,] * VPi / beta )</font>
00183 <font class="comment">* Note, due to (2), only elements of columns i+1:N actually  participate</font>
00184 <font class="comment">* in above transforms; the left i columns of A are not affected.</font>
00185 <font class="comment">* As was mentioned earlier,</font>
00186 <font class="comment">* (5)  beta = A[i,] * VPi = (A[i,i+1] + Norm)*A[i,i+1]</font>
00187 <font class="comment">*                          + A[i,i+2:N]*A[i,i+2:N]</font>
00188 <font class="comment">*       = ||A[i,i+1:N]||^2 + Norm*A[i,i+1] = Norm^2 + Norm*A[i,i+1]</font>
00189 <font class="comment">* (note the sign of the Norm is the same as A[i,i+1])</font>
00190 <font class="comment">* For extra precision, vector VPi (and so is Norm and beta) are scaled,</font>
00191 <font class="comment">* which would not affect (4) as easy to see.</font>
00192 <font class="comment">*</font>
00193 <font class="comment">* The result of consecutive transformations (1) over matrix A is accumulated</font>
00194 <font class="comment">* in matrix V (which is initialized to be a unit matrix). At each step,</font>
00195 <font class="comment">* V is right-multiplied by VP. That is, rows of V are transformed similarly</font>
00196 <font class="comment">* to rows of A, see eq. (4). We also keep in mind that multiplication by</font>
00197 <font class="comment">* VP at the i-th step does not affect the first i rows of V.</font>
00198 <font class="comment">* Note that vector VPi doesn't have to be allocated explicitly: its</font>
00199 <font class="comment">* first i components are zeros (which we can always imply in computations),</font>
00200 <font class="comment">* and the rest of the components (but the VPi[i+1]) are the same as those</font>
00201 <font class="comment">* of A[i,i+1:N], the superdiagonal of A[i,]. This row, A[i,] is affected</font>
00202 <font class="comment">* only trivially as explained above, that is, we don't need to carry this</font>
00203 <font class="comment">* transformation explicitly (only A[i,i+1] is going to be non-trivially</font>
00204 <font class="comment">* affected, that is, replaced by -Norm, but we will use super_diag[i+1] to</font>
00205 <font class="comment">* store the result).</font>
00206 <font class="comment">*</font>
00207 <font class="comment">*/</font>
00208 <font class="keyword">inline</font> Real SVD::rightHausholder ( DenseMatrix &amp;A, sizet i )<font class="keyword"></font>
00209 <font class="keyword"></font>{
00210         RowRef VPi = rows(A)[i];  <font class="comment">// Note only VPi[i+1:N] matter</font>
00211         sizet j, k ;
00212         Real                    sfactor = 0 ;  <font class="comment">// Compute the scaling factor</font>
00213         
00214         <font class="keywordflow">for</font> ( k = i + 1 ; k &lt; N ; k++ ) 
00215                 sfactor += fabs(VPi[k]);
00216         <font class="keywordflow">if</font> ( sfactor == 0 ) 
00217         {
00218                 <font class="comment">// If VPi[i,] is a null vector, no</font>
00219                 <font class="keywordflow">return</font> 0 ; <font class="comment">// transform is required</font>
00220         }
00221         
00222         Real  Norm_sqr = 0 ; <font class="comment">// Scale VPi</font>
00223         
00224         <font class="keywordflow">for</font> ( k = i + 1 ; k &lt; N ; k++ ) 
00225         {
00226                 <font class="comment">// and compute its norm, Norm^2</font>
00227                 Norm_sqr += <a class="code" href="namespace__base.html#a59">sqr</a>(VPi[k] /= sfactor);
00228         }
00229         
00230         Real  new_Aii1 = <a class="code" href="namespace__base.html#a60">sqrt</a>(Norm_sqr); <font class="comment">// new_Aii1 = -Norm, Norm has the</font>
00231         
00232         <font class="keywordflow">if</font> ( VPi[i + 1] &gt; 0 ) 
00233         {
00234                 <font class="comment">// same sign as</font>
00235                 new_Aii1 = - new_Aii1 ; <font class="comment">// Aii1 (that is, VPi[i+1])</font>
00236         }
00237         
00238         <font class="keyword">const</font> Real beta = - VPi[i + 1] * new_Aii1 + Norm_sqr ;
00239         
00240         VPi[i + 1] -= new_Aii1 ; <font class="comment">// VPi[i+1] = A[i,i+1] - (-Norm)</font>
00241         <font class="keywordflow">for</font> ( j = i + 1 ; j &lt; M ; j++ ) <font class="comment">// Transform i+1:M rows of A</font>
00242         {
00243                 Real            factor = 0 ;
00244                 <font class="keywordflow">for</font> ( k = i + 1 ; k &lt; N ; k++ ) 
00245                         factor += VPi[k] * A(j,k); <font class="comment">// Compute A[j,] * VPi</font>
00246                 factor /= beta ;
00247                 <font class="keywordflow">for</font> ( k = i + 1 ; k &lt; N ; k++ ) 
00248                         A(j,k) -= VPi[k] * factor ;
00249         }
00250         <font class="keywordflow">for</font> ( j = 0 ; j &lt; N ; j++ ) <font class="comment">// Accumulate the transform in V</font>
00251         {
00252                 Real            factor = 0 ;
00253                 <font class="keywordflow">for</font> ( k = i + 1 ; k &lt; N ; k++ ) 
00254                         factor += VPi[k] * VMat(j,k); <font class="comment">// Compute  V[j,] * VPi</font>
00255                 factor /= beta ;
00256                 <font class="keywordflow">for</font> ( k = i + 1 ; k &lt; N ; k++ ) 
00257                         VMat(j,k) -= VPi[k] * factor ;
00258         }
00259         <font class="keywordflow">return</font> new_Aii1 * sfactor ; <font class="comment">// Scale new Aii1 back</font>
00260 }
00261 
00262 <font class="comment">/*</font>
00263 <font class="comment">*------------------------------------------------------------------------</font>
00264 <font class="comment">*                         Bidiagonalization</font>
00265 <font class="comment">* This nethod turns matrix A into a bidiagonal one. Its N diagonal elements</font>
00266 <font class="comment">* are stored in a vector sig, while N-1 superdiagonal elements are stored</font>
00267 <font class="comment">* in a vector super_diag(2:N) (with super_diag(1) being always 0).</font>
00268 <font class="comment">* Matrices U and V store the record of orthogonal Hausholder</font>
00269 <font class="comment">* reflections that were used to convert A to this form. The method</font>
00270 <font class="comment">* returns the norm of the resulting bidiagonal matrix, that is, the</font>
00271 <font class="comment">* maximal column sum.</font>
00272 <font class="comment">*/</font>
00273 Real SVD::bidiagonalize ( Vector &amp;super_diag, <font class="keyword">const</font> DenseMatrix &amp;_A )<font class="keyword"></font>
00274 <font class="keyword"></font>{
00275         Real  norm_acc = 0 ;
00276         
00277         super_diag[0] = 0 ; <font class="comment">// No superdiag elem above A(1,1)</font>
00278 
00279         DenseMatrix A(_A.nrows(), _A.ncols());
00280         copy(_A, A);
00281         
00282         <font class="keywordflow">for</font> ( sizet i = 0 ; i &lt; N ; i++ ) 
00283         {
00284                 <font class="keyword">const</font> Real  &amp;diagi = sig[i] = leftHausholder(A, i);
00285                 <font class="keywordflow">if</font> ( i &lt; (N-1) ) 
00286                         super_diag[i + 1] = rightHausholder(A, i);
00287                 norm_acc = <a class="code" href="namespace__base.html#a82">maximum</a>(norm_acc, fabs(diagi) + fabs(super_diag[i]));
00288         }
00289         <font class="keywordflow">return</font> norm_acc ;
00290 }
00291 
00292 <font class="comment">/*</font>
00293 <font class="comment">*------------------------------------------------------------------------</font>
00294 <font class="comment">*               QR-diagonalization of a bidiagonal matrix</font>
00295 <font class="comment">*</font>
00296 <font class="comment">* After bidiagonalization we get a bidiagonal matrix J:</font>
00297 <font class="comment">*       (1)  J = U' * A * V</font>
00298 <font class="comment">* The present method turns J into a matrix JJ by applying a set of</font>
00299 <font class="comment">* orthogonal transforms</font>
00300 <font class="comment">*       (2)  JJ = S' * J * T</font>
00301 <font class="comment">* Orthogonal matrices S and T are chosen so that JJ were also a</font>
00302 <font class="comment">* bidiagonal matrix, but with superdiag elements smaller than those of J.</font>
00303 <font class="comment">* We repeat (2) until non-diag elements of JJ become smaller than EPS</font>
00304 <font class="comment">* and can be disregarded.</font>
00305 <font class="comment">* Matrices S and T are constructed as</font>
00306 <font class="comment">*       (3)  S = S1 * S2 * S3 ... Sn, and similarly T</font>
00307 <font class="comment">* where Sk and Tk are matrices of simple rotations</font>
00308 <font class="comment">*       (4)  Sk[i,j] = i==j ? 1 : 0 for all i&gt;k or i&lt;k-1</font>
00309 <font class="comment">*                Sk[k-1,k-1] = cos(Phk),  Sk[k-1,k] = -sin(Phk),</font>
00310 <font class="comment">*                SK[k,k-1] = sin(Phk),  Sk[k,k] = cos(Phk), k=2..N</font>
00311 <font class="comment">* Matrix Tk is constructed similarly, only with angle Thk rather than Phk.</font>
00312 <font class="comment">*</font>
00313 <font class="comment">* Thus left multiplication of J by SK' can be spelled out as</font>
00314 <font class="comment">*       (5)  (Sk' * J)[i,j] = J[i,j] when i&gt;k or i&lt;k-1,</font>
00315 <font class="comment">*                                 [k-1,j] = cos(Phk)*J[k-1,j] + sin(Phk)*J[k,j]</font>
00316 <font class="comment">*                                 [k,j] =  -sin(Phk)*J[k-1,j] + cos(Phk)*J[k,j]</font>
00317 <font class="comment">* That is, k-1 and k rows of J are replaced by their linear combinations;</font>
00318 <font class="comment">* the rest of J is unaffected. Right multiplication of J by Tk similarly</font>
00319 <font class="comment">* changes only k-1 and k columns of J.</font>
00320 <font class="comment">* Matrix T2 is chosen the way that T2'J'JT2 were a QR-transform with a</font>
00321 <font class="comment">* shift. Note that multiplying J by T2 gives rise to a J[2,1] element of</font>
00322 <font class="comment">* the product J (which is below the main diagonal). Angle Ph2 is then</font>
00323 <font class="comment">* chosen so that multiplication by S2' (which combines 1 and 2 rows of J)</font>
00324 <font class="comment">* gets rid of that elemnent. But this will create a [1,3] non-zero element.</font>
00325 <font class="comment">* T3 is made to make it disappear, but this leads to [3,2], etc.</font>
00326 <font class="comment">* In the end, Sn removes a [N,N-1] element of J and matrix S'JT becomes</font>
00327 <font class="comment">* bidiagonal again. However, because of a special choice</font>
00328 <font class="comment">* of T2 (QR-algorithm), its non-diag elements are smaller than those of J.</font>
00329 <font class="comment">*</font>
00330 <font class="comment">* All this process in more detail is described in</font>
00331 <font class="comment">*       J.H. Wilkinson, C. Reinsch. Linear algebra - Springer-Verlag, 1971</font>
00332 <font class="comment">*</font>
00333 <font class="comment">* If during transforms (1), JJ[N-1,N] turns 0, then JJ[N,N] is a singular</font>
00334 <font class="comment">* number (possibly with a wrong (that is, negative) sign). This is a</font>
00335 <font class="comment">* consequence of Frantsis' Theorem, see the book above. In that case, we can</font>
00336 <font class="comment">* eliminate the N-th row and column of JJ and carry out further transforms</font>
00337 <font class="comment">* with a smaller matrix. If any other superdiag element of JJ turns 0,</font>
00338 <font class="comment">* then JJ effectively falls into two independent matrices. We will process</font>
00339 <font class="comment">* them independently (the bottom one first).</font>
00340 <font class="comment">*</font>
00341 <font class="comment">* Since matrix J is a bidiagonal, it can be stored efficiently. As a matter</font>
00342 <font class="comment">* of fact, its N diagonal elements are in array Sig, and superdiag elements</font>
00343 <font class="comment">* are stored in array super_diag.</font>
00344 <font class="comment">*/</font>
00345 <font class="comment">// Carry out U * S with a rotation matrix</font>
00346 <font class="comment">// S (which combines i-th and j-th columns</font>
00347 <font class="comment">// of U, i&gt;j)</font>
00348 <font class="keyword">inline</font> <font class="keywordtype">void</font> <a class="code" href="Matrix3_8cpp.html#a2">SVD::rotate</a> ( DenseMatrix &amp;mat, sizet i, sizet j,
00349                           <font class="keyword">const</font> Real cos_ph, <font class="keyword">const</font> Real sin_ph )<font class="keyword"></font>
00350 <font class="keyword"></font>{
00351         <font class="keywordflow">for</font> ( sizet l = 0 ; l &lt; mat.nrows() ; l++ ) 
00352         {
00353                 RowRef Ml = rows(mat)[l];
00354                 <font class="keyword">const</font> Real  Ujl_was = Ml[j];
00355                 Ml[j] =   cos_ph * Ujl_was + sin_ph * Ml[i] ;
00356                 Ml[i] = - sin_ph * Ujl_was + cos_ph * Ml[i] ;
00357         }
00358 }
00359 
00360 <font class="comment">/*</font>
00361 <font class="comment">* A diagonal element J[l-1,l-1] turns out 0 at the k-th step of the</font>
00362 <font class="comment">* algorithm. That means that one of the original matrix' singular numbers</font>
00363 <font class="comment">* shall be zero. In that case, we multiply J by specially selected</font>
00364 <font class="comment">* matrices S' of simple rotations to eliminate a superdiag element J[l-1,l].</font>
00365 <font class="comment">* After that, matrix J falls into two pieces, which can be dealt with</font>
00366 <font class="comment">* in a regular way (the bottom piece first).</font>
00367 <font class="comment">* </font>
00368 <font class="comment">* These special S transformations are accumulated into matrix U: since J</font>
00369 <font class="comment">* is left-multiplied by S', U would be right-multiplied by S. Transform</font>
00370 <font class="comment">* formulas for doing these rotations are similar to (5) above. See the</font>
00371 <font class="comment">* book cited above for more details.</font>
00372 <font class="comment">*/</font>
00373 <font class="keyword">inline</font> <font class="keywordtype">void</font> SVD::ripThrough ( Vector &amp;super_diag, sizet k, sizet l, <font class="keyword">const</font> Real eps )<font class="keyword"></font>
00374 <font class="keyword"></font>{
00375         Real  cos_ph = 0, sin_ph = 1 ; <font class="comment">// Accumulate cos,sin of Ph</font>
00376         
00377         <font class="comment">// The first step of the loop below</font>
00378         <font class="comment">// (when i==l) would eliminate J[l-1,l],</font>
00379         <font class="comment">// which is stored in super_diag(l)</font>
00380         <font class="comment">// However, it gives rise to J[l-1,l+1]</font>
00381         <font class="comment">// and J[l,l+2]</font>
00382         <font class="comment">// The following steps eliminate these</font>
00383         <font class="comment">// until they fall below</font>
00384         <font class="comment">// significance</font>
00385         <font class="keywordflow">for</font> ( sizet i = l ; i &lt;= k ; i++ ) {
00386                 <font class="keyword">const</font> Real      f = sin_ph * super_diag[i];
00387                 super_diag[i] *= cos_ph ;
00388                 <font class="keywordflow">if</font> ( f &lt;= eps ) 
00389                         <font class="keywordflow">break</font> ; <font class="comment">// Current J[l-1,l] became unsignificant</font>
00390                 cos_ph = sig[i];
00391                 sin_ph = - f ; <font class="comment">// unnormalized sin/cos</font>
00392                 <font class="keyword">const</font> Real norm = sig[i] = hypot(cos_ph, sin_ph); <font class="comment">// sqrt(sin^2+cos^2)</font>
00393                 cos_ph /= norm, sin_ph /= norm ; <font class="comment">// Normalize sin/cos</font>
00394                 <a class="code" href="Matrix3_8cpp.html#a2">rotate</a>(UMat, i, l - 1, cos_ph, sin_ph);
00395         }
00396 }
00397 
00398 <font class="comment">// We're about to proceed doing QR-transforms</font>
00399 <font class="comment">// on a (bidiag) matrix J[1:k,1:k]. It may happen</font>
00400 <font class="comment">// though that the matrix splits (or can be</font>
00401 <font class="comment">// split) into two independent pieces. This function</font>
00402 <font class="comment">// checks for splitting and returns the lowerbound</font>
00403 <font class="comment">// index l of the bottom piece, J[l:k,l:k]</font>
00404 <font class="keyword">inline</font> SVD::sizet SVD::getSubmatrixToWorkOn ( Vector &amp;super_diag, sizet k, <font class="keyword">const</font> Real eps )<font class="keyword"></font>
00405 <font class="keyword"></font>{
00406         <font class="keywordflow">for</font> ( sizet l = k ; l &gt; 0 ; l-- ) 
00407                 <font class="keywordflow">if</font> ( fabs(super_diag[l]) &lt;= eps ) 
00408                         <font class="keywordflow">return</font> l ; <font class="comment">// The breaking point: zero J[l-1,l]</font>
00409                 <font class="keywordflow">else</font> <font class="keywordflow">if</font> ( fabs(sig[l - 1]) &lt;= eps ) <font class="comment">// Diagonal J[l,l] turns out 0</font>
00410                 {
00411                         <font class="comment">// meaning J[l-1,l] _can_ be made</font>
00412                         ripThrough(super_diag, k , l, eps); <font class="comment">// zero after some rotations</font>
00413                         <font class="keywordflow">return</font> l ;
00414                 }
00415         <font class="keywordflow">return</font> 0 ; <font class="comment">// Deal with J[1:k,1:k] as a whole</font>
00416 }
00417 
00418 <font class="comment">// Diagonalize root module</font>
00419 <font class="keywordtype">void</font> SVD::diagonalize ( Vector &amp;super_diag, <font class="keyword">const</font> Real eps )<font class="keyword"></font>
00420 <font class="keyword"></font>{
00421         <font class="keywordflow">for</font> ( <font class="keywordtype">int</font> k = N-1 ; k &gt;= 0 ; k-- ) <font class="comment">// QR-iterate upon J[l:k,l:k]</font>
00422         {
00423                 sizet l ;
00424                 <font class="keywordflow">while</font> ( l = getSubmatrixToWorkOn(super_diag, k, eps)
00425                         , fabs(super_diag[k]) &gt; eps ) <font class="comment">// until superdiag J[k-1,k] becomes 0</font>
00426                 {
00427                         Real  shift ; <font class="comment">// Compute a QR-shift from a bottom</font>
00428                         {
00429                                 <font class="comment">// corner minor of J[l:k,l:k] order 2</font>
00430                                 Real    Jk2k1 = super_diag[k - 1], <font class="comment">// J[k-2,k-1]</font>
00431                                                 Jk1k = super_diag[k] , 
00432                                                 Jk1k1 = sig[k - 1], <font class="comment">// J[k-1,k-1]</font>
00433                                                 Jkk = sig[k] , 
00434                                                 Jll = sig[l]; <font class="comment">// J[l,l]</font>
00435                                 shift = (Jk1k1 - Jkk) * (Jk1k1 + Jkk) + (Jk2k1 - Jk1k) * 
00436                                                 (Jk2k1 + Jk1k);
00437                                 shift /= 2 * Jk1k * Jk1k1 ;
00438                                 shift += (shift &lt; 0 ? - 1 : 1) * <a class="code" href="namespace__base.html#a60">sqrt</a>(shift * shift + 1);
00439                                 shift = ((Jll - Jkk) * (Jll + Jkk) + Jk1k * 
00440                                         (Jk1k1 / shift - Jk1k)) / Jll ;
00441                         }
00442                                                                                         
00443                         <font class="comment">// Carry on multiplications by T2, S2, T3...</font>
00444                         Real cos_th = 1, sin_th = 1 ;
00445                         Real Ji1i1 = sig[l];  <font class="comment">// J[i-1,i-1] at i=l+1...k</font>
00446                         <font class="keywordflow">for</font> ( sizet i = l + 1 ; i &lt;= (sizet)k ; i++ ) 
00447                         {
00448                                 Real    Ji1i = super_diag[i], Jii = sig[i]; <font class="comment">// J[i-1,i] and J[i,i]</font>
00449                                 sin_th *= Ji1i ;
00450                                 Ji1i *= cos_th ;
00451                                 cos_th = shift ;
00452                                 Real  norm_f = super_diag[i - 1] = hypot(cos_th, sin_th);
00453                                 cos_th /= norm_f, sin_th /= norm_f ;
00454                                                                                                 
00455                                 <font class="comment">// Rotate J[i-1:i,i-1:i] by Ti</font>
00456                                 shift = cos_th * Ji1i1 + sin_th * Ji1i ; <font class="comment">// new J[i-1,i-1]</font>
00457                                 Ji1i = - sin_th * Ji1i1 + cos_th * Ji1i ; <font class="comment">// J[i-1,i] after rotation</font>
00458                                 <font class="keyword">const</font> Real      Jii1 = Jii * sin_th ; <font class="comment">// Emerged J[i,i-1]</font>
00459                                 Jii *= cos_th ; <font class="comment">// new J[i,i]</font>
00460                                 <a class="code" href="Matrix3_8cpp.html#a2">rotate</a>(VMat, i, i - 1, cos_th, sin_th); <font class="comment">// Accumulate T rotations in V</font>
00461                                 Real  cos_ph = shift, sin_ph = Jii1 ; <font class="comment">// Make Si to get rid of J[i,i-1]</font>
00462                                 sig[i - 1] = norm_f = hypot(cos_ph, sin_ph); <font class="comment">// New J[i-1,i-1]</font>
00463                                 <font class="keywordflow">if</font> ( norm_f == 0 ) 
00464                                         <font class="comment">// If norm =0, rotation angle</font>
00465                                         cos_ph = cos_th, sin_ph = sin_th ; <font class="comment">// can be anything now</font>
00466                                 <font class="keywordflow">else</font> 
00467                                         cos_ph /= norm_f, sin_ph /= norm_f ;
00468                                                                                                 
00469                                 <font class="comment">// Rotate J[i-1:i,i-1:i] by Si</font>
00470                                 shift = cos_ph * Ji1i + sin_ph * Jii ; <font class="comment">// New J[i-1,i]</font>
00471                                 Ji1i1 = - sin_ph * Ji1i + cos_ph * Jii ; <font class="comment">// New Jii, would carry over</font>
00472 
00473                                 <font class="comment">// as J[i-1,i-1] for next i</font>
00474                                 <a class="code" href="Matrix3_8cpp.html#a2">rotate</a>(UMat, i, i - 1, cos_ph, sin_ph); <font class="comment">// Accumulate S rotations in U</font>
00475                                                                                                 
00476                                 <font class="comment">// Jii1 disappears, sin_th would</font>
00477                                 cos_th = cos_ph, sin_th = sin_ph ; <font class="comment">// carry over a (scaled) J[i-1,i+1]</font>
00478                                 <font class="comment">// to eliminate on the next i, cos_th</font>
00479                                 <font class="comment">// would carry over a scaled J[i,i+1]</font>
00480                         }
00481                         super_diag[l] = 0 ; <font class="comment">// Supposed to be eliminated by now</font>
00482                         super_diag[k] = shift ;
00483                         sig[k] = Ji1i1 ;
00484                 } <font class="comment">// --- end-of-QR-iterations</font>
00485                 <font class="keywordflow">if</font> ( sig[k] &lt; 0 ) <font class="comment">// Correct the sign of the sing number</font>
00486                 {
00487                         sig[k] = - sig[k];
00488                         <font class="keywordflow">for</font> ( sizet j = 0 ; j &lt; VMat.nrows() ; j++ ) 
00489                                 VMat(j, k) = - VMat(j, k);
00490                 }                                                  
00491         }
00492 }
00493 
00494 <font class="comment">/*</font>
00495 <font class="comment">*------------------------------------------------------------------------</font>
00496 <font class="comment">*                               The root Module</font>
00497 <font class="comment">*/</font>
00498 SVD::SVD ( <font class="keyword">const</font> Matrix &amp;A )
00499         : M(A.nrows()),  N(A.ncols()),  UMat(A.nrows(), A.nrows())
00500         ,  VMat(A.ncols(), A.ncols()),  sig(A.ncols())
00501 {
00502         <a class="code" href="base.html#a18">Assertm</a>(M &gt;= N,<font class="stringliteral">"A.nrows() must be &gt;= A.ncols()"</font>);
00503 
00504         <font class="comment">//eye(UMat);</font>
00505         <font class="comment">//eye(VMat);</font>
00506         <a class="code" href="namespace__base.html#a100">setIdentity</a>(UMat);
00507         <a class="code" href="namespace__base.html#a100">setIdentity</a>(VMat);
00508         
00509         Vector super_diag(N);
00510         DenseMatrix DA(A.nrows(), A.ncols());
00511         copy(A,DA);
00512         <font class="keyword">const</font> Real      bidiag_norm = bidiagonalize(super_diag, DA);
00513         <font class="keyword">const</font> Real      eps = base::epsilon2 * bidiag_norm ; <font class="comment">// Significance threshold !!!</font>
00514 <font class="comment">//      const Real      eps = DBL_EPSILON * bidiag_norm ; // Significance threshold</font>
00515 <font class="comment">//      const Real      eps = FLT_EPSILON * bidiag_norm ; // Significance threshold</font>
00516         
00517         diagonalize(super_diag, eps);
00518 }
00519 
00520 <font class="comment">// sig_max/sig_min</font>
00521 Real SVD::condition ( )<font class="keyword"> const</font>
00522 <font class="keyword"></font>{
00523         sizet minInd = min_index(sig);
00524         sizet maxInd = max_index(sig);
00525 
00526         Real min = sig[minInd];
00527         Real max = sig[maxInd];
00528 
00529         <font class="keywordflow">if</font>(min / max &lt; 1.0/MAXCONDITION)
00530                 <font class="keywordflow">return</font> MAXCONDITION;
00531         <font class="keywordflow">else</font>
00532                 <font class="keywordflow">return</font> max / min;
00533 }
00534 
00535 Matrix SVD::inv()<font class="keyword"> const</font>
00536 <font class="keyword"></font>{
00537 
00538         <font class="comment">// combine the products to form the pseudo inverse solution</font>
00539         DenseMatrix tmpMat(VMat.nrows(), VMat.ncols());
00540         
00541         copy(VMat, tmpMat);
00542         
00543         <font class="comment">// invert the diagonal elements and apply to the invA matrix</font>
00544         <font class="keywordflow">for</font>(sizet i=0; i&lt;sig.size(); i++)
00545         {
00546                 Real tmp = sig[i];
00547                 <font class="keywordflow">if</font>(fabs(tmp) &lt; MINSINGVALUE)
00548                         tmp = 0.0;
00549                 <font class="keywordflow">else</font>
00550                         tmp = 1.0 / tmp;
00551 
00552                 scale( columns(tmpMat)[i] , tmp);
00553         }
00554 
00555         <font class="comment">// U^-1 == U^T </font>
00556         Matrix invA(VMat.nrows(), UMat.nrows());
00557         mult(tmpMat, trans(UMat), invA);
00558         <font class="keywordflow">return</font> invA;
00559 }
</pre></div><hr><address><small>Generated at Wed Aug 7 10:30:29 2002 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
