<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/Singleton Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/Singleton</h1><a href="Singleton.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2001 by Andrei Alexandrescu</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This file is a derivative of a file from the Loki Library written by</span>
00005 <span class="comment">  Andrei Alexandrescu.  It was distributed by him under the terms</span>
00006 <span class="comment">  listed below (titled Loki Original Distribution Terms).</span>
00007 <span class="comment">  In accordance with the terms, this distribution contains the copyright</span>
00008 <span class="comment">  notice here and the copyright notice and permission notice</span>
00009 <span class="comment">  in supporting documentation.  The terms do *not* require</span>
00010 <span class="comment">  redistribution under those same terms.  This code is distributed</span>
00011 <span class="comment">  to you under the terms of the GNU General Public License (GPL) </span>
00012 <span class="comment">  below.  The GPL does not require you to maintain the terms of</span>
00013 <span class="comment">  the Loki Original Distribution Terms, but you are encouraged to do so.</span>
00014 <span class="comment"></span>
00015 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00016 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00017 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00018 <span class="comment">  (at your option) any later version.</span>
00019 <span class="comment">  </span>
00020 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00021 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00022 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00023 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00024 <span class="comment">  </span>
00025 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00026 <span class="comment">  along with this program; if not, write to the Free Software</span>
00027 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00028 <span class="comment">  </span>
00029 <span class="comment"> ****************************************************************************</span>
00030 <span class="comment">  Loki Original Distribution Terms:</span>
00031 <span class="comment"></span>
00032 <span class="comment">  The Loki Library</span>
00033 <span class="comment">  Copyright (c) 2001 by Andrei Alexandrescu</span>
00034 <span class="comment">  This code accompanies the book:</span>
00035 <span class="comment">  Alexandrescu, Andrei. "Modern C++ Design: Generic Programming and Design </span>
00036 <span class="comment">      Patterns Applied". Copyright (c) 2001. Addison-Wesley.</span>
00037 <span class="comment">  Permission to use, copy, modify, distribute and sell this software for any </span>
00038 <span class="comment">      purpose is hereby granted without fee, provided that the above copyright </span>
00039 <span class="comment">      notice appear in all copies and that both that copyright notice and this </span>
00040 <span class="comment">      permission notice appear in supporting documentation.</span>
00041 <span class="comment">  The author or Addison-Welsey Longman make no representations about the </span>
00042 <span class="comment">      suitability of this software for any purpose. It is provided "as is" </span>
00043 <span class="comment">      without express or implied warranty.</span>
00044 <span class="comment"> ****************************************************************************</span>
00045 <span class="comment"></span>
00046 <span class="comment">  $Id: Singleton 1029 2004-02-11 20:45:54Z jungd $</span>
00047 <span class="comment">  $Revision: 1.1 $</span>
00048 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00049 <span class="comment">  $Author: jungd $</span>
00050 <span class="comment"> </span>
00051 <span class="comment">****************************************************************************/</span>
00052 
00053 <span class="comment">// Last update: June 20, 2001</span>
00054 
00055 <span class="preprocessor">#ifndef SINGLETON_INC_</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define SINGLETON_INC_</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#include &lt;<a class="code" href="Threads.html">base/Threads</a>&gt;</span>
00059 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00060 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00061 <span class="preprocessor">#include &lt;cassert&gt;</span>
00062 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00063 <span class="preprocessor">#include &lt;new&gt;</span>
00064 
00065 <span class="keyword">namespace </span><a class="code" href="base_2Jamfile_8ft.html#a0">base</a>
00066 {
00067     <span class="keyword">namespace </span>Private
00068     {<span class="comment"></span>
00069 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00070 <span class="comment"></span><span class="comment">// class LifetimeTracker</span>
00071 <span class="comment">// Helper class for SetLongevity</span><span class="comment"></span>
00072 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00073 <span class="comment"></span>
<a name="l00074"></a><a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">00074</a>         <span class="keyword">class </span><a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">LifetimeTracker</a>
00075         {
00076         <span class="keyword">public</span>:
<a name="l00077"></a><a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackera0">00077</a>             <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackera0">LifetimeTracker</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x) : longevity_(x) 
00078             {}
00079             
00080             <span class="keyword">virtual</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackera1">~LifetimeTracker</a>() = 0;
00081             
<a name="l00082"></a><a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackere0">00082</a>             <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackere0">Compare</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">LifetimeTracker</a>* lhs,
00083                 <span class="keyword">const</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">LifetimeTracker</a>* rhs)
00084             {
00085                 <span class="keywordflow">return</span> rhs-&gt;<a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackerr0">longevity_</a> &gt; lhs-&gt;<a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackerr0">longevity_</a>;
00086             }
00087             
00088         <span class="keyword">private</span>:
00089             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> longevity_;
00090         };
00091         
00092         <span class="comment">// Definition required</span>
<a name="l00093"></a><a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html#base_1_1Private_1_1LifetimeTrackera1">00093</a>         <span class="keyword">inline</span> LifetimeTracker::~LifetimeTracker() {} 
00094         
00095         <span class="comment">// Helper data</span>
<a name="l00096"></a><a class="code" href="namespacebase_1_1Private.html#a0">00096</a>         <span class="keyword">typedef</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">LifetimeTracker</a>** <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">TrackerArray</a>;
00097         <span class="keyword">extern</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">TrackerArray</a> <a class="code" href="namespacebase_1_1Private.html#a1">pTrackerArray</a>;
00098         <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacebase_1_1Private.html#a2">elements</a>;
00099 
00100         <span class="comment">// Helper destroyer function</span>
00101         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00102"></a><a class="code" href="structbase_1_1Private_1_1Deleter.html">00102</a>         <span class="keyword">struct </span><a class="code" href="structbase_1_1Private_1_1Deleter.html">Deleter</a>
00103         {
<a name="l00104"></a><a class="code" href="structbase_1_1Private_1_1Deleter.html#base_1_1Private_1_1Deletere0">00104</a>             <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1Private_1_1Deleter.html#base_1_1Private_1_1Deletere0">Delete</a>(T* pObj)
00105             { <span class="keyword">delete</span> pObj; }
00106         };
00107 
00108         <span class="comment">// Concrete lifetime tracker for objects of type T</span>
00109         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Destroyer&gt;
<a name="l00110"></a><a class="code" href="classbase_1_1Private_1_1ConcreteLifetimeTracker.html">00110</a>         <span class="keyword">class </span><a class="code" href="classbase_1_1Private_1_1ConcreteLifetimeTracker.html">ConcreteLifetimeTracker</a> : <span class="keyword">public</span> <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">LifetimeTracker</a>
00111         {
00112         <span class="keyword">public</span>:
<a name="l00113"></a><a class="code" href="classbase_1_1Private_1_1ConcreteLifetimeTracker.html#base_1_1Private_1_1ConcreteLifetimeTrackera0">00113</a>             <a class="code" href="classbase_1_1Private_1_1ConcreteLifetimeTracker.html#base_1_1Private_1_1ConcreteLifetimeTrackera0">ConcreteLifetimeTracker</a>(T* p,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> longevity, Destroyer d)
00114                 : <a class="code" href="classbase_1_1Private_1_1LifetimeTracker.html">LifetimeTracker</a>(longevity)
00115                 , pTracked_(p)
00116                 , destroyer_(d)
00117             {}
00118             
<a name="l00119"></a><a class="code" href="classbase_1_1Private_1_1ConcreteLifetimeTracker.html#base_1_1Private_1_1ConcreteLifetimeTrackera1">00119</a>             <a class="code" href="classbase_1_1Private_1_1ConcreteLifetimeTracker.html#base_1_1Private_1_1ConcreteLifetimeTrackera1">~ConcreteLifetimeTracker</a>()
00120             { destroyer_(pTracked_); }
00121             
00122         <span class="keyword">private</span>:
00123             T* pTracked_;
00124             Destroyer destroyer_;
00125         };
00126 
00127         <span class="keywordtype">void</span> <a class="code" href="namespacebase_1_1Private.html#a3">AtExitFn</a>(); <span class="comment">// declaration needed below</span>
00128     
00129     } <span class="comment">// namespace Private</span>
00130 <span class="comment"></span>
00131 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00132 <span class="comment"></span><span class="comment">// function template SetLongevity</span>
00133 <span class="comment">// Assigns an object a longevity; ensures ordered destructions of objects </span>
00134 <span class="comment">//     registered thusly during the exit sequence of the application</span><span class="comment"></span>
00135 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00136 <span class="comment"></span>
00137     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Destroyer&gt;
<a name="l00138"></a><a class="code" href="namespacebase.html#a186">00138</a>     <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a186">SetLongevity</a>(T* pDynObject, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> longevity,
00139         Destroyer d = <a class="code" href="structbase_1_1Private_1_1Deleter.html">Private::Deleter&lt;T&gt;</a>::Delete)
00140     {
00141         <span class="keyword">using</span> <span class="keyword">namespace </span><a class="code" href="classPrivate.html">Private</a>;
00142         
00143         TrackerArray pNewArray = static_cast&lt;TrackerArray&gt;(
00144                 std::realloc(pTrackerArray, elements + 1));
00145         <span class="keywordflow">if</span> (!pNewArray) <span class="keywordflow">throw</span> std::bad_alloc();
00146         
00147         LifetimeTracker* p = <span class="keyword">new</span> ConcreteLifetimeTracker&lt;T, Destroyer&gt;(
00148             pDynObject, longevity, d);
00149         
00150         <span class="comment">// Delayed assignment for exception safety</span>
00151         pTrackerArray = pNewArray;
00152         
00153         <span class="comment">// Insert a pointer to the object into the queue</span>
00154         TrackerArray pos = std::upper_bound(
00155             pTrackerArray, 
00156             pTrackerArray + elements, 
00157             p, 
00158             LifetimeTracker::Compare);
00159         std::copy_backward(
00160             pos, 
00161             pTrackerArray + elements,
00162             pTrackerArray + elements + 1);
00163         *pos = p;
00164         ++elements;
00165         
00166         <span class="comment">// Register a call to AtExitFn</span>
00167         std::atexit(Private::AtExitFn);
00168     }
00169 <span class="comment"></span>
00170 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00171 <span class="comment"></span><span class="comment">// class template CreateUsingNew</span>
00172 <span class="comment">// Implementation of the CreationPolicy used by SingletonHolder</span>
00173 <span class="comment">// Creates objects using a straight call to the new operator </span><span class="comment"></span>
00174 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00175 <span class="comment"></span>
<a name="l00176"></a><a class="code" href="structbase_1_1CreateUsingNew.html">00176</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span><a class="code" href="structbase_1_1CreateUsingNew.html">CreateUsingNew</a>
00177     {
<a name="l00178"></a><a class="code" href="structbase_1_1CreateUsingNew.html#base_1_1CreateUsingNewe0">00178</a>         <span class="keyword">static</span> T* <a class="code" href="structbase_1_1CreateUsingNew.html#base_1_1CreateUsingNewe0">Create</a>()
00179         { <span class="keywordflow">return</span> <span class="keyword">new</span> T; }
00180         
<a name="l00181"></a><a class="code" href="structbase_1_1CreateUsingNew.html#base_1_1CreateUsingNewe1">00181</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1CreateUsingNew.html#base_1_1CreateUsingNewe1">Destroy</a>(T* p)
00182         { <span class="keyword">delete</span> p; }
00183     };
00184     <span class="comment"></span>
00185 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00186 <span class="comment"></span><span class="comment">// class template CreateUsingNew</span>
00187 <span class="comment">// Implementation of the CreationPolicy used by SingletonHolder</span>
00188 <span class="comment">// Creates objects using a call to std::malloc, followed by a call to the </span>
00189 <span class="comment">//     placement new operator</span><span class="comment"></span>
00190 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00191 <span class="comment"></span>
<a name="l00192"></a><a class="code" href="structbase_1_1CreateUsingMalloc.html">00192</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span><a class="code" href="structbase_1_1CreateUsingMalloc.html">CreateUsingMalloc</a>
00193     {
<a name="l00194"></a><a class="code" href="structbase_1_1CreateUsingMalloc.html#base_1_1CreateUsingMalloce0">00194</a>         <span class="keyword">static</span> T* <a class="code" href="structbase_1_1CreateUsingMalloc.html#base_1_1CreateUsingMalloce0">Create</a>()
00195         {
00196             <span class="keywordtype">void</span>* p = std::malloc(<span class="keyword">sizeof</span>(T));
00197             <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> 0;
00198             <span class="keywordflow">return</span> <span class="keyword">new</span>(p) T;
00199         }
00200         
<a name="l00201"></a><a class="code" href="structbase_1_1CreateUsingMalloc.html#base_1_1CreateUsingMalloce1">00201</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1CreateUsingMalloc.html#base_1_1CreateUsingMalloce1">Destroy</a>(T* p)
00202         {
00203             p-&gt;~T();
00204             std::free(p);
00205         }
00206     };
00207     <span class="comment"></span>
00208 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00209 <span class="comment"></span><span class="comment">// class template CreateStatic</span>
00210 <span class="comment">// Implementation of the CreationPolicy used by SingletonHolder</span>
00211 <span class="comment">// Creates an object in static memory</span>
00212 <span class="comment">// Implementation is slightly nonportable because it uses the MaxAlign trick </span>
00213 <span class="comment">//     (an union of all types to ensure proper memory alignment). This trick is </span>
00214 <span class="comment">//     nonportable in theory but highly portable in practice.</span><span class="comment"></span>
00215 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00216 <span class="comment"></span>
<a name="l00217"></a><a class="code" href="structbase_1_1CreateStatic.html">00217</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span><a class="code" href="structbase_1_1CreateStatic.html">CreateStatic</a>
00218     {
<a name="l00219"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html">00219</a>         <span class="keyword">union </span><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html">MaxAlign</a>
00220         {
<a name="l00221"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno0">00221</a>             <span class="keywordtype">char</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno0">t_</a>[<span class="keyword">sizeof</span>(T)];
<a name="l00222"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno1">00222</a>             <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno1">shortInt_</a>;
<a name="l00223"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno2">00223</a>             <span class="keywordtype">int</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno2">int_</a>;
<a name="l00224"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno3">00224</a>             <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno3">longInt_</a>;
<a name="l00225"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno4">00225</a>             <span class="keywordtype">float</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno4">float_</a>;
<a name="l00226"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno5">00226</a>             <span class="keywordtype">double</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno5">double_</a>;
<a name="l00227"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno6">00227</a>             <span class="keywordtype">long</span> <span class="keywordtype">double</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno6">longDouble_</a>;
00228             <span class="keyword">struct </span>Test;
<a name="l00229"></a><a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno7">00229</a>             <span class="keywordtype">int</span> Test::* <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html#base_1_1CreateStatic_1_1MaxAligno7">pMember_</a>;
00230             int (Test::*pMemberFn_)(<span class="keywordtype">int</span>);
00231         };
00232         
<a name="l00233"></a><a class="code" href="structbase_1_1CreateStatic.html#base_1_1CreateStatice0">00233</a>         <span class="keyword">static</span> T* <a class="code" href="structbase_1_1CreateStatic.html#base_1_1CreateStatice0">Create</a>()
00234         {
00235             <span class="keyword">static</span> <a class="code" href="unionbase_1_1CreateStatic_1_1MaxAlign.html">MaxAlign</a> staticMemory_;
00236             <span class="keywordflow">return</span> <span class="keyword">new</span>(&amp;staticMemory_) T;
00237         }
00238         
<a name="l00239"></a><a class="code" href="structbase_1_1CreateStatic.html#base_1_1CreateStatice1">00239</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1CreateStatic.html#base_1_1CreateStatice1">Destroy</a>(T* p)
00240         {
00241             p-&gt;~T();
00242         }
00243     };
00244     <span class="comment"></span>
00245 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00246 <span class="comment"></span><span class="comment">// class template DefaultLifetime</span>
00247 <span class="comment">// Implementation of the LifetimePolicy used by SingletonHolder</span>
00248 <span class="comment">// Schedules an object's destruction as per C++ rules</span>
00249 <span class="comment">// Forwards to std::atexit</span><span class="comment"></span>
00250 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00251 <span class="comment"></span>
00252     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00253"></a><a class="code" href="structbase_1_1DefaultLifetime.html">00253</a>     <span class="keyword">struct </span><a class="code" href="structbase_1_1DefaultLifetime.html">DefaultLifetime</a>
00254     {
<a name="l00255"></a><a class="code" href="structbase_1_1DefaultLifetime.html#base_1_1DefaultLifetimee0">00255</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1DefaultLifetime.html#base_1_1DefaultLifetimee0">ScheduleDestruction</a>(T*, <span class="keywordtype">void</span> (*pFun)())
00256         { std::atexit(pFun); }
00257         
<a name="l00258"></a><a class="code" href="structbase_1_1DefaultLifetime.html#base_1_1DefaultLifetimee1">00258</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1DefaultLifetime.html#base_1_1DefaultLifetimee1">OnDeadReference</a>()
00259         { <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">"Dead Reference Detected"</span>); }
00260     };
00261 <span class="comment"></span>
00262 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00263 <span class="comment"></span><span class="comment">// class template PhoenixSingleton</span>
00264 <span class="comment">// Implementation of the LifetimePolicy used by SingletonHolder</span>
00265 <span class="comment">// Schedules an object's destruction as per C++ rules, and it allows object </span>
00266 <span class="comment">//    recreation by not throwing an exception from OnDeadReference</span><span class="comment"></span>
00267 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00268 <span class="comment"></span>
00269     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00270"></a><a class="code" href="classbase_1_1PhoenixSingleton.html">00270</a>     <span class="keyword">class </span><a class="code" href="classbase_1_1PhoenixSingleton.html">PhoenixSingleton</a>
00271     {
00272     <span class="keyword">public</span>:
<a name="l00273"></a><a class="code" href="classbase_1_1PhoenixSingleton.html#base_1_1PhoenixSingletone0">00273</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1PhoenixSingleton.html#base_1_1PhoenixSingletone0">ScheduleDestruction</a>(T*, <span class="keywordtype">void</span> (*pFun)())
00274         {
00275 <span class="preprocessor">#ifndef ATEXIT_FIXED</span>
00276 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (!destroyedOnce_)
00277 <span class="preprocessor">#endif</span>
00278 <span class="preprocessor"></span>                std::atexit(pFun);
00279         }
00280         
<a name="l00281"></a><a class="code" href="classbase_1_1PhoenixSingleton.html#base_1_1PhoenixSingletone1">00281</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1PhoenixSingleton.html#base_1_1PhoenixSingletone1">OnDeadReference</a>()
00282         {
00283 <span class="preprocessor">#ifndef ATEXIT_FIXED</span>
00284 <span class="preprocessor"></span>            destroyedOnce_ = <span class="keyword">true</span>;
00285 <span class="preprocessor">#endif</span>
00286 <span class="preprocessor"></span>        }
00287         
00288     <span class="keyword">private</span>:
00289 <span class="preprocessor">#ifndef ATEXIT_FIXED</span>
00290 <span class="preprocessor"></span>        <span class="keyword">static</span> <span class="keywordtype">bool</span> destroyedOnce_;
00291 <span class="preprocessor">#endif</span>
00292 <span class="preprocessor"></span>    };
00293     
00294 <span class="preprocessor">#ifndef ATEXIT_FIXED</span>
00295 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">bool</span> PhoenixSingleton&lt;T&gt;::destroyedOnce_ = <span class="keyword">false</span>;
00296 <span class="preprocessor">#endif</span>
00297 <span class="preprocessor"></span>        <span class="comment"></span>
00298 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00299 <span class="comment"></span><span class="comment">// class template Adapter</span>
00300 <span class="comment">// Helper for SingletonWithLongevity below</span><span class="comment"></span>
00301 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00302 <span class="comment"></span>
00303     <span class="keyword">namespace </span><a class="code" href="classPrivate.html">Private</a>
00304     {
00305         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00306"></a><a class="code" href="structbase_1_1Private_1_1Adapter.html">00306</a>         <span class="keyword">struct </span><a class="code" href="structbase_1_1Private_1_1Adapter.html">Adapter</a>
00307         {
<a name="l00308"></a><a class="code" href="structbase_1_1Private_1_1Adapter.html#base_1_1Private_1_1Adaptera0">00308</a>             <span class="keywordtype">void</span> <a class="code" href="structbase_1_1Private_1_1Adapter.html#base_1_1Private_1_1Adaptera0">operator()</a>(T*) { <span class="keywordflow">return</span> <a class="code" href="structbase_1_1Private_1_1Adapter.html#base_1_1Private_1_1Adaptero0">pFun_</a>(); }
00309             void (*pFun_)();
00310         };
00311     }
00312 <span class="comment"></span>
00313 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00314 <span class="comment"></span><span class="comment">// class template SingletonWithLongevity</span>
00315 <span class="comment">// Implementation of the LifetimePolicy used by SingletonHolder</span>
00316 <span class="comment">// Schedules an object's destruction in order of their longevities</span>
00317 <span class="comment">// Assumes a visible function GetLongevity(T*) that returns the longevity of the</span>
00318 <span class="comment">//     object</span><span class="comment"></span>
00319 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00320 <span class="comment"></span>
00321     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00322"></a><a class="code" href="classbase_1_1SingletonWithLongevity.html">00322</a>     <span class="keyword">class </span><a class="code" href="classbase_1_1SingletonWithLongevity.html">SingletonWithLongevity</a>
00323     {
00324     <span class="keyword">public</span>:
<a name="l00325"></a><a class="code" href="classbase_1_1SingletonWithLongevity.html#base_1_1SingletonWithLongevitye0">00325</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1SingletonWithLongevity.html#base_1_1SingletonWithLongevitye0">ScheduleDestruction</a>(T* pObj, <span class="keywordtype">void</span> (*pFun)())
00326         {
00327             <a class="code" href="structbase_1_1Private_1_1Adapter.html">Private::Adapter&lt;T&gt;</a> adapter = { pFun };
00328             <a class="code" href="namespacebase.html#a186">SetLongevity</a>(pObj, GetLongevity(pObj), adapter);
00329         }
00330         
<a name="l00331"></a><a class="code" href="classbase_1_1SingletonWithLongevity.html#base_1_1SingletonWithLongevitye1">00331</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1SingletonWithLongevity.html#base_1_1SingletonWithLongevitye1">OnDeadReference</a>()
00332         { <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">"Dead Reference Detected"</span>); }
00333     };
00334 <span class="comment"></span>
00335 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00336 <span class="comment"></span><span class="comment">// class template NoDestroy</span>
00337 <span class="comment">// Implementation of the LifetimePolicy used by SingletonHolder</span>
00338 <span class="comment">// Never destroys the object</span><span class="comment"></span>
00339 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00340 <span class="comment"></span>
00341     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00342"></a><a class="code" href="structbase_1_1NoDestroy.html">00342</a>     <span class="keyword">struct </span><a class="code" href="structbase_1_1NoDestroy.html">NoDestroy</a>
00343     {
<a name="l00344"></a><a class="code" href="structbase_1_1NoDestroy.html#base_1_1NoDestroye0">00344</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1NoDestroy.html#base_1_1NoDestroye0">ScheduleDestruction</a>(T*, <span class="keywordtype">void</span> (*)())
00345         {}
00346         
<a name="l00347"></a><a class="code" href="structbase_1_1NoDestroy.html#base_1_1NoDestroye1">00347</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1NoDestroy.html#base_1_1NoDestroye1">OnDeadReference</a>()
00348         {}
00349     };
00350 <span class="comment"></span>
00351 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00352 <span class="comment"></span><span class="comment">// class template SingletonHolder</span>
00353 <span class="comment">// Provides Singleton amenities for a type T</span>
00354 <span class="comment">// To protect that type from spurious instantiations, you have to protect it</span>
00355 <span class="comment">//     yourself.</span><span class="comment"></span>
00356 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00357 <span class="comment"></span>
00358     <span class="keyword">template</span>
00359     &lt;
00360         <span class="keyword">typename</span> T,
00361         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>CreationPolicy = CreateUsingNew,
00362         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>LifetimePolicy = DefaultLifetime,
00363         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classThreadingModel.html">ThreadingModel</a> = SingleThreaded
00364     &gt;
<a name="l00365"></a><a class="code" href="classbase_1_1SingletonHolder.html">00365</a>     <span class="keyword">class </span><a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder</a>
00366     {
00367     <span class="keyword">public</span>:
00368         <span class="keyword">static</span> T&amp; <a class="code" href="classbase_1_1SingletonHolder.html#base_1_1SingletonHoldere0">Instance</a>();
00369         
00370     <span class="keyword">private</span>:
00371         <span class="comment">// Helpers</span>
00372         <span class="keyword">static</span> <span class="keywordtype">void</span> MakeInstance();
00373         <span class="keyword">static</span> <span class="keywordtype">void</span> DestroySingleton();
00374         
00375         <span class="comment">// Protection</span>
00376         <a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder</a>();
00377         
00378         <span class="comment">// Data</span>
00379         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classThreadingModel.html">ThreadingModel&lt;T*&gt;</a>::VolatileType <a class="code" href="classThreadingModel.html">PtrInstanceType</a>;
00380         <span class="keyword">static</span> <a class="code" href="classThreadingModel.html">PtrInstanceType</a> pInstance_;
00381         <span class="keyword">static</span> <span class="keywordtype">bool</span> destroyed_;
00382     };
00383     <span class="comment"></span>
00384 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00385 <span class="comment"></span><span class="comment">// SingletonHolder's data</span><span class="comment"></span>
00386 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00387 <span class="comment"></span>
00388     <span class="keyword">template</span>
00389     &lt;
00390         <span class="keyword">class </span>T,
00391         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>C,
00392         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>L,
00393         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>M
00394     &gt;
00395     <span class="keyword">typename</span> <a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder&lt;T, C, L, M&gt;</a>::PtrInstanceType
00396         <a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder&lt;T, C, L, M&gt;</a>::pInstance_;
00397 
00398     <span class="keyword">template</span>
00399     &lt;
00400         <span class="keyword">class </span>T,
00401         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>C,
00402         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>L,
00403         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>M
00404     &gt;
00405     <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder&lt;T, C, L, M&gt;</a>::destroyed_;
00406 <span class="comment"></span>
00407 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00408 <span class="comment"></span><span class="comment">// SingletonHolder::Instance</span><span class="comment"></span>
00409 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00410 <span class="comment"></span>
00411     <span class="keyword">template</span>
00412     &lt;
00413         <span class="keyword">class </span>T,
00414         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>CreationPolicy,
00415         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>LifetimePolicy,
00416         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classThreadingModel.html">ThreadingModel</a>
00417     &gt;
00418     <span class="keyword">inline</span> T&amp; <a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder</a>&lt;T, CreationPolicy, 
<a name="l00419"></a><a class="code" href="classbase_1_1SingletonHolder.html#base_1_1SingletonHoldere0">00419</a>         LifetimePolicy, <a class="code" href="classThreadingModel.html">ThreadingModel</a>&gt;::Instance()
00420     {
00421         <span class="keywordflow">if</span> (!pInstance_)
00422         {
00423             MakeInstance();
00424         }
00425         <span class="keywordflow">return</span> *pInstance_;
00426     }
00427 <span class="comment"></span>
00428 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00429 <span class="comment"></span><span class="comment">// SingletonHolder::MakeInstance (helper for Instance)</span><span class="comment"></span>
00430 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00431 <span class="comment"></span>
00432     <span class="keyword">template</span>
00433     &lt;
00434         <span class="keyword">class </span>T,
00435         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>CreationPolicy,
00436         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>LifetimePolicy,
00437         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classThreadingModel.html">ThreadingModel</a>
00438     &gt;
00439     <span class="keywordtype">void</span> <a class="code" href="classbase_1_1SingletonHolder.html">SingletonHolder</a>&lt;T, CreationPolicy, 
00440         LifetimePolicy, <a class="code" href="classThreadingModel.html">ThreadingModel</a>&gt;::MakeInstance()
00441     {
00442         <span class="keyword">typename</span> <a class="code" href="classThreadingModel.html">ThreadingModel&lt;T&gt;</a>::Lock guard;
00443         (<span class="keywordtype">void</span>)guard;
00444         
00445         <span class="keywordflow">if</span> (!pInstance_)
00446         {
00447             <span class="keywordflow">if</span> (destroyed_)
00448             {
00449                 LifetimePolicy&lt;T&gt;::OnDeadReference();
00450                 destroyed_ = <span class="keyword">false</span>;
00451             }
00452             pInstance_ = CreationPolicy&lt;T&gt;::Create();
00453             LifetimePolicy&lt;T&gt;::ScheduleDestruction(pInstance_, 
00454                 &amp;DestroySingleton);
00455         }
00456     }
00457 
00458     <span class="keyword">template</span>
00459     &lt;
00460         <span class="keyword">class </span>T,
00461         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>CreationPolicy,
00462         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>L,
00463         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="general_8h.html#a54">M</a>
00464     &gt;
00465     <span class="keywordtype">void</span> SingletonHolder&lt;T, CreationPolicy, L, M&gt;::DestroySingleton()
00466     {
00467         assert(!destroyed_);
00468         CreationPolicy&lt;T&gt;::Destroy(pInstance_);
00469         pInstance_ = 0;
00470         destroyed_ = <span class="keyword">true</span>;
00471     }
00472 } <span class="comment">// namespace base</span>
00473 <span class="comment"></span>
00474 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00475 <span class="comment"></span><span class="comment">// Change log:</span>
00476 <span class="comment">// May 21, 2001: Correct the volatile qualifier - credit due to Darin Adler</span>
00477 <span class="comment">// June 20, 2001: ported by Nick Thurn to gcc 2.95.3. Kudos, Nick!!!</span>
00478 <span class="comment">// Feb 25, 2002: David Jung: integrated into larger project - changed to </span>
00479 <span class="comment">//                namespace base and changed header comments to reflect GPL</span>
00480 <span class="comment">//                distribution</span><span class="comment"></span>
00481 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00482 <span class="comment"></span>
00483 <span class="preprocessor">#endif // SINGLETON_INC_</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:14 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
