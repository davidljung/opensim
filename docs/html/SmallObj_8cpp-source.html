<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/SmallObj.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/SmallObj.cpp</h1><a href="SmallObj_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2001 by Andrei Alexandrescu</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This file is a derivative of a file from the Loki Library written by</span>
00005 <span class="comment">  Andrei Alexandrescu.  It was distributed by him under the terms</span>
00006 <span class="comment">  listed below (titled Loki Original Distribution Terms).</span>
00007 <span class="comment">  In accordance with the terms, this distribution contains the copyright</span>
00008 <span class="comment">  notice here and the copyright notice and permission notice</span>
00009 <span class="comment">  in supporting documentation.  The terms do *not* require</span>
00010 <span class="comment">  redistribution under those same terms.  This code is distributed</span>
00011 <span class="comment">  to you under the terms of the GNU General Public License (GPL) </span>
00012 <span class="comment">  below.  The GPL does not require you to maintain the terms of</span>
00013 <span class="comment">  the Loki Original Distribution Terms, but you are encouraged to do so.</span>
00014 <span class="comment"></span>
00015 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00016 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00017 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00018 <span class="comment">  (at your option) any later version.</span>
00019 <span class="comment">  </span>
00020 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00021 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00022 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00023 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00024 <span class="comment">  </span>
00025 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00026 <span class="comment">  along with this program; if not, write to the Free Software</span>
00027 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00028 <span class="comment">  </span>
00029 <span class="comment"> ****************************************************************************</span>
00030 <span class="comment">  Loki Original Distribution Terms:</span>
00031 <span class="comment"></span>
00032 <span class="comment">  The Loki Library</span>
00033 <span class="comment">  Copyright (c) 2001 by Andrei Alexandrescu</span>
00034 <span class="comment">  This code accompanies the book:</span>
00035 <span class="comment">  Alexandrescu, Andrei. "Modern C++ Design: Generic Programming and Design </span>
00036 <span class="comment">      Patterns Applied". Copyright (c) 2001. Addison-Wesley.</span>
00037 <span class="comment">  Permission to use, copy, modify, distribute and sell this software for any </span>
00038 <span class="comment">      purpose is hereby granted without fee, provided that the above copyright </span>
00039 <span class="comment">      notice appear in all copies and that both that copyright notice and this </span>
00040 <span class="comment">      permission notice appear in supporting documentation.</span>
00041 <span class="comment">  The author or Addison-Welsey Longman make no representations about the </span>
00042 <span class="comment">      suitability of this software for any purpose. It is provided "as is" </span>
00043 <span class="comment">      without express or implied warranty.</span>
00044 <span class="comment"> ****************************************************************************</span>
00045 <span class="comment"></span>
00046 <span class="comment">  $Id: SmallObj.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00047 <span class="comment">  $Revision: 1.1 $</span>
00048 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00049 <span class="comment">  $Author: jungd $</span>
00050 <span class="comment"> </span>
00051 <span class="comment">****************************************************************************/</span>
00052 
00053 <span class="comment">// Last update: March 20, 2001</span>
00054 
00055 <span class="preprocessor">#include &lt;<a class="code" href="SmallObj.html">base/SmallObj</a>&gt;</span>
00056 <span class="preprocessor">#include &lt;cassert&gt;</span>
00057 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00058 <span class="preprocessor">#include &lt;iostream&gt;</span>
00059 
00060 <span class="preprocessor">#include &lt;<a class="code" href="MemoryTracer.html">base/MemoryTracer</a>&gt;</span>
00061 
00062 <span class="keyword">using</span> <span class="keyword">namespace </span><a class="code" href="base_2Jamfile_8ft.html#a0">base</a>;
00063 <span class="comment"></span>
00064 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00065 <span class="comment"></span><span class="comment">// FixedAllocator::Chunk::Init</span>
00066 <span class="comment">// Initializes a chunk object</span><span class="comment"></span>
00067 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00068 <span class="comment"></span>
00069 <span class="keywordtype">void</span> FixedAllocator::Chunk::Init(std::size_t blockSize, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> blocks)
00070 {
00071     assert(blockSize &gt; 0);
00072     assert(blocks &gt; 0);
00073     <span class="comment">// Overflow check</span>
00074     assert((blockSize * blocks) / blockSize == blocks);
00075     
00076     pData_ = <a class="code" href="MemoryTracer.html#a1">NewNamedObj</a>(<span class="stringliteral">"FixedAllocator::pData"</span>) <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[blockSize * blocks];
00077 
00078     <a class="code" href="namespacebase.html#a164">Reset</a>(blockSize, blocks);
00079 }
00080 <span class="comment"></span>
00081 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00082 <span class="comment"></span><span class="comment">// FixedAllocator::Chunk::Reset</span>
00083 <span class="comment">// Clears an already allocated chunk</span><span class="comment"></span>
00084 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00085 <span class="comment"></span>
00086 <span class="keywordtype">void</span> FixedAllocator::Chunk::Reset(std::size_t blockSize, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> blocks)
00087 {
00088     assert(blockSize &gt; 0);
00089     assert(blocks &gt; 0);
00090     <span class="comment">// Overflow check</span>
00091     assert((blockSize * blocks) / blockSize == blocks);
00092 
00093     firstAvailableBlock_ = 0;
00094     blocksAvailable_ = blocks;
00095 
00096     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i = 0;
00097     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* p = pData_;
00098     <span class="keywordflow">for</span> (; i != blocks; p += blockSize)
00099     {
00100         *p = ++i;
00101     }
00102 }
00103 <span class="comment"></span>
00104 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00105 <span class="comment"></span><span class="comment">// FixedAllocator::Chunk::Release</span>
00106 <span class="comment">// Releases the data managed by a chunk</span><span class="comment"></span>
00107 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00108 <span class="comment"></span>
00109 <span class="keywordtype">void</span> FixedAllocator::Chunk::Release()
00110 {
00111     <span class="keyword">delete</span>[] pData_;
00112 }
00113 <span class="comment"></span>
00114 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00115 <span class="comment"></span><span class="comment">// FixedAllocator::Chunk::Allocate</span>
00116 <span class="comment">// Allocates a block from a chunk</span><span class="comment"></span>
00117 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00118 <span class="comment"></span>
00119 <span class="keywordtype">void</span>* <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora5">FixedAllocator::Chunk::Allocate</a>(std::size_t blockSize)
00120 {
00121     <span class="keywordflow">if</span> (!blocksAvailable_) <span class="keywordflow">return</span> 0;
00122     
00123     assert((firstAvailableBlock_ * blockSize) / blockSize == 
00124         firstAvailableBlock_);
00125 
00126     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pResult =
00127         pData_ + (firstAvailableBlock_ * blockSize);
00128     firstAvailableBlock_ = *pResult;
00129     --blocksAvailable_;
00130     
00131     <span class="keywordflow">return</span> pResult;
00132 }
00133 <span class="comment"></span>
00134 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00135 <span class="comment"></span><span class="comment">// FixedAllocator::Chunk::Deallocate</span>
00136 <span class="comment">// Dellocates a block from a chunk</span><span class="comment"></span>
00137 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00138 <span class="comment"></span>
00139 <span class="keywordtype">void</span> <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora6">FixedAllocator::Chunk::Deallocate</a>(<span class="keywordtype">void</span>* p, std::size_t blockSize)
00140 {
00141     assert(p &gt;= pData_);
00142 
00143     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* toRelease = static_cast&lt;unsigned char*&gt;(p);
00144     <span class="comment">// Alignment check</span>
00145     assert((toRelease - pData_) % blockSize == 0);
00146 
00147     *toRelease = firstAvailableBlock_;
00148     firstAvailableBlock_ = static_cast&lt;unsigned char&gt;(
00149         (toRelease - pData_) / blockSize);
00150     <span class="comment">// Truncation check</span>
00151     assert(firstAvailableBlock_ == (toRelease - pData_) / blockSize);
00152 
00153     ++blocksAvailable_;
00154 }
00155 <span class="comment"></span>
00156 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00157 <span class="comment"></span><span class="comment">// FixedAllocator::FixedAllocator</span>
00158 <span class="comment">// Creates a FixedAllocator object of a fixed block size</span><span class="comment"></span>
00159 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00160 <span class="comment"></span>
<a name="l00161"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora0">00161</a> <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora0">FixedAllocator::FixedAllocator</a>(std::size_t blockSize)
00162     : blockSize_(blockSize)
00163     , allocChunk_(0)
00164     , deallocChunk_(0)
00165 {
00166     assert(blockSize_ &gt; 0);
00167     
00168     prev_ = next_ = <span class="keyword">this</span>;
00169 
00170     std::size_t <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> = <a class="code" href="SmallObj.html#a0">DEFAULT_CHUNK_SIZE</a> / blockSize;
00171     <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> &gt; UCHAR_MAX) <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> = UCHAR_MAX;
00172     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> == 0) <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> = 8 * blockSize;
00173     
00174     numBlocks_ = static_cast&lt;unsigned char&gt;(<a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a>);
00175     assert(numBlocks_ == <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a>);
00176 }
00177 <span class="comment"></span>
00178 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00179 <span class="comment"></span><span class="comment">// FixedAllocator::FixedAllocator(const FixedAllocator&amp;)</span>
00180 <span class="comment">// Creates a FixedAllocator object of a fixed block size</span><span class="comment"></span>
00181 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00182 <span class="comment"></span>
<a name="l00183"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora1">00183</a> <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora0">FixedAllocator::FixedAllocator</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1FixedAllocator.html">FixedAllocator</a>&amp; rhs)
00184     : blockSize_(rhs.blockSize_)
00185     , numBlocks_(rhs.numBlocks_)
00186     , chunks_(rhs.chunks_)
00187 {
00188     prev_ = &amp;rhs;
00189     next_ = rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr6">next_</a>;
00190     rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr6">next_</a>-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr5">prev_</a> = <span class="keyword">this</span>;
00191     rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr6">next_</a> = <span class="keyword">this</span>;
00192     
00193     allocChunk_ = rhs.allocChunk_
00194         ? &amp;chunks_.front() + (rhs.allocChunk_ - &amp;rhs.chunks_.front())
00195         : 0;
00196 
00197     deallocChunk_ = rhs.deallocChunk_
00198         ? &amp;chunks_.front() + (rhs.deallocChunk_ - &amp;rhs.chunks_.front())
00199         : 0;
00200 }
00201 
<a name="l00202"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora2">00202</a> <a class="code" href="classbase_1_1FixedAllocator.html">FixedAllocator</a>&amp; <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora2">FixedAllocator::operator=</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1FixedAllocator.html">FixedAllocator</a>&amp; rhs)
00203 {
00204     <a class="code" href="classbase_1_1FixedAllocator.html">FixedAllocator</a> copy(rhs);
00205     copy.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora4">Swap</a>(*<span class="keyword">this</span>);
00206     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00207 }
00208 <span class="comment"></span>
00209 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00210 <span class="comment"></span><span class="comment">// FixedAllocator::~FixedAllocator</span><span class="comment"></span>
00211 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00212 <span class="comment"></span>
<a name="l00213"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora3">00213</a> <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora3">FixedAllocator::~FixedAllocator</a>()
00214 {
00215     <span class="keywordflow">if</span> (prev_ != <span class="keyword">this</span>)
00216     {
00217         prev_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr6">next_</a> = next_;
00218         next_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr5">prev_</a> = prev_;
00219         <span class="keywordflow">return</span>;
00220     }
00221     
00222     assert(prev_ == next_);
00223     <span class="keywordtype">int</span> allocatedBlocks = 0;
00224     Chunks::iterator i = chunks_.begin();
00225     <span class="keywordflow">for</span> (; i != chunks_.end(); ++i)
00226     {
00227       allocatedBlocks += (numBlocks_ - i-&gt;blocksAvailable_);
00228 
00229       <span class="comment">//assert(i-&gt;blocksAvailable_ == numBlocks_);</span>
00230       i-&gt;Release();
00231     }
00232     
00233     <span class="keywordflow">if</span> (allocatedBlocks &gt; 0)
00234       fprintf(stderr,<span class="stringliteral">"SmallObj/FixedAllocator::~FixedAllocator - Warning: %d objects (of size %d) left allocated on allocator destruction.\n"</span>,allocatedBlocks,blockSize_);
00235 }
00236 <span class="comment"></span>
00237 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00238 <span class="comment"></span><span class="comment">// FixedAllocator::Swap</span><span class="comment"></span>
00239 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00240 <span class="comment"></span>
<a name="l00241"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora4">00241</a> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora4">FixedAllocator::Swap</a>(<a class="code" href="classbase_1_1FixedAllocator.html">FixedAllocator</a>&amp; rhs)
00242 {
00243     <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00244     
00245     <a class="code" href="namespacebase.html#a46">swap</a>(blockSize_, rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr0">blockSize_</a>);
00246     <a class="code" href="namespacebase.html#a46">swap</a>(numBlocks_, rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr1">numBlocks_</a>);
00247     chunks_.swap(rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr2">chunks_</a>);
00248     <a class="code" href="namespacebase.html#a46">swap</a>(allocChunk_, rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr3">allocChunk_</a>);
00249     <a class="code" href="namespacebase.html#a46">swap</a>(deallocChunk_, rhs.<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatorr4">deallocChunk_</a>);
00250 }
00251 <span class="comment"></span>
00252 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00253 <span class="comment"></span><span class="comment">// FixedAllocator::Allocate</span>
00254 <span class="comment">// Allocates a block of fixed size</span><span class="comment"></span>
00255 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00256 <span class="comment"></span>
<a name="l00257"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora5">00257</a> <span class="keywordtype">void</span>* <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora5">FixedAllocator::Allocate</a>()
00258 {
00259     <span class="keywordflow">if</span> (allocChunk_ == 0 || allocChunk_-&gt;blocksAvailable_ == 0)
00260     {
00261         Chunks::iterator i = chunks_.begin();
00262         <span class="keywordflow">for</span> (;; ++i)
00263         {
00264             <span class="keywordflow">if</span> (i == chunks_.end())
00265             {
00266                 <span class="comment">// Initialize</span>
00267                 chunks_.reserve(chunks_.size() + 1);
00268                 Chunk newChunk;
00269                 newChunk.Init(blockSize_, numBlocks_);
00270                 chunks_.push_back(newChunk);
00271                 allocChunk_ = &amp;chunks_.back();
00272                 deallocChunk_ = &amp;chunks_.front();
00273                 <span class="keywordflow">break</span>;
00274             }
00275             <span class="keywordflow">if</span> (i-&gt;blocksAvailable_ &gt; 0)
00276             {
00277                 allocChunk_ = &amp;*i;
00278                 <span class="keywordflow">break</span>;
00279             }
00280         }
00281     }
00282     assert(allocChunk_ != 0);
00283     assert(allocChunk_-&gt;blocksAvailable_ &gt; 0);
00284     
00285     <span class="keywordflow">return</span> allocChunk_-&gt;Allocate(blockSize_);
00286 }
00287 <span class="comment"></span>
00288 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00289 <span class="comment"></span><span class="comment">// FixedAllocator::Deallocate</span>
00290 <span class="comment">// Deallocates a block previously allocated with Allocate</span>
00291 <span class="comment">// (undefined behavior if called with the wrong pointer)</span><span class="comment"></span>
00292 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00293 <span class="comment"></span>
<a name="l00294"></a><a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora6">00294</a> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora6">FixedAllocator::Deallocate</a>(<span class="keywordtype">void</span>* p)
00295 {
00296     assert(!chunks_.empty());
00297     assert(&amp;chunks_.front() &lt;= deallocChunk_);
00298     assert(&amp;chunks_.back() &gt;= deallocChunk_);
00299     
00300     deallocChunk_  = VicinityFind(p);
00301     assert(deallocChunk_);
00302 
00303     DoDeallocate(p);
00304 }
00305 <span class="comment"></span>
00306 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00307 <span class="comment"></span><span class="comment">// FixedAllocator::VicinityFind (internal)</span>
00308 <span class="comment">// Finds the chunk corresponding to a pointer, using an efficient search</span><span class="comment"></span>
00309 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00310 <span class="comment"></span>
00311 FixedAllocator::Chunk* FixedAllocator::VicinityFind(<span class="keywordtype">void</span>* p)
00312 {
00313     assert(!chunks_.empty());
00314     assert(deallocChunk_);
00315 
00316     <span class="keyword">const</span> std::size_t chunkLength = numBlocks_ * blockSize_;
00317 
00318     Chunk* lo = deallocChunk_;
00319     Chunk* hi = deallocChunk_ + 1;
00320     Chunk* loBound = &amp;chunks_.front();
00321     Chunk* hiBound = &amp;chunks_.back() + 1;
00322 
00323     <span class="keywordflow">for</span> (;;)
00324     {
00325         <span class="keywordflow">if</span> (lo)
00326         {
00327             <span class="keywordflow">if</span> (p &gt;= lo-&gt;pData_ &amp;&amp; p &lt; lo-&gt;pData_ + chunkLength)
00328             {
00329                 <span class="keywordflow">return</span> lo;
00330             }
00331             <span class="keywordflow">if</span> (lo == loBound) lo = 0;
00332             <span class="keywordflow">else</span> --lo;
00333         }
00334         
00335         <span class="keywordflow">if</span> (hi)
00336         {
00337             <span class="keywordflow">if</span> (p &gt;= hi-&gt;pData_ &amp;&amp; p &lt; hi-&gt;pData_ + chunkLength)
00338             {
00339                 <span class="keywordflow">return</span> hi;
00340             }
00341             <span class="keywordflow">if</span> (++hi == hiBound) hi = 0;
00342         }
00343     }
00344     assert(<span class="keyword">false</span>);
00345     <span class="keywordflow">return</span> 0;
00346 }
00347 <span class="comment"></span>
00348 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00349 <span class="comment"></span><span class="comment">// FixedAllocator::DoDeallocate (internal)</span>
00350 <span class="comment">// Performs deallocation. Assumes deallocChunk_ points to the correct chunk</span><span class="comment"></span>
00351 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00352 <span class="comment"></span>
00353 <span class="keywordtype">void</span> FixedAllocator::DoDeallocate(<span class="keywordtype">void</span>* p)
00354 {
00355     assert(deallocChunk_-&gt;pData_ &lt;= p);
00356     assert(deallocChunk_-&gt;pData_ + numBlocks_ * blockSize_ &gt; p);
00357 
00358     <span class="comment">// call into the chunk, will adjust the inner list but won't release memory</span>
00359     deallocChunk_-&gt;Deallocate(p, blockSize_);
00360 
00361     <span class="keywordflow">if</span> (deallocChunk_-&gt;blocksAvailable_ == numBlocks_)
00362     {
00363         <span class="comment">// deallocChunk_ is completely free, should we release it? </span>
00364         
00365         Chunk&amp; lastChunk = chunks_.back();
00366         
00367         <span class="keywordflow">if</span> (&amp;lastChunk == deallocChunk_)
00368         {
00369             <span class="comment">// check if we have two last chunks empty</span>
00370             
00371             <span class="keywordflow">if</span> (chunks_.size() &gt; 1 &amp;&amp; 
00372                 deallocChunk_[-1].blocksAvailable_ == numBlocks_)
00373             {
00374                 <span class="comment">// Two free chunks, discard the last one</span>
00375                 lastChunk.Release();
00376                 chunks_.pop_back();
00377                 allocChunk_ = deallocChunk_ = &amp;chunks_.front();
00378             }
00379             <span class="keywordflow">return</span>;
00380         }
00381         
00382         <span class="keywordflow">if</span> (lastChunk.blocksAvailable_ == numBlocks_)
00383         {
00384             <span class="comment">// Two free blocks, discard one</span>
00385             lastChunk.Release();
00386             chunks_.pop_back();
00387             allocChunk_ = deallocChunk_;
00388         }
00389         <span class="keywordflow">else</span>
00390         {
00391             <span class="comment">// move the empty chunk to the end</span>
00392             std::swap(*deallocChunk_, lastChunk);
00393             allocChunk_ = &amp;chunks_.back();
00394         }
00395     }
00396 }
00397 <span class="comment"></span>
00398 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00399 <span class="comment"></span><span class="comment">// SmallObjAllocator::SmallObjAllocator</span>
00400 <span class="comment">// Creates an allocator for small objects given chunk size and maximum 'small'</span>
00401 <span class="comment">//     object size</span><span class="comment"></span>
00402 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00403 <span class="comment"></span>
<a name="l00404"></a><a class="code" href="classbase_1_1SmallObjAllocator.html#base_1_1SmallObjAllocatora0">00404</a> <a class="code" href="classbase_1_1SmallObjAllocator.html#base_1_1SmallObjAllocatora0">SmallObjAllocator::SmallObjAllocator</a>(
00405         std::size_t chunkSize, 
00406         std::size_t maxObjectSize)
00407     : pLastAlloc_(0), pLastDealloc_(0)
00408     , chunkSize_(chunkSize), maxObjectSize_(maxObjectSize) 
00409 {   
00410 }
00411 <span class="comment"></span>
00412 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00413 <span class="comment"></span><span class="comment">// SmallObjAllocator::Allocate</span>
00414 <span class="comment">// Allocates 'numBytes' memory</span>
00415 <span class="comment">// Uses an internal pool of FixedAllocator objects for small objects  </span><span class="comment"></span>
00416 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00417 <span class="comment"></span>
<a name="l00418"></a><a class="code" href="classbase_1_1SmallObjAllocator.html#base_1_1SmallObject_1_1MySmallObjAllocatora1">00418</a> <span class="keywordtype">void</span>* <a class="code" href="classbase_1_1SmallObjAllocator.html#base_1_1SmallObject_1_1MySmallObjAllocatora1">SmallObjAllocator::Allocate</a>(std::size_t numBytes)
00419 {
00420     <span class="keywordflow">if</span> (numBytes &gt; maxObjectSize_) <span class="keywordflow">return</span> <a class="code" href="MemoryTracer.html#a3">operator new</a>(numBytes,<span class="stringliteral">"SmallObjAllocator::Allocate"</span>);
00421 
00422     <span class="keywordflow">if</span> (pLastAlloc_ &amp;&amp; pLastAlloc_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora7">BlockSize</a>() == numBytes)
00423     {
00424         <span class="keywordflow">return</span> pLastAlloc_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora5">Allocate</a>();
00425     }
00426     
00427     Pool::iterator i = std::lower_bound(pool_.begin(), pool_.end(), numBytes);
00428     <span class="keywordflow">if</span> (i == pool_.end() || i-&gt;BlockSize() != numBytes)
00429     {
00430         i = pool_.insert(i, <a class="code" href="classbase_1_1FixedAllocator.html">FixedAllocator</a>(numBytes));
00431         pLastDealloc_ = &amp;*pool_.begin();
00432     }
00433     pLastAlloc_ = &amp;*i;
00434     <span class="keywordflow">return</span> pLastAlloc_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora5">Allocate</a>();
00435 }
00436 <span class="comment"></span>
00437 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00438 <span class="comment"></span><span class="comment">// SmallObjAllocator::Deallocate</span>
00439 <span class="comment">// Deallocates memory previously allocated with Allocate</span>
00440 <span class="comment">// (undefined behavior if you pass any other pointer)</span><span class="comment"></span>
00441 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00442 <span class="comment"></span>
<a name="l00443"></a><a class="code" href="classbase_1_1SmallObjAllocator.html#base_1_1SmallObject_1_1MySmallObjAllocatora2">00443</a> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1SmallObjAllocator.html#base_1_1SmallObject_1_1MySmallObjAllocatora2">SmallObjAllocator::Deallocate</a>(<span class="keywordtype">void</span>* p, std::size_t numBytes)
00444 {
00445     <span class="keywordflow">if</span> (numBytes &gt; maxObjectSize_) <span class="keywordflow">return</span> operator delete(p);
00446 
00447     <span class="keywordflow">if</span> (pLastDealloc_ &amp;&amp; pLastDealloc_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora7">BlockSize</a>() == numBytes)
00448     {
00449         pLastDealloc_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora6">Deallocate</a>(p);
00450         <span class="keywordflow">return</span>;
00451     }
00452 
00453     Pool::iterator i = std::lower_bound(pool_.begin(), pool_.end(), numBytes);
00454     assert(i != pool_.end());
00455     assert(i-&gt;BlockSize() == numBytes);
00456     pLastDealloc_ = &amp;*i;
00457     pLastDealloc_-&gt;<a class="code" href="classbase_1_1FixedAllocator.html#base_1_1FixedAllocatora6">Deallocate</a>(p);
00458 }
00459 <span class="comment"></span>
00460 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00461 <span class="comment"></span><span class="comment">// Change log:</span>
00462 <span class="comment">// March 20: fix exception safety issue in FixedAllocator::Allocate </span>
00463 <span class="comment">//     (thanks to Chris Udazvinis for pointing that out)</span>
00464 <span class="comment">// June 20, 2001: ported by Nick Thurn to gcc 2.95.3. Kudos, Nick!!!</span>
00465 <span class="comment">// Feb 25, 2002: David Jung: integrated into larger project - changed to </span>
00466 <span class="comment">//                namespace base and changed header comments to reflect GPL</span>
00467 <span class="comment">//                distribution</span><span class="comment"></span>
00468 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
</span></pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:15 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
