<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/ref.full Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/ref.full</h1><a href="ref_8full.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2001 by Andrei Alexandrescu</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This file is a derivative of a file from the Loki Library written by</span>
00005 <span class="comment">  Andrei Alexandrescu.  It was distributed by him under the terms</span>
00006 <span class="comment">  listed below (titled Loki Original Distribution Terms).</span>
00007 <span class="comment">  In accordance with the terms, this distribution contains the copyright</span>
00008 <span class="comment">  notice here and the copyright notice and permission notice</span>
00009 <span class="comment">  in supporting documentation.  The terms do *not* require</span>
00010 <span class="comment">  redistribution under those same terms.  This code is distributed</span>
00011 <span class="comment">  to you under the terms of the GNU General Public License (GPL) </span>
00012 <span class="comment">  below.  The GPL does not require you to maintain the terms of</span>
00013 <span class="comment">  the Loki Original Distribution Terms, but you are encouraged to do so.</span>
00014 <span class="comment"></span>
00015 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00016 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00017 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00018 <span class="comment">  (at your option) any later version.</span>
00019 <span class="comment">  </span>
00020 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00021 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00022 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00023 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00024 <span class="comment">  </span>
00025 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00026 <span class="comment">  along with this program; if not, write to the Free Software</span>
00027 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00028 <span class="comment">  </span>
00029 <span class="comment"> ****************************************************************************</span>
00030 <span class="comment">  Loki Original Distribution Terms:</span>
00031 <span class="comment"></span>
00032 <span class="comment">  The Loki Library</span>
00033 <span class="comment">  Copyright (c) 2001 by Andrei Alexandrescu</span>
00034 <span class="comment">  This code accompanies the book:</span>
00035 <span class="comment">  Alexandrescu, Andrei. "Modern C++ Design: Generic Programming and Design </span>
00036 <span class="comment">      Patterns Applied". Copyright (c) 2001. Addison-Wesley.</span>
00037 <span class="comment">  Permission to use, copy, modify, distribute and sell this software for any </span>
00038 <span class="comment">      purpose is hereby granted without fee, provided that the above copyright </span>
00039 <span class="comment">      notice appear in all copies and that both that copyright notice and this </span>
00040 <span class="comment">      permission notice appear in supporting documentation.</span>
00041 <span class="comment">  The author or Addison-Welsey Longman make no representations about the </span>
00042 <span class="comment">      suitability of this software for any purpose. It is provided "as is" </span>
00043 <span class="comment">      without express or implied warranty.</span>
00044 <span class="comment"> ****************************************************************************</span>
00045 <span class="comment"></span>
00046 <span class="comment">  $Id: ref.full 1029 2004-02-11 20:45:54Z jungd $</span>
00047 <span class="comment">  $Revision: 1.1 $</span>
00048 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00049 <span class="comment">  $Author: jungd $</span>
00050 <span class="comment"> </span>
00051 <span class="comment">****************************************************************************/</span>
00052 
00053 <span class="comment">// Last update: June 20, 2001</span>
00054 
00055 <span class="preprocessor">#ifndef SMARTPTR_INC_</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define SMARTPTR_INC_</span>
00057 <span class="preprocessor"></span><span class="comment"></span>
00058 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00059 <span class="comment"></span><span class="comment">// IMPORTANT NOTE</span>
00060 <span class="comment">// Due to threading issues, the OwnershipPolicy has been changed as follows:</span>
00061 <span class="comment">//     Release() returns a boolean saying if that was the last release</span>
00062 <span class="comment">//        so the pointer can be deleted by the StoragePolicy</span>
00063 <span class="comment">//     IsUnique() was removed</span><span class="comment"></span>
00064 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00065 <span class="comment"></span>
00066 
00067 <span class="preprocessor">#include &lt;<a class="code" href="SmallObj.html">base/SmallObj</a>&gt;</span>
00068 <span class="preprocessor">#include &lt;<a class="code" href="TypeManip.html">base/TypeManip</a>&gt;</span>
00069 <span class="preprocessor">#include &lt;<a class="code" href="NullType.html">base/NullType</a>&gt;</span>
00070 <span class="preprocessor">#include &lt;<a class="code" href="static__check.html">base/static_check</a>&gt;</span>
00071 <span class="preprocessor">#include &lt;functional&gt;</span>
00072 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00073 
00074 <span class="keyword">namespace </span><a class="code" href="base_2Jamfile_8ft.html#a0">base</a>
00075 {
00076 <span class="comment"></span>
00077 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00078 <span class="comment"></span><span class="comment">// class template DefaultSPStorage</span>
00079 <span class="comment">// Implementation of the StoragePolicy used by ref</span><span class="comment"></span>
00080 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00081 <span class="comment"></span>
00082     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00083     <span class="keyword">class </span>DefaultSPStorage
00084     {
00085     <span class="keyword">public</span>:
<a name="l00086"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew3">00086</a>         <span class="keyword">typedef</span> T* <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew0">StoredType</a>;    <span class="comment">// the type of the pointee_ object</span>
<a name="l00087"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew4">00087</a>         <span class="keyword">typedef</span> T* <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew1">PointerType</a>;   <span class="comment">// type returned by operator-&gt;</span>
<a name="l00088"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew5">00088</a>         <span class="keyword">typedef</span> T&amp; <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew2">ReferenceType</a>; <span class="comment">// type returned by operator*</span>
00089         
<a name="l00090"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea7">00090</a>         <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea0">DefaultSPStorage</a>() : pointee_(<a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragee0">Default</a>()) 
00091         {}
00092 
00093         <span class="comment">// The storage policy doesn't initialize the stored pointer </span>
00094         <span class="comment">//     which will be initialized by the OwnershipPolicy's Clone fn</span>
<a name="l00095"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea8">00095</a>         <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea0">DefaultSPStorage</a>(<span class="keyword">const</span> <a class="code" href="classDefaultSPStorage.html">DefaultSPStorage</a>&amp;)
00096         {}
00097 
00098         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00099"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea9">00099</a>         <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea0">DefaultSPStorage</a>(<span class="keyword">const</span> <a class="code" href="classDefaultSPStorage.html">DefaultSPStorage&lt;U&gt;</a>&amp;) 
00100         {}
00101         
<a name="l00102"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea10">00102</a>         <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea0">DefaultSPStorage</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew0">StoredType</a>&amp; p) : pointee_(p) {}
00103         
<a name="l00104"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea11">00104</a>         <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew1">PointerType</a> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea4">operator-&gt;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pointee_; }
00105         
<a name="l00106"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea12">00106</a>         <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew2">ReferenceType</a> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea5">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *pointee_; }
00107         
<a name="l00108"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea13">00108</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragea6">Swap</a>(<a class="code" href="classDefaultSPStorage.html">DefaultSPStorage</a>&amp; rhs)
00109         { std::swap(pointee_, rhs.pointee_); }
00110     
00111         <span class="comment">// Accessors</span>
<a name="l00112"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragen3">00112</a>         <span class="keyword">friend</span> <span class="keyword">inline</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew1">PointerType</a> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragen0">GetImpl</a>(<span class="keyword">const</span> <a class="code" href="classDefaultSPStorage.html">DefaultSPStorage</a>&amp; sp)
00113         { <span class="keywordflow">return</span> sp.pointee_; }
00114         
<a name="l00115"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragen4">00115</a>         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew0">StoredType</a>&amp; <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragen1">GetImplRef</a>(<span class="keyword">const</span> <a class="code" href="classDefaultSPStorage.html">DefaultSPStorage</a>&amp; sp)
00116         { <span class="keywordflow">return</span> sp.pointee_; }
00117 
<a name="l00118"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragen5">00118</a>         <span class="keyword">friend</span> <span class="keyword">inline</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew0">StoredType</a>&amp; <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragen1">GetImplRef</a>(<a class="code" href="classDefaultSPStorage.html">DefaultSPStorage</a>&amp; sp)
00119         { <span class="keywordflow">return</span> sp.pointee_; }
00120 
00121         <span class="comment">// Default value to initialize the pointer</span>
<a name="l00122"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragee1">00122</a>         <span class="keyword">static</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragew0">StoredType</a> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStoragee0">Default</a>()
00123         { <span class="keywordflow">return</span> 0; }
00124 
00125     <span class="keyword">protected</span>:
00126         <span class="comment">// Destroys the data stored</span>
00127         <span class="comment">// (Destruction might be taken over by the OwnershipPolicy)</span>
<a name="l00128"></a><a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStorageb1">00128</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1DefaultSPStorage.html#base_1_1DefaultSPStorageb0">Destroy</a>()
00129         { <span class="keyword">delete</span> pointee_; }
00130     
00131     <span class="keyword">private</span>:
00132         <span class="comment">// Data</span>
00133         StoredType pointee_;
00134     };
00135 <span class="comment"></span>
00136 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00137 <span class="comment"></span><span class="comment">// class template RefCounted</span>
00138 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00139 <span class="comment">// Provides a classic external reference counting implementation</span><span class="comment"></span>
00140 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00141 <span class="comment"></span>
00142     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00143     <span class="keyword">class </span>RefCounted
00144     {
00145     <span class="keyword">public</span>:
<a name="l00146"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda7">00146</a>         <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda0">RefCounted</a>() 
00147         {
00148             pCount_ = static_cast&lt;unsigned int*&gt;(
00149                 <a class="code" href="MemoryTracer.html#a3">SmallObject&lt;&gt;::operator new</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)));
00150             assert(pCount_);
00151             *pCount_ = 1;
00152         }
00153         
<a name="l00154"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda8">00154</a>         <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda0">RefCounted</a>(<span class="keyword">const</span> <a class="code" href="classRefCounted.html">RefCounted</a>&amp; rhs) 
00155         : pCount_(rhs.pCount_)
00156         {}
00157         
00158         <span class="comment">// MWCW lacks template friends, hence the following kludge</span>
00159         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1&gt;
<a name="l00160"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda9">00160</a>         <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda0">RefCounted</a>(<span class="keyword">const</span> <a class="code" href="classRefCounted.html">RefCounted&lt;P1&gt;</a>&amp; rhs) 
00161         : pCount_(reinterpret_cast&lt;const <a class="code" href="classRefCounted.html">RefCounted</a>&amp;&gt;(rhs).pCount_)
00162         {}
00163         
<a name="l00164"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda10">00164</a>         P <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda3">Clone</a>(<span class="keyword">const</span> P&amp; val)
00165         {
00166             ++*pCount_;
00167             <span class="keywordflow">return</span> val;
00168         }
00169         
<a name="l00170"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda11">00170</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda4">OnInit</a>(<span class="keyword">const</span> P&amp;)
00171         {}
00172 
<a name="l00173"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda12">00173</a>         <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda5">Release</a>(<span class="keyword">const</span> P&amp;)
00174         {
00175             <span class="keywordflow">if</span> (!--*pCount_)
00176             {
00177                 <a class="code" href="classbase_1_1SmallObject.html">SmallObject&lt;&gt;::operator delete</a>(pCount_, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>));
00178                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00179             }
00180             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00181         }
00182         
<a name="l00183"></a><a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda13">00183</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1RefCounted.html#base_1_1RefCounteda6">Swap</a>(<a class="code" href="classRefCounted.html">RefCounted</a>&amp; rhs)
00184         { std::swap(pCount_, rhs.pCount_); }
00185     
00186         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00187 
00188     <span class="keyword">private</span>:
00189         <span class="comment">// Data</span>
00190         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* pCount_;
00191     };
00192     <span class="comment"></span>
00193 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00194 <span class="comment"></span><span class="comment">// class template RefCountedMT</span>
00195 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00196 <span class="comment">// Implements external reference counting for multithreaded programs</span><span class="comment"></span>
00197 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00198 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class </span>P,
00199         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classThreadingModel.html">ThreadingModel</a>&gt;
00200     <span class="keyword">class </span>RefCountedMT : <span class="keyword">public</span> <a class="code" href="classThreadingModel.html">ThreadingModel</a>&lt; RefCountedMT&lt;P, ThreadingModel&gt; &gt;
00201     {
00202     <span class="keyword">public</span>:
<a name="l00203"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa7">00203</a>         <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa0">RefCountedMT</a>() 
00204         {
00205             pCount_ = static_cast&lt;unsigned int*&gt;(
00206                 <a class="code" href="MemoryTracer.html#a3">SmallObject&lt;ThreadingModel&gt;::operator new</a>(
00207                     <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)));
00208             assert(pCount_);
00209             *pCount_ = 1;
00210         }
00211         
<a name="l00212"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa8">00212</a>         <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa0">RefCountedMT</a>(<span class="keyword">const</span> <a class="code" href="classRefCountedMT.html">RefCountedMT</a>&amp; rhs) 
00213         : pCount_(rhs.pCount_)
00214         {}
00215         
00216         <span class="comment">// MWCW lacks template friends, hence the following kludge</span>
00217         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1&gt;
<a name="l00218"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa9">00218</a>         <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa0">RefCountedMT</a>(<span class="keyword">const</span> <a class="code" href="classRefCountedMT.html">RefCountedMT&lt;P1, ThreadingModel&gt;</a>&amp; rhs) 
00219         : pCount_(reinterpret_cast&lt;const <a class="code" href="classbase_1_1RefCounted.html">RefCounted</a>&lt;P&gt;&amp;&gt;(rhs).pCount_)
00220         {}
00221         
<a name="l00222"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa10">00222</a>         P <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa3">Clone</a>(<span class="keyword">const</span> P&amp; val)
00223         {
00224             <a class="code" href="classThreadingModel.html">ThreadingModel&lt;RefCountedMT&gt;::AtomicIncrement</a>(*pCount_);
00225             <span class="keywordflow">return</span> val;
00226         }
00227         
<a name="l00228"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa11">00228</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa4">OnInit</a>(<span class="keyword">const</span> P&amp;)
00229         {}
00230 
<a name="l00231"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa12">00231</a>         <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa5">Release</a>(<span class="keyword">const</span> P&amp;)
00232         {
00233             <span class="keywordflow">if</span> (!<a class="code" href="classThreadingModel.html">ThreadingModel&lt;RefCountedMT&gt;::AtomicDecrement</a>(*pCount_))
00234             {
00235                 <a class="code" href="classbase_1_1SmallObject.html">SmallObject&lt;ThreadingModel&gt;::operator delete</a>(pCount_, 
00236                     <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>));
00237                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00238             }
00239             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00240         }
00241         
<a name="l00242"></a><a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa13">00242</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1RefCountedMT.html#base_1_1RefCountedMTa6">Swap</a>(<a class="code" href="classRefCountedMT.html">RefCountedMT</a>&amp; rhs)
00243         { std::swap(pCount_, rhs.pCount_); }
00244     
00245         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00246 
00247     <span class="keyword">private</span>:
00248         <span class="comment">// Data</span>
00249         <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* pCount_;
00250     };
00251 <span class="comment"></span>
00252 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00253 <span class="comment"></span><span class="comment">// class template COMRefCounted</span>
00254 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00255 <span class="comment">// Adapts COM intrusive reference counting to OwnershipPolicy-specific syntax</span><span class="comment"></span>
00256 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00257 <span class="comment"></span>
00258     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00259     <span class="keyword">class </span>COMRefCounted
00260     {
00261     <span class="keyword">public</span>:
<a name="l00262"></a><a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCounteda2">00262</a>         <a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCounteda0">COMRefCounted</a>()
00263         {}
00264         
00265         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00266"></a><a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCounteda3">00266</a>         <a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCounteda0">COMRefCounted</a>(<span class="keyword">const</span> <a class="code" href="classCOMRefCounted.html">COMRefCounted&lt;U&gt;</a>&amp;)
00267         {}
00268         
<a name="l00269"></a><a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede4">00269</a>         <span class="keyword">static</span> P <a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede0">Clone</a>(<span class="keyword">const</span> P&amp; val)
00270         {
00271             val-&gt;AddRef();
00272             <span class="keywordflow">return</span> val;
00273         }
00274         
<a name="l00275"></a><a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede5">00275</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00276         {}
00277 
<a name="l00278"></a><a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede6">00278</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede2">Release</a>(<span class="keyword">const</span> P&amp; val)
00279         { val-&gt;Release(); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
00280         
00281         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00282         
<a name="l00283"></a><a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede7">00283</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1COMRefCounted.html#base_1_1COMRefCountede3">Swap</a>(<a class="code" href="classCOMRefCounted.html">COMRefCounted</a>&amp;)
00284         {}
00285     };
00286 <span class="comment"></span>
00287 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00288 <span class="comment"></span><span class="comment">// class template IntrRefCounted</span>
00289 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00290 <span class="comment">// Intrusive reference counting through class Referenced</span><span class="comment"></span>
00291 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00292 <span class="comment"></span>
00293     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00294     <span class="keyword">class </span>IntrRefCounted
00295     {
00296     <span class="keyword">public</span>:
<a name="l00297"></a><a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCounteda2">00297</a>         <a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCounteda0">IntrRefCounted</a>()
00298         {}
00299         
00300         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00301"></a><a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCounteda3">00301</a>         <a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCounteda0">IntrRefCounted</a>(<span class="keyword">const</span> <a class="code" href="classIntrRefCounted.html">IntrRefCounted&lt;U&gt;</a>&amp;)
00302         {}
00303         
<a name="l00304"></a><a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede4">00304</a>         <span class="keyword">static</span> P <a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede0">Clone</a>(<span class="keyword">const</span> P&amp; val)
00305         {
00306           <span class="keywordflow">if</span> (val!=0)
00307             val-&gt;reference();
00308           <span class="keywordflow">return</span> val;
00309         }
00310         
<a name="l00311"></a><a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede5">00311</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede1">OnInit</a>(<span class="keyword">const</span> P&amp; val)
00312         {
00313           <span class="keywordflow">if</span> (val!=0)
00314             val-&gt;reference();
00315         }
00316 
<a name="l00317"></a><a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede6">00317</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede2">Release</a>(<span class="keyword">const</span> P&amp; val)
00318         { 
00319           <span class="keywordflow">if</span> (val!=0) 
00320             <span class="keywordflow">return</span> val-&gt;unreference(); 
00321           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00322         }
00323         
00324         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00325         
<a name="l00326"></a><a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede7">00326</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1IntrRefCounted.html#base_1_1IntrRefCountede3">Swap</a>(<a class="code" href="classIntrRefCounted.html">IntrRefCounted</a>&amp;)
00327         {}
00328     };
00329 <span class="comment"></span>
00330 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00331 <span class="comment"></span><span class="comment">// class template NonSmartShared</span>
00332 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00333 <span class="comment">// Behaves like a regular 'non-smart' builtin pointer</span><span class="comment"></span>
00334 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00335 <span class="comment"></span>
00336     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00337     <span class="keyword">class </span>NonSmartShared
00338     {
00339     <span class="keyword">public</span>:
<a name="l00340"></a><a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartShareda2">00340</a>         <a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartShareda0">NonSmartShared</a>()
00341         {}
00342         
00343         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00344"></a><a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartShareda3">00344</a>         <a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartShareda0">NonSmartShared</a>(<span class="keyword">const</span> <a class="code" href="classNonSmartShared.html">NonSmartShared&lt;U&gt;</a>&amp;)
00345         {}
00346         
<a name="l00347"></a><a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede4">00347</a>         <span class="keyword">static</span> P <a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede0">Clone</a>(<span class="keyword">const</span> P&amp; val)
00348         {
00349           <span class="keywordflow">return</span> val;
00350         }
00351         
<a name="l00352"></a><a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede5">00352</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede1">OnInit</a>(<span class="keyword">const</span> P&amp; val)
00353         {}
00354 
<a name="l00355"></a><a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede6">00355</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede2">Release</a>(<span class="keyword">const</span> P&amp; val)
00356         { 
00357           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00358         }
00359         
00360         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00361         
<a name="l00362"></a><a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede7">00362</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1NonSmartShared.html#base_1_1NonSmartSharede3">Swap</a>(<a class="code" href="classNonSmartShared.html">NonSmartShared</a>&amp;)
00363         {}
00364     };
00365 <span class="comment"></span>
00366 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00367 <span class="comment"></span><span class="comment">// class template DeepCopy</span>
00368 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00369 <span class="comment">// Implements deep copy semantics, assumes existence of a Clone() member </span>
00370 <span class="comment">//     function of the pointee type</span><span class="comment"></span>
00371 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00372 <span class="comment"></span>
00373     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00374     <span class="keyword">struct </span>DeepCopy
00375     {
<a name="l00376"></a><a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopya2">00376</a>         <a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopya0">DeepCopy</a>()
00377         {}
00378         
00379         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00380"></a><a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopya3">00380</a>         <a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopya0">DeepCopy</a>(<span class="keyword">const</span> <a class="code" href="classDeepCopy.html">DeepCopy&lt;P1&gt;</a>&amp;)
00381         {}
00382         
<a name="l00383"></a><a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye4">00383</a>         <span class="keyword">static</span> P <a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye0">Clone</a>(<span class="keyword">const</span> P&amp; val)
00384         { <span class="keywordflow">return</span> val-&gt;Clone(); }
00385         
<a name="l00386"></a><a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye5">00386</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00387         {}
00388 
<a name="l00389"></a><a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye6">00389</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye2">Release</a>(<span class="keyword">const</span> P&amp; val)
00390         { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
00391         
<a name="l00392"></a><a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye7">00392</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1DeepCopy.html#base_1_1DeepCopye3">Swap</a>(<a class="code" href="classDeepCopy.html">DeepCopy</a>&amp;)
00393         {}
00394         
00395         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00396     };
00397     <span class="comment"></span>
00398 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00399 <span class="comment"></span><span class="comment">// class template RefLinked</span>
00400 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00401 <span class="comment">// Implements reference linking</span><span class="comment"></span>
00402 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00403 <span class="comment"></span>
00404     <span class="keyword">namespace </span>Private
00405     {
00406         <span class="keyword">class </span>RefLinkedBase
00407         {
00408         <span class="keyword">public</span>:
<a name="l00409"></a><a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea4">00409</a>             <a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea0">RefLinkedBase</a>() 
00410             { prev_ = next_ = <span class="keyword">this</span>; }
00411             
<a name="l00412"></a><a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea5">00412</a>             <a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea0">RefLinkedBase</a>(<span class="keyword">const</span> <a class="code" href="classRefLinkedBase.html">RefLinkedBase</a>&amp; rhs) 
00413             {
00414                 prev_ = &amp;rhs;
00415                 next_ = rhs.next_;
00416                 prev_-&gt;next_ = <span class="keyword">this</span>;
00417                 next_-&gt;prev_ = <span class="keyword">this</span>;
00418             }
00419             
<a name="l00420"></a><a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea6">00420</a>             <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea2">Release</a>()
00421             {
00422                 <span class="keywordflow">if</span> (next_ == <span class="keyword">this</span>)
00423                 {   
00424                     assert(prev_ == <span class="keyword">this</span>);
00425                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00426                 }
00427                 prev_-&gt;next_ = next_;
00428                 next_-&gt;prev_ = prev_;
00429                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00430             }
00431             
<a name="l00432"></a><a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea7">00432</a>             <span class="keywordtype">void</span> <a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea3">Swap</a>(<a class="code" href="classRefLinkedBase.html">RefLinkedBase</a>&amp; rhs)
00433             {
00434                 <span class="keywordflow">if</span> (next_ == <span class="keyword">this</span>)
00435                 {
00436                     assert(prev_ == <span class="keyword">this</span>);
00437                     <span class="keywordflow">if</span> (rhs.next_ == &amp;rhs)
00438                     {
00439                         assert(rhs.prev_ == &amp;rhs);
00440                         <span class="comment">// both lists are empty, nothing 2 do</span>
00441                         <span class="keywordflow">return</span>;
00442                     }
00443                     prev_ = rhs.prev_;
00444                     next_ = rhs.next_;
00445                     prev_-&gt;next_ = next_-&gt;prev_ = <span class="keyword">this</span>;
00446                     rhs.next_ = rhs.prev_ = &amp;rhs;
00447                     <span class="keywordflow">return</span>;
00448                 }
00449                 <span class="keywordflow">if</span> (rhs.next_ == &amp;rhs)
00450                 {
00451                     rhs.Swap(*<span class="keyword">this</span>);
00452                     <span class="keywordflow">return</span>;
00453                 }
00454                 std::swap(prev_, rhs.prev_);
00455                 std::swap(next_, rhs.next_);
00456                 std::swap(prev_-&gt;next_, rhs.prev_-&gt;next_);
00457                 std::swap(next_-&gt;prev_, rhs.next_-&gt;prev_);
00458             }
00459                 
00460             <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00461 
00462         <span class="keyword">private</span>:
00463             <span class="keyword">mutable</span> <span class="keyword">const</span> RefLinkedBase* prev_;
00464             <span class="keyword">mutable</span> <span class="keyword">const</span> RefLinkedBase* next_;
00465         };
00466     }
00467     
00468     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00469     <span class="keyword">class </span>RefLinked : <span class="keyword">public</span> <a class="code" href="classPrivate.html">Private</a>::RefLinkedBase
00470     {
00471     <span class="keyword">public</span>:
<a name="l00472"></a><a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkeda3">00472</a>         <a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkeda0">RefLinked</a>()
00473         {}
00474         
00475         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00476"></a><a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkeda4">00476</a>         <a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkeda0">RefLinked</a>(<span class="keyword">const</span> <a class="code" href="classRefLinked.html">RefLinked&lt;P1&gt;</a>&amp; rhs) 
00477         : <a class="code" href="classPrivate.html">Private</a>::RefLinkedBase(rhs)
00478         {}
00479 
<a name="l00480"></a><a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkede2">00480</a>         <span class="keyword">static</span> P <a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkede0">Clone</a>(<span class="keyword">const</span> P&amp; val)
00481         { <span class="keywordflow">return</span> val; }
00482 
<a name="l00483"></a><a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkede3">00483</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkede1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00484         {}
00485 
<a name="l00486"></a><a class="code" href="classbase_1_1RefLinked.html#base_1_1RefLinkeda5">00486</a>         <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1Private_1_1RefLinkedBase.html#base_1_1Private_1_1RefLinkedBasea2">Release</a>(<span class="keyword">const</span> P&amp;)
00487         { <span class="keywordflow">return</span> Private::RefLinkedBase::Release(); }
00488     };
00489     <span class="comment"></span>
00490 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00491 <span class="comment"></span><span class="comment">// class template DestructiveCopy</span>
00492 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00493 <span class="comment">// Implements destructive copy semantics (a la std::auto_ptr)</span><span class="comment"></span>
00494 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00495 <span class="comment"></span>
00496     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00497     <span class="keyword">class </span>DestructiveCopy
00498     {
00499     <span class="keyword">public</span>:
<a name="l00500"></a><a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopya2">00500</a>         <a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopya0">DestructiveCopy</a>()
00501         {}
00502         
00503         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00504"></a><a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopya3">00504</a>         <a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopya0">DestructiveCopy</a>(<span class="keyword">const</span> <a class="code" href="classDestructiveCopy.html">DestructiveCopy&lt;P1&gt;</a>&amp;)
00505         {}
00506         
00507         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00508"></a><a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye4">00508</a>         <span class="keyword">static</span> P <a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye0">Clone</a>(P1&amp; val)
00509         {
00510             P result(val);
00511             val = <a class="code" href="Globals_8h.html#a25">P1</a>();
00512             <span class="keywordflow">return</span> result;
00513         }
00514 
<a name="l00515"></a><a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye5">00515</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00516         {}
00517 
<a name="l00518"></a><a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye6">00518</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye2">Release</a>(<span class="keyword">const</span> P&amp;)
00519         { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
00520         
<a name="l00521"></a><a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye7">00521</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1DestructiveCopy.html#base_1_1DestructiveCopye3">Swap</a>(<a class="code" href="classDestructiveCopy.html">DestructiveCopy</a>&amp;)
00522         {}
00523         
00524         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">true</span> };
00525     };
00526     <span class="comment"></span>
00527 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00528 <span class="comment"></span><span class="comment">// class template NoCopy</span>
00529 <span class="comment">// Implementation of the OwnershipPolicy used by ref</span>
00530 <span class="comment">// Implements a policy that doesn't allow copying objects</span><span class="comment"></span>
00531 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00532 <span class="comment"></span>
00533     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00534     <span class="keyword">class </span>NoCopy
00535     {
00536     <span class="keyword">public</span>:
<a name="l00537"></a><a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopya2">00537</a>         <a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopya0">NoCopy</a>()
00538         {}
00539         
00540         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00541"></a><a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopya3">00541</a>         <a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopya0">NoCopy</a>(<span class="keyword">const</span> <a class="code" href="classNoCopy.html">NoCopy&lt;P1&gt;</a>&amp;)
00542         {}
00543         
<a name="l00544"></a><a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye4">00544</a>         <span class="keyword">static</span> P <a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye0">Clone</a>(<span class="keyword">const</span> P&amp;)
00545         {
00546             CT_ASSERT(<span class="keyword">false</span>, This_Policy_Disallows_Value_Copying);
00547         }
00548 
<a name="l00549"></a><a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye5">00549</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00550         {}
00551 
<a name="l00552"></a><a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye6">00552</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye2">Release</a>(<span class="keyword">const</span> P&amp;)
00553         { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
00554         
<a name="l00555"></a><a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye7">00555</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1NoCopy.html#base_1_1NoCopye3">Swap</a>(<a class="code" href="classNoCopy.html">NoCopy</a>&amp;)
00556         {}
00557         
00558         <span class="keyword">enum</span> { destructiveCopy = <span class="keyword">false</span> };
00559     };
00560     <span class="comment"></span>
00561 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00562 <span class="comment"></span><span class="comment">// class template AllowConversion</span>
00563 <span class="comment">// Implementation of the ConversionPolicy used by ref</span>
00564 <span class="comment">// Allows implicit conversion from ref to the pointee type</span><span class="comment"></span>
00565 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00566 <span class="comment"></span>
00567     <span class="keyword">struct </span>AllowConversion
00568     {
00569         <span class="keyword">enum</span> { <a class="code" href="structbase_1_1AllowConversion.html#base_1_1AllowConversionw2base_1_1AllowConversionw0">allow</a> = <span class="keyword">true</span> };
00570 
<a name="l00571"></a><a class="code" href="structbase_1_1AllowConversion.html#base_1_1AllowConversiona1">00571</a>         <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AllowConversion.html#base_1_1AllowConversiona0">Swap</a>(<a class="code" href="structbase_1_1AllowConversion.html">AllowConversion</a>&amp;)
00572         {}
00573     };
00574 <span class="comment"></span>
00575 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00576 <span class="comment"></span><span class="comment">// class template DisallowConversion</span>
00577 <span class="comment">// Implementation of the ConversionPolicy used by ref</span>
00578 <span class="comment">// Does not allow implicit conversion from ref to the pointee type</span>
00579 <span class="comment">// You can initialize a DisallowConversion with an AllowConversion</span><span class="comment"></span>
00580 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00581 <span class="comment"></span>
00582     <span class="keyword">struct </span>DisallowConversion
00583     {
<a name="l00584"></a><a class="code" href="structbase_1_1DisallowConversion.html#base_1_1DisallowConversiona3">00584</a>         <a class="code" href="structbase_1_1DisallowConversion.html#base_1_1DisallowConversiona0">DisallowConversion</a>()
00585         {}
00586         
<a name="l00587"></a><a class="code" href="structbase_1_1DisallowConversion.html#base_1_1DisallowConversiona4">00587</a>         <a class="code" href="structbase_1_1DisallowConversion.html#base_1_1DisallowConversiona0">DisallowConversion</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1AllowConversion.html">AllowConversion</a>&amp;)
00588         {}
00589         
00590         <span class="keyword">enum</span> { allow = <span class="keyword">false</span> };
00591 
<a name="l00592"></a><a class="code" href="structbase_1_1DisallowConversion.html#base_1_1DisallowConversiona5">00592</a>         <span class="keywordtype">void</span> <a class="code" href="structbase_1_1DisallowConversion.html#base_1_1DisallowConversiona2">Swap</a>(<a class="code" href="classDisallowConversion.html">DisallowConversion</a>&amp;)
00593         {}
00594     };
00595 <span class="comment"></span>
00596 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00597 <span class="comment"></span><span class="comment">// class template NoCheck</span>
00598 <span class="comment">// Implementation of the CheckingPolicy used by ref</span>
00599 <span class="comment">// Well, it's clear what it does :o)</span><span class="comment"></span>
00600 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00601 <span class="comment"></span>
00602     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00603     <span class="keyword">struct </span>NoCheck
00604     {
<a name="l00605"></a><a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecka2">00605</a>         <a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecka0">NoCheck</a>()
00606         {}
00607         
00608         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00609"></a><a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecka3">00609</a>         <a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecka0">NoCheck</a>(<span class="keyword">const</span> <a class="code" href="classNoCheck.html">NoCheck&lt;P1&gt;</a>&amp;)
00610         {}
00611         
<a name="l00612"></a><a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke4">00612</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke0">OnDefault</a>(<span class="keyword">const</span> P&amp;)
00613         {}
00614 
<a name="l00615"></a><a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke5">00615</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00616         {}
00617 
<a name="l00618"></a><a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke6">00618</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke2">OnDereference</a>(<span class="keyword">const</span> P&amp;)
00619         {}
00620 
<a name="l00621"></a><a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke7">00621</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1NoCheck.html#base_1_1NoChecke3">Swap</a>(<a class="code" href="classNoCheck.html">NoCheck</a>&amp;)
00622         {}
00623     };
00624 
00625 <span class="comment"></span>
00626 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00627 <span class="comment"></span><span class="comment">// class template AssertCheck</span>
00628 <span class="comment">// Implementation of the CheckingPolicy used by ref</span>
00629 <span class="comment">// Checks the pointer before dereference</span><span class="comment"></span>
00630 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00631 <span class="comment"></span>
00632     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00633     <span class="keyword">struct </span>AssertCheck
00634     {
<a name="l00635"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecka3">00635</a>         <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecka0">AssertCheck</a>()
00636         {}
00637         
00638         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00639"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecka4">00639</a>         <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecka0">AssertCheck</a>(<span class="keyword">const</span> <a class="code" href="classAssertCheck.html">AssertCheck&lt;P1&gt;</a>&amp;)
00640         {}
00641         
00642         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00643"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecka5">00643</a>         <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecka0">AssertCheck</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1NoCheck.html">NoCheck&lt;P1&gt;</a>&amp;)
00644         {}
00645         
<a name="l00646"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke4">00646</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke0">OnDefault</a>(<span class="keyword">const</span> P&amp;)
00647         {}
00648 
<a name="l00649"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke5">00649</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke1">OnInit</a>(<span class="keyword">const</span> P&amp;)
00650         {}
00651 
<a name="l00652"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke6">00652</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke2">OnDereference</a>(P val)
00653         { assert(val); }
00654 
<a name="l00655"></a><a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke7">00655</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheck.html#base_1_1AssertChecke3">Swap</a>(<a class="code" href="classAssertCheck.html">AssertCheck</a>&amp;)
00656         {}
00657     };
00658 <span class="comment"></span>
00659 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00660 <span class="comment"></span><span class="comment">// class template AssertCheckStrict</span>
00661 <span class="comment">// Implementation of the CheckingPolicy used by ref</span>
00662 <span class="comment">// Checks the pointer against zero upon initialization and before dereference</span>
00663 <span class="comment">// You can initialize an AssertCheckStrict with an AssertCheck </span><span class="comment"></span>
00664 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00665 <span class="comment"></span>
00666     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00667     <span class="keyword">struct </span>AssertCheckStrict
00668     {
<a name="l00669"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta4">00669</a>         <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta0">AssertCheckStrict</a>()
00670         {}
00671         
00672         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00673"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta5">00673</a>         <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta0">AssertCheckStrict</a>(<span class="keyword">const</span> <a class="code" href="classAssertCheckStrict.html">AssertCheckStrict&lt;U&gt;</a>&amp;)
00674         {}
00675         
00676         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00677"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta6">00677</a>         <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta0">AssertCheckStrict</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1AssertCheck.html">AssertCheck&lt;U&gt;</a>&amp;)
00678         {}
00679         
00680         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00681"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta7">00681</a>         <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricta0">AssertCheckStrict</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1NoCheck.html">NoCheck&lt;P1&gt;</a>&amp;)
00682         {}
00683         
<a name="l00684"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte4">00684</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte0">OnDefault</a>(P val)
00685         { assert(val); }
00686         
<a name="l00687"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte5">00687</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte1">OnInit</a>(P val)
00688         { assert(val); }
00689         
<a name="l00690"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte6">00690</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte2">OnDereference</a>(P val)
00691         { assert(val); }
00692         
<a name="l00693"></a><a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte7">00693</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1AssertCheckStrict.html#base_1_1AssertCheckStricte3">Swap</a>(<a class="code" href="classAssertCheckStrict.html">AssertCheckStrict</a>&amp;)
00694         {}
00695     };
00696 <span class="comment"></span>
00697 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00698 <span class="comment"></span><span class="comment">// class NullPointerException</span>
00699 <span class="comment">// Used by some implementations of the CheckingPolicy used by ref</span><span class="comment"></span>
00700 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00701 <span class="comment"></span>
00702     <span class="keyword">struct </span>NullPointerException : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1runtime__error.html">runtime_error</a>
00703     {
<a name="l00704"></a><a class="code" href="structbase_1_1NullPointerException.html#base_1_1NullPointerExceptiona2">00704</a>         <a class="code" href="structbase_1_1NullPointerException.html#base_1_1NullPointerExceptiona0">NullPointerException</a>() : std::<a class="code" href="classstd_1_1runtime__error.html">runtime_error</a>("")
00705         { }
<a name="l00706"></a><a class="code" href="structbase_1_1NullPointerException.html#base_1_1NullPointerExceptiona3">00706</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="structbase_1_1NullPointerException.html#base_1_1NullPointerExceptiona1">what</a>() <span class="keyword">const</span> <span class="keywordflow">throw</span>()  <span class="comment">// added throw() DJ</span>
00707         { <span class="keywordflow">return</span> <span class="stringliteral">"Null Pointer Exception"</span>; }
00708     };
00709         <span class="comment"></span>
00710 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00711 <span class="comment"></span><span class="comment">// class template RejectNullStatic</span>
00712 <span class="comment">// Implementation of the CheckingPolicy used by ref</span>
00713 <span class="comment">// Checks the pointer upon initialization and before dereference</span><span class="comment"></span>
00714 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00715 <span class="comment"></span>
00716     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00717     <span class="keyword">struct </span>RejectNullStatic
00718     {
<a name="l00719"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica5">00719</a>         <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica0">RejectNullStatic</a>()
00720         {}
00721         
00722         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00723"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica6">00723</a>         <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica0">RejectNullStatic</a>(<span class="keyword">const</span> <a class="code" href="classRejectNullStatic.html">RejectNullStatic&lt;P1&gt;</a>&amp;)
00724         {}
00725         
00726         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00727"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica7">00727</a>         <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica0">RejectNullStatic</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1NoCheck.html">NoCheck&lt;P1&gt;</a>&amp;)
00728         {}
00729         
00730         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00731"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica8">00731</a>         <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica0">RejectNullStatic</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1AssertCheck.html">AssertCheck&lt;P1&gt;</a>&amp;)
00732         {}
00733         
00734         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00735"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica9">00735</a>         <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatica0">RejectNullStatic</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1AssertCheckStrict.html">AssertCheckStrict&lt;P1&gt;</a>&amp;)
00736         {}
00737         
<a name="l00738"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice4">00738</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice0">OnDefault</a>(<span class="keyword">const</span> P&amp;)
00739         {
00740             CompileTimeError&lt;false&gt;
00741                 ERROR_This_Policy_Does_Not_Allow_Default_Initialization;
00742         }
00743         
<a name="l00744"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice5">00744</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice1">OnInit</a>(<span class="keyword">const</span> P&amp; val)
00745         { <span class="keywordflow">if</span> (!val) <span class="keywordflow">throw</span> <a class="code" href="structbase_1_1NullPointerException.html">NullPointerException</a>(); }
00746         
<a name="l00747"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice6">00747</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice2">OnDereference</a>(<span class="keyword">const</span> P&amp; val)
00748         { <span class="keywordflow">if</span> (!val) <span class="keywordflow">throw</span> <a class="code" href="structbase_1_1NullPointerException.html">NullPointerException</a>(); }
00749         
<a name="l00750"></a><a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice7">00750</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStatic.html#base_1_1RejectNullStatice3">Swap</a>(<a class="code" href="classRejectNullStatic.html">RejectNullStatic</a>&amp;)
00751         {}
00752     };
00753 <span class="comment"></span>
00754 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00755 <span class="comment"></span><span class="comment">// class template RejectNull</span>
00756 <span class="comment">// Implementation of the CheckingPolicy used by ref</span>
00757 <span class="comment">// Checks the pointer before dereference</span><span class="comment"></span>
00758 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00759 <span class="comment"></span>
00760     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00761     <span class="keyword">struct </span>RejectNull
00762     {
<a name="l00763"></a><a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla4">00763</a>         <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla0">RejectNull</a>()
00764         {}
00765         
00766         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00767"></a><a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla5">00767</a>         <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla0">RejectNull</a>(<span class="keyword">const</span> <a class="code" href="classRejectNull.html">RejectNull&lt;P1&gt;</a>&amp;)
00768         {}
00769         
<a name="l00770"></a><a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulle2">00770</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulle0">OnInit</a>(P val)
00771         { <span class="keywordflow">if</span> (!val) <span class="keywordflow">throw</span> <a class="code" href="structbase_1_1NullPointerException.html">NullPointerException</a>(); }
00772 
<a name="l00773"></a><a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulle3">00773</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulle1">OnDefault</a>(P val)
00774         { <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulle0">OnInit</a>(val); }
00775         
<a name="l00776"></a><a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla6">00776</a>         <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla2">OnDereference</a>(P val)
00777         { <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulle0">OnInit</a>(val); }
00778         
<a name="l00779"></a><a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla7">00779</a>         <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNull.html#base_1_1RejectNulla3">Swap</a>(<a class="code" href="classRejectNull.html">RejectNull</a>&amp;)
00780         {}        
00781     };
00782 <span class="comment"></span>
00783 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00784 <span class="comment"></span><span class="comment">// class template RejectNullStrict</span>
00785 <span class="comment">// Implementation of the CheckingPolicy used by ref</span>
00786 <span class="comment">// Checks the pointer upon initialization and before dereference</span><span class="comment"></span>
00787 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00788 <span class="comment"></span>
00789     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;
00790     <span class="keyword">struct </span>RejectNullStrict
00791     {
<a name="l00792"></a><a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta5">00792</a>         <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta0">RejectNullStrict</a>()
00793         {}
00794         
00795         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00796"></a><a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta6">00796</a>         <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta0">RejectNullStrict</a>(<span class="keyword">const</span> <a class="code" href="classRejectNullStrict.html">RejectNullStrict&lt;P1&gt;</a>&amp;)
00797         {}
00798         
00799         <span class="keyword">template</span> &lt;<span class="keyword">class</span> P1&gt;
<a name="l00800"></a><a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta7">00800</a>         <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta0">RejectNullStrict</a>(<span class="keyword">const</span> <a class="code" href="structbase_1_1RejectNull.html">RejectNull&lt;P1&gt;</a>&amp;)
00801         {}
00802         
<a name="l00803"></a><a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricte1">00803</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricte0">OnInit</a>(P val)
00804         { <span class="keywordflow">if</span> (!val) <span class="keywordflow">throw</span> <a class="code" href="structbase_1_1NullPointerException.html">NullPointerException</a>(); }
00805 
<a name="l00806"></a><a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta8">00806</a>         <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta3">OnDereference</a>(P val)
00807         { <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricte0">OnInit</a>(val); }
00808         
<a name="l00809"></a><a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta9">00809</a>         <span class="keywordtype">void</span> <a class="code" href="structbase_1_1RejectNullStrict.html#base_1_1RejectNullStricta4">Swap</a>(<a class="code" href="classRejectNullStrict.html">RejectNullStrict</a>&amp;)
00810         {}        
00811     };
00812 <span class="comment"></span>
00813 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00814 <span class="comment"></span><span class="comment">// class template ByRef</span>
00815 <span class="comment">// Transports a reference as a value</span>
00816 <span class="comment">// Serves to implement the Colvin/Gibbons trick for ref</span><span class="comment"></span>
00817 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00818 <span class="comment"></span>
00819     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00820     <span class="keyword">class </span>ByRef
00821     {
00822     <span class="keyword">public</span>:
<a name="l00823"></a><a class="code" href="classbase_1_1ByRef.html#base_1_1ByRefa2">00823</a>         <a class="code" href="classbase_1_1ByRef.html#base_1_1ByRefa0">ByRef</a>(T&amp; v) : value_(v) {}
<a name="l00824"></a><a class="code" href="classbase_1_1ByRef.html#base_1_1ByRefa3">00824</a>         <a class="code" href="classbase_1_1ByRef.html#base_1_1ByRefa1">operator T&amp;</a>() { <span class="keywordflow">return</span> value_; }
00825         <span class="comment">// gcc doesn't like this:</span>
00826         <span class="comment">// operator const T&amp;() const { return value_; }</span>
00827     <span class="keyword">private</span>:
00828         T&amp; value_;
00829     };
00830 <span class="comment"></span>
00831 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00832 <span class="comment"></span><span class="comment">// class template ref (declaration)</span>
00833 <span class="comment">// The reason for all the fuss above</span><span class="comment"></span>
00834 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00835 <span class="comment"></span>
00836     <span class="keyword">template</span>
00837     &lt;
00838         <span class="keyword">typename</span> T,
00839         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classOwnershipPolicy.html">OwnershipPolicy</a> = IntrRefCounted,
00840         <span class="keyword">class </span><a class="code" href="classConversionPolicy.html">ConversionPolicy</a> = DisallowConversion,
00841         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classCheckingPolicy.html">CheckingPolicy</a> = AssertCheck,
00842         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classStoragePolicy.html">StoragePolicy</a> = DefaultSPStorage
00843     &gt;
00844     <span class="keyword">class </span>ref;
00845 <span class="comment"></span>
00846 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00847 <span class="comment"></span><span class="comment">// class template ref (definition)</span><span class="comment"></span>
00848 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
00849 <span class="comment"></span>
00850     <span class="keyword">template</span>
00851     &lt;
00852         <span class="keyword">typename</span> T,
00853         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classOwnershipPolicy.html">OwnershipPolicy</a>,
00854         <span class="keyword">class </span><a class="code" href="classConversionPolicy.html">ConversionPolicy</a>,
00855         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classCheckingPolicy.html">CheckingPolicy</a>,
00856         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classStoragePolicy.html">StoragePolicy</a>
00857     &gt;
00858     <span class="keyword">class </span>ref
00859         : <span class="keyword">public</span> <a class="code" href="classStoragePolicy.html">StoragePolicy</a>&lt;T&gt;
00860         , <span class="keyword">public</span> <a class="code" href="classOwnershipPolicy.html">OwnershipPolicy</a>&lt;typename StoragePolicy&lt;T&gt;::PointerType&gt;
00861         , <span class="keyword">public</span> <a class="code" href="classCheckingPolicy.html">CheckingPolicy</a>&lt;typename StoragePolicy&lt;T&gt;::StoredType&gt;
00862         , <span class="keyword">public</span> <a class="code" href="classConversionPolicy.html">ConversionPolicy</a>
00863     {
00864         <span class="keyword">typedef</span> <a class="code" href="classStoragePolicy.html">StoragePolicy&lt;T&gt;</a> SP;
00865         <span class="keyword">typedef</span> <a class="code" href="classOwnershipPolicy.html">OwnershipPolicy&lt;typename StoragePolicy&lt;T&gt;</a>::PointerType&gt; OP;
00866         <span class="keyword">typedef</span> <a class="code" href="classCheckingPolicy.html">CheckingPolicy&lt;typename StoragePolicy&lt;T&gt;</a>::StoredType&gt; KP;
00867         <span class="keyword">typedef</span> <a class="code" href="classConversionPolicy.html">ConversionPolicy</a> CP;
00868         
00869     <span class="keyword">public</span>:
<a name="l00870"></a><a class="code" href="classbase_1_1ref.html#base_1_1refw4">00870</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> SP::PointerType PointerType;
<a name="l00871"></a><a class="code" href="classbase_1_1ref.html#base_1_1refw5">00871</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> SP::StoredType StoredType;
<a name="l00872"></a><a class="code" href="classbase_1_1ref.html#base_1_1refw6">00872</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> SP::ReferenceType ReferenceType;
00873         
00874         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structbase_1_1Select.html">Select</a>&lt;OP::destructiveCopy, 
00875                 <a class="code" href="classbase_1_1ref.html">ref</a>, <span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">ref</a>&gt;::Result
<a name="l00876"></a><a class="code" href="classbase_1_1ref.html#base_1_1refw7">00876</a>             CopyArg;
00877 
00878     
<a name="l00879"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa22">00879</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>()
00880         { KP::OnDefault(GetImpl(*<span class="keyword">this</span>)); }
00881         
<a name="l00882"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa23">00882</a>         <span class="keyword">explicit</span> <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>(<span class="keyword">const</span> StoredType&amp; p) : SP(p)
00883         { KP::OnInit(GetImpl(*<span class="keyword">this</span>)); OP::OnInit(GetImpl(*<span class="keyword">this</span>)); }
00884         
<a name="l00885"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa24">00885</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>(CopyArg&amp; rhs)
00886         : SP(rhs), OP(rhs), KP(rhs), CP(rhs)
00887         { <a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>) = OP::Clone(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(rhs)); }
00888 
00889         <span class="keyword">template</span>
00890         &lt;
00891             <span class="keyword">typename</span> T1,
00892             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
00893             <span class="keyword">class </span>CP1,
00894             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
00895             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
00896         &gt;
<a name="l00897"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa25">00897</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">ref&lt;T1, OP1, CP1, KP1, SP1&gt;</a>&amp; rhs)
00898         : SP(rhs), OP(rhs), KP(rhs), CP(rhs)
00899         { <a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>) = OP::Clone(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(rhs)); }
00900 
00901         <span class="keyword">template</span>
00902         &lt;
00903             <span class="keyword">typename</span> T1,
00904             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
00905             <span class="keyword">class </span>CP1,
00906             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
00907             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
00908         &gt;
<a name="l00909"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa26">00909</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>(<a class="code" href="classbase_1_1ref.html">ref&lt;T1, OP1, CP1, KP1, SP1&gt;</a>&amp; rhs)
00910         : SP(rhs), OP(rhs), KP(rhs), CP(rhs)
00911         { <a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>) = OP::Clone(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(rhs)); }
00912 
00913 
<a name="l00914"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa27">00914</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>(<a class="code" href="classbase_1_1ByRef.html">ByRef&lt;ref&gt;</a> rhs)
00915         : SP(rhs), OP(rhs), KP(rhs), CP(rhs)
00916         {}
00917         
<a name="l00918"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa28">00918</a>         operator ByRef&lt;ref&gt;()
00919         { <span class="keywordflow">return</span> <a class="code" href="classbase_1_1ByRef.html">ByRef&lt;ref&gt;</a>(*this); }
00920 
<a name="l00921"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa29">00921</a>         ref&amp; <a class="code" href="classbase_1_1ref.html#base_1_1refa7">operator=</a>(CopyArg&amp; rhs)
00922         {
00923             ref temp(rhs);
00924             temp.Swap(*<span class="keyword">this</span>);
00925             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00926         }
00927 
00928         <span class="keyword">template</span>
00929         &lt;
00930             <span class="keyword">typename</span> T1,
00931             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
00932             <span class="keyword">class </span>CP1,
00933             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
00934             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
00935         &gt;
<a name="l00936"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa30">00936</a>         ref&amp; <a class="code" href="classbase_1_1ref.html#base_1_1refa7">operator=</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">ref&lt;T1, OP1, CP1, KP1, SP1&gt;</a>&amp; rhs)
00937         {
00938             ref temp(rhs);
00939             temp.Swap(*<span class="keyword">this</span>);
00940             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00941         }
00942         
00943         <span class="keyword">template</span>
00944         &lt;
00945             <span class="keyword">typename</span> T1,
00946             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
00947             <span class="keyword">class </span>CP1,
00948             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
00949             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
00950         &gt;
<a name="l00951"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa31">00951</a>         ref&amp; <a class="code" href="classbase_1_1ref.html#base_1_1refa7">operator=</a>(<a class="code" href="classbase_1_1ref.html">ref&lt;T1, OP1, CP1, KP1, SP1&gt;</a>&amp; rhs)
00952         {
00953             ref temp(rhs);
00954             temp.Swap(*<span class="keyword">this</span>);
00955             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00956         }
00957         
<a name="l00958"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa32">00958</a>         <span class="keywordtype">void</span> <a class="code" href="classbase_1_1ref.html#base_1_1refa10">Swap</a>(ref&amp; rhs)
00959         {
00960             OP::Swap(rhs);
00961             CP::Swap(rhs);
00962             KP::Swap(rhs);
00963             SP::Swap(rhs);
00964         }
00965         
<a name="l00966"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa33">00966</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa11">~ref</a>()
00967         {
00968             <span class="keywordflow">if</span> (OP::Release(GetImpl(*static_cast&lt;SP*&gt;(<span class="keyword">this</span>))))
00969             {
00970               SP::Destroy();
00971             }
00972         }
00973         
<a name="l00974"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn7">00974</a>         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn0">Release</a>(ref&amp; sp, <span class="keyword">typename</span> SP::StoredType&amp; p)
00975         {
00976             p = <a class="code" href="namespacebase.html#a163">GetImplRef</a>(sp);
00977             <a class="code" href="namespacebase.html#a163">GetImplRef</a>(sp) = SP::Default();
00978         }
00979         
<a name="l00980"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn8">00980</a>         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn0">Release</a>(ref&amp; sp)
00981         {
00982             <a class="code" href="namespacebase.html#a163">GetImplRef</a>(sp) = SP::Default();
00983         }
00984         
<a name="l00985"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn9">00985</a>         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn2">Reset</a>(ref&amp; sp, <span class="keyword">typename</span> SP::StoredType p)
00986         { <a class="code" href="classbase_1_1ref.html#base_1_1refa0">ref</a>(p).Swap(sp); }
00987 
<a name="l00988"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa34">00988</a>         PointerType <a class="code" href="classbase_1_1ref.html#base_1_1refa12">operator-&gt;</a>()
00989         {
00990             KP::OnDereference(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>));
00991             <span class="keywordflow">return</span> SP::operator-&gt;();
00992         }
00993 
<a name="l00994"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa35">00994</a>         PointerType <a class="code" href="classbase_1_1ref.html#base_1_1refa12">operator-&gt;</a>()<span class="keyword"> const</span>
00995 <span class="keyword">        </span>{
00996             KP::OnDereference(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>));
00997             <span class="keywordflow">return</span> SP::operator-&gt;();
00998         }
00999 
<a name="l01000"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa36">01000</a>         ReferenceType <a class="code" href="classbase_1_1ref.html#base_1_1refa14">operator*</a>()
01001         {
01002             KP::OnDereference(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>));
01003             <span class="keywordflow">return</span> SP::operator*();
01004         }
01005         
<a name="l01006"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa37">01006</a>         ReferenceType <a class="code" href="classbase_1_1ref.html#base_1_1refa14">operator*</a>()<span class="keyword"> const</span>
01007 <span class="keyword">        </span>{
01008             KP::OnDereference(<a class="code" href="namespacebase.html#a163">GetImplRef</a>(*<span class="keyword">this</span>));
01009             <span class="keywordflow">return</span> SP::operator*();
01010         }
01011 
01012         
<a name="l01013"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa38">01013</a>         <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refa16">operator!</a>() <span class="keyword">const</span> <span class="comment">// Enables "if (!sp) ..."</span>
01014         { <span class="keywordflow">return</span> GetImpl(*<span class="keyword">this</span>) == 0; }
01015         
<a name="l01016"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn10">01016</a>         <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn3">operator==</a>(<span class="keyword">const</span> ref&amp; lhs,
01017             <span class="keyword">const</span> T* rhs)
01018         { <span class="keywordflow">return</span> GetImpl(lhs) == rhs; }
01019         
<a name="l01020"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn11">01020</a>         <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn3">operator==</a>(<span class="keyword">const</span> T* lhs,
01021             <span class="keyword">const</span> ref&amp; rhs)
01022         { <span class="keywordflow">return</span> rhs == lhs; }
01023         
<a name="l01024"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn12">01024</a>         <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn5">operator!=</a>(<span class="keyword">const</span> ref&amp; lhs,
01025             <span class="keyword">const</span> T* rhs)
01026         { <span class="keywordflow">return</span> !(lhs == rhs); }
01027         
<a name="l01028"></a><a class="code" href="classbase_1_1ref.html#base_1_1refn13">01028</a>         <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn5">operator!=</a>(<span class="keyword">const</span> T* lhs,
01029             <span class="keyword">const</span> ref&amp; rhs)
01030         { <span class="keywordflow">return</span> rhs != lhs; }
01031 
01032         <span class="comment">// Ambiguity buster</span>
01033         <span class="keyword">template</span>
01034         &lt;
01035             <span class="keyword">typename</span> T1,
01036             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
01037             <span class="keyword">class </span>CP1,
01038             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
01039             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
01040         &gt;
<a name="l01041"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa39">01041</a>         <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn3">operator==</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">ref&lt;T1, OP1, CP1, KP1, SP1&gt;</a>&amp; rhs)<span class="keyword"> const</span>
01042 <span class="keyword">        </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span> == GetImpl(rhs); }
01043 
01044         <span class="comment">// Ambiguity buster</span>
01045         <span class="keyword">template</span>
01046         &lt;
01047             <span class="keyword">typename</span> T1,
01048             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
01049             <span class="keyword">class </span>CP1,
01050             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
01051             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
01052         &gt;
<a name="l01053"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa40">01053</a>         <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1ref.html#base_1_1refn5">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">ref&lt;T1, OP1, CP1, KP1, SP1&gt;</a>&amp; rhs)<span class="keyword"> const</span>
01054 <span class="keyword">        </span>{ <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == rhs); }
01055 
01056         <span class="comment">// Ambiguity buster</span>
01057         <span class="keyword">template</span>
01058         &lt;
01059             <span class="keyword">typename</span> T1,
01060             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP1,
01061             <span class="keyword">class </span>CP1,
01062             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP1,
01063             <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP1
01064         &gt;
<a name="l01065"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa41">01065</a>         <span class="keywordtype">bool</span> operator&lt;(const ref&lt;T1, OP1, CP1, KP1, SP1&gt;&amp; rhs) <span class="keyword">const</span>
01066         { <span class="keywordflow">return</span> *<span class="keyword">this</span> &lt; GetImpl(rhs); }
01067 
01068     <span class="keyword">private</span>:
01069         <span class="comment">// Helper for enabling 'if (sp)'</span>
01070         <span class="keyword">struct </span>Tester
01071         {
01072             Tester() {}
01073         <span class="keyword">private</span>:
01074             <span class="keywordtype">void</span> operator delete(<span class="keywordtype">void</span>*);
01075         };
01076         
01077     <span class="keyword">public</span>:
01078         <span class="comment">// enable 'if (sp)'</span>
<a name="l01079"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa42">01079</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa20">operator Tester*</a>()<span class="keyword"> const</span>
01080 <span class="keyword">        </span>{
01081             <span class="keywordflow">if</span> (!*<span class="keyword">this</span>) <span class="keywordflow">return</span> 0;
01082             <span class="keyword">static</span> Tester t;
01083             <span class="keywordflow">return</span> &amp;t;
01084         }
01085 
01086     <span class="keyword">private</span>:
01087         <span class="comment">// Helper for disallowing automatic conversion</span>
01088         <span class="keyword">struct </span>Insipid
01089         {
01090             Insipid(PointerType) {}
01091         };
01092         
01093         <span class="keyword">typedef</span> <span class="keyword">typename</span> Select&lt;CP::allow, PointerType, Insipid&gt;::Result
01094             AutomaticConversionResult;
01095     
01096     <span class="keyword">public</span>:        
<a name="l01097"></a><a class="code" href="classbase_1_1ref.html#base_1_1refa43">01097</a>         <a class="code" href="classbase_1_1ref.html#base_1_1refa21">operator AutomaticConversionResult</a>()<span class="keyword"> const</span>
01098 <span class="keyword">        </span>{ <span class="keywordflow">return</span> GetImpl(*<span class="keyword">this</span>); }
01099     };
01100 <span class="comment"></span>
01101 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01102 <span class="comment"></span><span class="comment">// casting operations class template ref</span><span class="comment"></span>
01103 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01104 <span class="comment"></span>
01105     <span class="keyword">template</span> 
01106     &lt;
01107       <span class="keyword">typename</span> Sub,
01108       <span class="keyword">typename</span> Super,
01109       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classOwnershipPolicy.html">OwnershipPolicy</a>,
01110       <span class="keyword">class </span><a class="code" href="classConversionPolicy.html">ConversionPolicy</a>,
01111       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classCheckingPolicy.html">CheckingPolicy</a>,
01112       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classStoragePolicy.html">StoragePolicy</a>
01113     &gt;
01114     <span class="keyword">inline</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;Sub, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt;</a>
01115     <a class="code" href="namespacebase.html#a137">static_cast_ref</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;Super, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt;</a>&amp; r)
01116     {
01117       base::ref &lt;Sub, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt; subref;
01118       <span class="keyword">typedef</span> <a class="code" href="classStoragePolicy.html">StoragePolicy&lt;Sub&gt;</a> DSP;
01119       <span class="keyword">typedef</span> <a class="code" href="classOwnershipPolicy.html">OwnershipPolicy&lt;typename StoragePolicy&lt;Sub&gt;</a>::PointerType&gt; OP;
01120       <span class="keyword">typename</span> DSP::PointerType subp = static_cast&lt;typename DSP::PointerType&gt;(GetImpl(r));
01121       <a class="code" href="namespacebase.html#a163">GetImplRef</a>(subref) = (subp!=0)?subref.OP::Clone(subp):0;
01122       <span class="keywordflow">return</span> subref;
01123     }
01124 
01125     <span class="keyword">template</span> 
01126     &lt;
01127       <span class="keyword">typename</span> Sub,
01128       <span class="keyword">typename</span> Super,
01129       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classOwnershipPolicy.html">OwnershipPolicy</a>,
01130       <span class="keyword">class </span><a class="code" href="classConversionPolicy.html">ConversionPolicy</a>,
01131       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classCheckingPolicy.html">CheckingPolicy</a>,
01132       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classStoragePolicy.html">StoragePolicy</a>
01133     &gt;
01134     <span class="keyword">inline</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;Sub, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt;</a>
01135     <a class="code" href="namespacebase.html#a138">dynamic_cast_ref</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;Super, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt;</a>&amp; r)
01136     {
01137       base::ref &lt;Sub, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt; subref;
01138       <span class="keyword">typedef</span> <a class="code" href="classStoragePolicy.html">StoragePolicy&lt;Sub&gt;</a> DSP;
01139       <span class="keyword">typedef</span> <a class="code" href="classOwnershipPolicy.html">OwnershipPolicy&lt;typename StoragePolicy&lt;Sub&gt;</a>::PointerType&gt; OP;
01140       <span class="keyword">typename</span> DSP::PointerType subp = dynamic_cast&lt;typename DSP::PointerType&gt;(GetImpl(r));
01141       <a class="code" href="namespacebase.html#a163">GetImplRef</a>(subref) = (subp!=0)?subref.OP::Clone(subp):0;
01142       <span class="keywordflow">return</span> subref;
01143     }
01144 
01145 
01146     <span class="keyword">template</span> 
01147     &lt;
01148       <span class="keyword">typename</span> Sub,
01149       <span class="keyword">typename</span> Super,
01150       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classOwnershipPolicy.html">OwnershipPolicy</a>,
01151       <span class="keyword">class </span><a class="code" href="classConversionPolicy.html">ConversionPolicy</a>,
01152       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classCheckingPolicy.html">CheckingPolicy</a>,
01153       <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span><a class="code" href="classStoragePolicy.html">StoragePolicy</a>
01154     &gt;
01155     <span class="keyword">inline</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;Sub, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt;</a>
01156     <span class="comment">// crashes gcc3.2</span>
01157     <span class="comment">//narrow_cast_ref(base::ref&lt; typename Select&lt; SUPERSUBCLASS_STRICT(Super,Sub),Super,NullType&gt;::Result, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt; r)</span>
01158     <a class="code" href="namespacebase.html#a139">narrow_cast_ref</a>(<a class="code" href="classbase_1_1ref.html">base::ref&lt;Super, OwnershipPolicy, ConversionPolicy, CheckingPolicy, StoragePolicy&gt;</a> r)
01159     {
01160       <span class="keywordflow">return</span> dynamic_cast_ref&lt;Sub,Super,OwnershipPolicy,ConversionPolicy,CheckingPolicy,StoragePolicy&gt;(r);
01161     }
01162 
<a name="l01163"></a><a class="code" href="ref_8full.html#a0">01163</a> <span class="preprocessor">#define narrow_ref narrow_cast_ref</span>
01164 <span class="preprocessor"></span>
01165 <span class="comment"></span>
01166 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01167 <span class="comment"></span><span class="comment">// free comparison operators for class template ref</span><span class="comment"></span>
01168 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01169 <span class="comment"></span><span class="comment"></span>
01170 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01171 <span class="comment"></span><span class="comment">// operator== for lhs = ref, rhs = raw pointer</span><span class="comment"></span>
01172 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01173 <span class="comment"></span>
01174     <span class="keyword">template</span>
01175     &lt;
01176         <span class="keyword">typename</span> T,
01177         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01178         <span class="keyword">class </span>CP,
01179         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01180         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01181         <span class="keyword">typename</span> U
01182     &gt;
01183     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a140">operator==</a>(<span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; lhs,
01184         <span class="keyword">const</span> U* rhs)
01185     { <span class="keywordflow">return</span> GetImpl(lhs) == rhs; }
01186     <span class="comment"></span>
01187 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01188 <span class="comment"></span><span class="comment">// operator== for lhs = raw pointer, rhs = ref</span><span class="comment"></span>
01189 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01190 <span class="comment"></span>
01191     <span class="keyword">template</span>
01192     &lt;
01193         <span class="keyword">typename</span> T,
01194         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01195         <span class="keyword">class </span>CP,
01196         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01197         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01198         <span class="keyword">typename</span> U
01199     &gt;
01200     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a140">operator==</a>(<span class="keyword">const</span> U* lhs,
01201         <span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; rhs)
01202     { <span class="keywordflow">return</span> rhs == lhs; }
01203 <span class="comment"></span>
01204 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01205 <span class="comment"></span><span class="comment">// operator!= for lhs = ref, rhs = raw pointer</span><span class="comment"></span>
01206 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01207 <span class="comment"></span>
01208     <span class="keyword">template</span>
01209     &lt;
01210         <span class="keyword">typename</span> T,
01211         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01212         <span class="keyword">class </span>CP,
01213         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01214         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01215         <span class="keyword">typename</span> U
01216     &gt;
01217     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a142">operator!=</a>(<span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; lhs,
01218         <span class="keyword">const</span> U* rhs)
01219     { <span class="keywordflow">return</span> !(lhs == rhs); }
01220     <span class="comment"></span>
01221 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01222 <span class="comment"></span><span class="comment">// operator!= for lhs = raw pointer, rhs = ref</span><span class="comment"></span>
01223 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01224 <span class="comment"></span>
01225     <span class="keyword">template</span>
01226     &lt;
01227         <span class="keyword">typename</span> T,
01228         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01229         <span class="keyword">class </span>CP,
01230         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01231         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01232         <span class="keyword">typename</span> U
01233     &gt;
01234     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a142">operator!=</a>(<span class="keyword">const</span> U* lhs,
01235         <span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; rhs)
01236     { <span class="keywordflow">return</span> rhs != lhs; }
01237 <span class="comment"></span>
01238 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01239 <span class="comment"></span><span class="comment">// operator&lt; for lhs = ref, rhs = raw pointer -- NOT DEFINED</span><span class="comment"></span>
01240 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01241 <span class="comment"></span>
01242     <span class="keyword">template</span>
01243     &lt;
01244         <span class="keyword">typename</span> T,
01245         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01246         <span class="keyword">class </span>CP,
01247         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01248         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01249         <span class="keyword">typename</span> U
01250     &gt;
01251     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const ref&lt;T, OP, CP, KP, SP&gt;&amp; lhs,
01252         <span class="keyword">const</span> U* rhs);
01253         <span class="comment"></span>
01254 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01255 <span class="comment"></span><span class="comment">// operator&lt; for lhs = raw pointer, rhs = ref -- NOT DEFINED</span><span class="comment"></span>
01256 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01257 <span class="comment"></span>
01258     <span class="keyword">template</span>
01259     &lt;
01260         <span class="keyword">typename</span> T,
01261         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01262         <span class="keyword">class </span>CP,
01263         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01264         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01265         <span class="keyword">typename</span> U
01266     &gt;
01267     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a144">operator&lt;</a>(<span class="keyword">const</span> U* lhs,
01268         <span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; rhs);
01269         <span class="comment"></span>
01270 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01271 <span class="comment"></span><span class="comment">// operator&gt; for lhs = ref, rhs = raw pointer -- NOT DEFINED</span><span class="comment"></span>
01272 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01273 <span class="comment"></span>
01274     <span class="keyword">template</span>
01275     &lt;
01276         <span class="keyword">typename</span> T,
01277         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01278         <span class="keyword">class </span>CP,
01279         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01280         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01281         <span class="keyword">typename</span> U
01282     &gt;
01283     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a146">operator&gt;</a>(<span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; lhs,
01284         <span class="keyword">const</span> U* rhs)
01285     { <span class="keywordflow">return</span> rhs &lt; lhs; }
01286         <span class="comment"></span>
01287 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01288 <span class="comment"></span><span class="comment">// operator&gt; for lhs = raw pointer, rhs = ref</span><span class="comment"></span>
01289 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01290 <span class="comment"></span>
01291     <span class="keyword">template</span>
01292     &lt;
01293         <span class="keyword">typename</span> T,
01294         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01295         <span class="keyword">class </span>CP,
01296         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01297         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01298         <span class="keyword">typename</span> U
01299     &gt;
01300     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a146">operator&gt;</a>(<span class="keyword">const</span> U* lhs,
01301         <span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; rhs)
01302     { <span class="keywordflow">return</span> rhs &lt; lhs; }
01303   <span class="comment"></span>
01304 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01305 <span class="comment"></span><span class="comment">// operator&lt;= for lhs = ref, rhs = raw pointer</span><span class="comment"></span>
01306 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01307 <span class="comment"></span>
01308     <span class="keyword">template</span>
01309     &lt;
01310         <span class="keyword">typename</span> T,
01311         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01312         <span class="keyword">class </span>CP,
01313         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01314         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01315         <span class="keyword">typename</span> U
01316     &gt;
01317     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const ref&lt;T, OP, CP, KP, SP&gt;&amp; lhs,
01318         <span class="keyword">const</span> U* rhs)
01319     { <span class="keywordflow">return</span> !(rhs &lt; lhs); }
01320         <span class="comment"></span>
01321 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01322 <span class="comment"></span><span class="comment">// operator&lt;= for lhs = raw pointer, rhs = ref</span><span class="comment"></span>
01323 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01324 <span class="comment"></span>
01325     <span class="keyword">template</span>
01326     &lt;
01327         <span class="keyword">typename</span> T,
01328         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01329         <span class="keyword">class </span>CP,
01330         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01331         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01332         <span class="keyword">typename</span> U
01333     &gt;
01334     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a148">operator&lt;=</a>(<span class="keyword">const</span> U* lhs,
01335         <span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; rhs)
01336     { <span class="keywordflow">return</span> !(rhs &lt; lhs); }
01337 <span class="comment"></span>
01338 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01339 <span class="comment"></span><span class="comment">// operator&gt;= for lhs = ref, rhs = raw pointer</span><span class="comment"></span>
01340 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01341 <span class="comment"></span>
01342     <span class="keyword">template</span>
01343     &lt;
01344         <span class="keyword">typename</span> T,
01345         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01346         <span class="keyword">class </span>CP,
01347         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01348         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01349         <span class="keyword">typename</span> U
01350     &gt;
01351     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a150">operator&gt;=</a>(<span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; lhs,
01352         <span class="keyword">const</span> U* rhs)
01353     { <span class="keywordflow">return</span> !(lhs &lt; rhs); }
01354         <span class="comment"></span>
01355 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01356 <span class="comment"></span><span class="comment">// operator&gt;= for lhs = raw pointer, rhs = ref</span><span class="comment"></span>
01357 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01358 <span class="comment"></span>
01359     <span class="keyword">template</span>
01360     &lt;
01361         <span class="keyword">typename</span> T,
01362         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01363         <span class="keyword">class </span>CP,
01364         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01365         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP,
01366         <span class="keyword">typename</span> U
01367     &gt;
01368     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a150">operator&gt;=</a>(<span class="keyword">const</span> U* lhs,
01369         <span class="keyword">const</span> ref&lt;T, OP, CP, KP, SP&gt;&amp; rhs)
01370     { <span class="keywordflow">return</span> !(lhs &lt; rhs); }
01371 
01372 } <span class="comment">// namespace base</span>
01373 <span class="comment"></span>
01374 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01375 <span class="comment"></span><span class="comment">// specialization of std::less for ref</span><span class="comment"></span>
01376 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01377 <span class="comment"></span>
01378 <span class="keyword">namespace </span>std
01379 {
01380     <span class="keyword">template</span>
01381     &lt;
01382         <span class="keyword">typename</span> T,
01383         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>OP,
01384         <span class="keyword">class </span>CP,
01385         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>KP,
01386         <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>SP
01387     &gt;
01388     <span class="keyword">struct </span>less&lt; <a class="code" href="base_2Jamfile_8ft.html#a0">base</a>::ref&lt;T, OP, CP, KP, SP&gt; &gt;
01389         : <span class="keyword">public</span> <a class="code" href="classbinary__function.html">binary_function</a>&lt;base::ref&lt;T, OP, CP, KP, SP&gt;,
01390             base::ref&lt;T, OP, CP, KP, SP&gt;, bool&gt;
01391     {
<a name="l01392"></a><a class="code" href="structstd_1_1less_3_01base_1_1ref_3_01T_00_01OP_00_01CP_00_01KP_00_01SP_01_4_01_4.html#std_1_1less_3_01base_1_1ref_3_01T_00_01OP_00_01CP_00_01KP_00_01SP_01_4_01_4a1">01392</a>         <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;T, OP, CP, KP, SP&gt;</a>&amp; lhs,
01393             <span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">base::ref&lt;T, OP, CP, KP, SP&gt;</a>&amp; rhs)<span class="keyword"> const</span>
01394 <span class="keyword">        </span>{ <span class="keywordflow">return</span> less&lt;T*&gt;()(GetImpl(lhs), GetImpl(rhs)); }
01395     };
01396 }
01397 <span class="comment"></span>
01398 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01399 <span class="comment"></span><span class="comment">// Change log:</span>
01400 <span class="comment">// June 20, 2001: ported by Nick Thurn to gcc 2.95.3. Kudos, Nick!!!</span><span class="comment"></span>
01401 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
01402 <span class="comment"></span>
01403 <span class="preprocessor">#endif // SMARTPTR_INC_</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:12 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
