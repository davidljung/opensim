<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: gfx/Triangle3.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>gfx/Triangle3.cpp</h1><a href="Triangle3_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Triangle3.cpp 1030 2004-02-11 20:46:17Z jungd $</span>
00019 <span class="comment">  $Revision: 1.3 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:46:17 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;math.h&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="Triangle3.html">gfx/Triangle3</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="Plane.html">gfx/Plane</a>&gt;</span>
00029 
00030 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>;
00031 <span class="keyword">using</span> gfx::Point3;
00032 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Segment3.html">gfx::Segment3</a>;
00033 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Plane.html">gfx::Plane</a>;
00034 
00035 
00036 <a class="code" href="namespacebase.html#a5">Real</a> Triangle3::distanceTo(<span class="keyword">const</span> Point3&amp; p)<span class="keyword"> const</span>
00037 <span class="keyword"></span>{
00038   <span class="keywordflow">return</span> Vector3(p-pointClosestTo(p)).length();
00039 }
00040 
00041   
00042 <span class="comment">// this implementation and its explanation was basically ripped from the XEngine code by Martin Ecker</span>
00043 <span class="comment">//  (email: martin.ecker@liwest.at - see http://xengine.sourceforge.net )</span>
00044 <span class="comment">// it looks a lot like the Magic Software algorithm ( http://www.magic-software.com )</span>
00045 <span class="comment">/*</span>
00046 <span class="comment">        Given a point P and a triangle T(s, t) = B + s * E0 + t * E1 with s and t </span>
00047 <span class="comment">        in [0, 1] and s + t &lt;= 1 we want to find the closest distance of P to T.</span>
00048 <span class="comment">        We want to find the values (s, t) that gives us the closest point on</span>
00049 <span class="comment">        the triangle to P. To do so we have to minimze the squared-distance function</span>
00050 <span class="comment">                Q(s, t) = |T - P|^2</span>
00051 <span class="comment">        This function is quadratic in s and t and is of the form</span>
00052 <span class="comment">                Q(s, t) = as^2 + 2bst + ct^2 + 2ds + 2et + f</span>
00053 <span class="comment">        with</span>
00054 <span class="comment">                a = E0 * E0</span>
00055 <span class="comment">                b = E0 * E1</span>
00056 <span class="comment">                c = E1 * E1</span>
00057 <span class="comment">                d = E0 * (B - P)</span>
00058 <span class="comment">                e = -E1 * (B - P)</span>
00059 <span class="comment">                f = (B - P) * (B - P)</span>
00060 <span class="comment">        Quadratics are classified by the sign of the determinant </span>
00061 <span class="comment">                ac - b^2 = (E0 * E0) * (E1 * E1) - (E0 * E1)^2 = |E0 x E1|^2 &gt; 0</span>
00062 <span class="comment">        The determinant is always &gt; 0 since E0 and E1 are linearly independent</span>
00063 <span class="comment">        and thus the cross product of the two vectors always yields a nonzero</span>
00064 <span class="comment">        vector.</span>
00065 <span class="comment">        The minimum of Q(s, t) either occurs at an interior point or at a</span>
00066 <span class="comment">        boundary of the domain of T(s, t). So we minimize Q(s, t) by determining</span>
00067 <span class="comment">        the gradient dQ(s, t) and calculating s and t where dQ = (0, 0)</span>
00068 <span class="comment">                dQ(s, t) = (2as + 2bt + 2d, 2bs + 2ct + 2e) = (0, 0)</span>
00069 <span class="comment">        which is at</span>
00070 <span class="comment">                s = (be - cd) / (ac - b^2)</span>
00071 <span class="comment">                t = (bd - ae) / (ac - b^2)</span>
00072 <span class="comment">        If (s, t) is an interior point we have found the minimum. Otherwise</span>
00073 <span class="comment">        we must determine the correct boundary of the triangle where the</span>
00074 <span class="comment">        minimum occurs. Consider the following figure:</span>
00075 <span class="comment"></span>
00076 <span class="comment">           t</span>
00077 <span class="comment">           </span>
00078 <span class="comment">        \ 2|</span>
00079 <span class="comment">         \ |</span>
00080 <span class="comment">          \|</span>
00081 <span class="comment">           |\</span>
00082 <span class="comment">           | \  1</span>
00083 <span class="comment">           |  \</span>
00084 <span class="comment">         3 | 0 \</span>
00085 <span class="comment">           |    \</span>
00086 <span class="comment">        --------------- s</span>
00087 <span class="comment">         4 | 5    \ 6</span>
00088 <span class="comment">           |       \</span>
00089 <span class="comment">           |        \</span>
00090 <span class="comment"></span>
00091 <span class="comment">        If (s, t) is in region 0 we have found the minimum. If (s, t) is</span>
00092 <span class="comment">        in region 1 we intersect the graph with the plane s + t = 1 and</span>
00093 <span class="comment">        get the parabola F(s) = Q(s, 1 - s) for s in [0, 1] as curve of </span>
00094 <span class="comment">        intersection that we can minimize. Either the minimum occurs at</span>
00095 <span class="comment">        F'(s) = 0 or at an end point where s = 0 or s = 1. Regions 3 and</span>
00096 <span class="comment">        5 are handled similarly.</span>
00097 <span class="comment">        If (s, t) is in region 2 the minimum could be on the edge s + t = 1</span>
00098 <span class="comment">        or s = 0. Because the global minimum occurs in region 2 the gradient</span>
00099 <span class="comment">        at the corner (0, 1) cannot point inside the triangle.</span>
00100 <span class="comment">        If dQ = (Qs, Qt) with Qs and Qt being the respective partial derivatives</span>
00101 <span class="comment">        of Q, it must be that (0, -1) * dQ(0, 1) and (1, -1) * dQ(0, 1)</span>
00102 <span class="comment">        cannot both be negative and the signs of these values can be used</span>
00103 <span class="comment">        to determine the correct edge. (0, -1) and (1, -1) are direction vectors</span>
00104 <span class="comment">        for the edges s = 0 and s + t = 1. Similar arguments apply to</span>
00105 <span class="comment">        regions 4 and 6.</span>
00106 <span class="comment">*/</span>
00107 <a class="code" href="namespacebase.html#a26">Point3</a> Triangle3::pointClosestTo(<span class="keyword">const</span> Point3&amp; p)<span class="keyword"> const</span>
00108 <span class="keyword"></span>{
00109   <a class="code" href="namespacebase.html#a5">Real</a> s, t;
00110   <a class="code" href="namespacebase.html#a5">Real</a> ds=0; <span class="comment">// squared distance</span>
00111   <span class="comment">// express triangle as T(s, t) = B + s * E0 + t * E1 with s and t in [0, 1] and s + t &lt;= 1.</span>
00112   <a class="code" href="namespacebase.html#a26">Point3</a>  tp = p2(); <span class="comment">// triangle 'point' - B</span>
00113   Vector3 e0 = p1() - tp; <span class="comment">// triangle E0</span>
00114   Vector3 e1 = p3() - tp; <span class="comment">// triangle E1</span>
00115 
00116   Vector3 diff = tp - p;
00117   <a class="code" href="namespacebase.html#a5">Real</a> a = <a class="code" href="namespacebase.html#a209">dot</a>(e0,e0);
00118   <a class="code" href="namespacebase.html#a5">Real</a> b = <a class="code" href="namespacebase.html#a209">dot</a>(e0,e1);
00119   <a class="code" href="namespacebase.html#a5">Real</a> c = <a class="code" href="namespacebase.html#a209">dot</a>(e1,e1);
00120   <a class="code" href="namespacebase.html#a5">Real</a> d = <a class="code" href="namespacebase.html#a209">dot</a>(e0,diff);
00121   <a class="code" href="namespacebase.html#a5">Real</a> e = <a class="code" href="namespacebase.html#a209">dot</a>(e1,diff);
00122   <a class="code" href="namespacebase.html#a5">Real</a> <a class="code" href="Makefile_8in.html#a5">f</a> = <a class="code" href="namespacebase.html#a209">dot</a>(diff,diff);
00123   <a class="code" href="namespacebase.html#a5">Real</a> det = Math::abs(a * c - Math::sqr(b));
00124   s = b * e - c * d;
00125   t = b * d - a * e;
00126   
00127   <span class="keywordflow">if</span> (s + t &lt;= det) {           <span class="comment">// s + t &lt;= 1?</span>
00128     <span class="keywordflow">if</span> (s &lt; 0) {
00129       <span class="keywordflow">if</span> (t &lt; 0) {
00130         <span class="comment">// region 4</span>
00131         <span class="comment">// minimum could be on edge s = 0 or t = 0 depending on the signs of</span>
00132         <span class="comment">// Qs and Qt for dQ(0, 0) = (2d, 2e)</span>
00133         <span class="comment">// s = 0: (0, 1) * dQ(0, 0) = (0, 1) * (2d, 2e) = 2e    if &lt; 0 then minimum on s = 0</span>
00134         <span class="comment">// t = 0: (1, 0) * dQ(0, 0) = (1, 0) * (2d, 2e) = 2d    if &lt; 0 then minimum on t = 0</span>
00135         <span class="keywordflow">if</span> (d &lt; 0) {            <span class="comment">// Qs(0, 0) &lt; 0 ?</span>
00136           <span class="comment">// find minimum on edge t = 0, so minimize</span>
00137           <span class="comment">// F(s) = Q(s, 0) = as^2 + 2ds + f</span>
00138           <span class="comment">// F'(s) = 2as + 2d = 0 ==&gt; s = -d / a</span>
00139           <span class="comment">// since Q(s, 0) &lt; Q(0, 0) for s &gt; 0 we can omit the test for s &gt; 0</span>
00140           t = 0;
00141           <span class="keywordflow">if</span> (-d &gt; a) {         <span class="comment">// s &gt; 1?</span>
00142             s = 1;
00143             ds = a + 2 * d + <a class="code" href="Makefile_8in.html#a5">f</a>;
00144           }
00145           <span class="keywordflow">else</span> {
00146             s = -d / a;
00147             ds = d * s + <a class="code" href="Makefile_8in.html#a5">f</a>;
00148           }
00149         }
00150         <span class="keywordflow">else</span> {
00151           <span class="comment">// find minimum on edge s = 0, so minimize</span>
00152           <span class="comment">// F(t) = Q(0, t) = ct^2 + 2et + f</span>
00153           <span class="comment">// F'(t) = 2ct + 2e = 0 ==&gt; t = -e / c</span>
00154           s = 0;
00155           <span class="keywordflow">if</span> (e &gt;= 0) {                 <span class="comment">// t &lt; 0 ?</span>
00156             t = 0;
00157             ds = <a class="code" href="Makefile_8in.html#a5">f</a>;
00158           }
00159           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (-e &gt; c) {    <span class="comment">// t &gt; 1 ?</span>
00160             t = 1;
00161             ds = c + 2 * e + <a class="code" href="Makefile_8in.html#a5">f</a>;
00162           }
00163           <span class="keywordflow">else</span> {
00164             t = -e / c;
00165             ds = c * t + <a class="code" href="Makefile_8in.html#a5">f</a>;
00166           }
00167         }
00168       }
00169       <span class="keywordflow">else</span> {
00170         <span class="comment">// region 3</span>
00171         <span class="comment">// we must find the minimum on the edge s = 0, so we minimize</span>
00172         <span class="comment">// F(t) = Q(0, t) = ct^2 + 2et + f</span>
00173         <span class="comment">// F'(t) = 2ct + 2e = 0 ==&gt; t = -e / c</span>
00174         s = 0;
00175         <span class="keywordflow">if</span> (e &gt;= 0) {                   <span class="comment">// t &lt; 0 ?</span>
00176           t = 0;
00177           ds = <a class="code" href="Makefile_8in.html#a5">f</a>;
00178         }
00179         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (-e &gt; c) {      <span class="comment">// t &gt; 1 ?</span>
00180           t = 1;
00181           ds = c + 2 * e + <a class="code" href="Makefile_8in.html#a5">f</a>;
00182         }
00183         <span class="keywordflow">else</span> {
00184           t = -e / c;
00185           ds = c * t + <a class="code" href="Makefile_8in.html#a5">f</a>;
00186         }
00187       }
00188     }
00189     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t &lt; 0) {
00190       <span class="comment">// region 5</span>
00191       <span class="comment">// find minimum on the edge t = 0, so we minimize</span>
00192       <span class="comment">// F(s) = Q(s, 0) = as^2 + 2ds + f</span>
00193       <span class="comment">// F'(s) = 2as + 2d = 0 ==&gt; s = -d / a</span>
00194       t = 0;
00195       <span class="keywordflow">if</span> (d &gt;= 0) {             <span class="comment">// s &lt; 0?</span>
00196         s = 0;
00197         ds = <a class="code" href="Makefile_8in.html#a5">f</a>;
00198       }
00199       <span class="keywordflow">if</span> (-d &gt; a) {             <span class="comment">// s &gt; 1?</span>
00200         s = 1;
00201         ds = a + 2 * d + <a class="code" href="Makefile_8in.html#a5">f</a>;
00202       }
00203       <span class="keywordflow">else</span> {
00204         s = -d / a;
00205         ds = d * s + <a class="code" href="Makefile_8in.html#a5">f</a>;
00206       }
00207     }
00208     <span class="keywordflow">else</span> {
00209       <span class="comment">// region 0</span>
00210       <span class="comment">// we have an interior point, so just use s and t in </span>
00211       <span class="comment">// Q(s, t) = as^2 + 2bst + ct^2 + 2ds + 2et + f</span>
00212       det = 1 / det;
00213       s *= det;
00214       t *= det;
00215       ds = <a class="code" href="Makefile_8in.html#a5">f</a> + s * (a * s + 2 * (b * t + 2 * d)) + t * (c * t + 2 * e);
00216     }
00217   }
00218   <span class="keywordflow">else</span> {        <span class="comment">// s + t &gt; 1</span>
00219     <span class="keywordflow">if</span> (s &lt; 0) {
00220       <span class="comment">// region 2</span>
00221       <span class="comment">// minimum could be on edge s = 0 or s + t = 1, depending on the sign of</span>
00222       <span class="comment">// s = 0: (0, -1) * dQ(0, 1) = (0, -1) * (2b + 2d, 2c + 2e) = -2 * (c + e)                if &lt; 0 then minimum on s = 0</span>
00223       <span class="comment">// s + t = 1: (1, -1) * dQ(0, 1) = (1, -1) * (2b + 2d, 2c + 2e) = 2 * ((b + d) - (c + e))         if &lt; 0 then minimum is on s + t = 1</span>
00224       
00225       <a class="code" href="namespacebase.html#a5">Real</a> bd = b + d;
00226       <a class="code" href="namespacebase.html#a5">Real</a> ce = c + e;
00227       <span class="keywordflow">if</span> (bd &lt; ce) {
00228         <span class="comment">// minimum on s + t = 1</span>
00229         <span class="comment">// F(s) = Q(s, 1 - s) = (a - 2b + c)s^2 + 2(b - c + d - e)s + c + 2e + f</span>
00230         <span class="comment">// F'(s) = 2(a - 2b + c)s + 2(b - c + d - e) = 0 ==&gt; s = (c + e - b - d) / (a - 2b + c)</span>
00231         <a class="code" href="namespacebase.html#a5">Real</a> temp = ce - bd;
00232         <a class="code" href="namespacebase.html#a5">Real</a> temp2 = a - 2 * b + c;
00233         <span class="keywordflow">if</span> (temp &gt; temp2) {             <span class="comment">// s &gt; 1?</span>
00234           s = 1;
00235           t = 0;
00236           ds = a + 2 * d + <a class="code" href="Makefile_8in.html#a5">f</a>;
00237         }
00238         <span class="keywordflow">else</span> {
00239           s = temp / temp2;
00240           t = 1 - s;
00241           ds = <a class="code" href="Makefile_8in.html#a5">f</a> + s * (a + 2 * (b * t + d)) + t * (c * t + 2 * e);
00242         }
00243       }
00244       <span class="keywordflow">else</span> {
00245         <span class="comment">// minimum on s = 0, so we minimize</span>
00246         <span class="comment">// F(t) = Q(0, t) = ct^2 + 2et + f</span>
00247         <span class="comment">// F'(t) = 2ct + 2e = 0 ==&gt; t = -e / c</span>
00248         s = 0;
00249         <span class="keywordflow">if</span> (e &gt;= 0) {                   <span class="comment">// t &lt; 0 ?</span>
00250           t = 0;
00251           ds = <a class="code" href="Makefile_8in.html#a5">f</a>;
00252         }
00253         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (-e &gt; c) {      <span class="comment">// t &gt; 1 ?</span>
00254           t = 1;
00255           ds = c + 2 * e + <a class="code" href="Makefile_8in.html#a5">f</a>;
00256         }
00257         <span class="keywordflow">else</span> {
00258           t = -e / c;
00259           ds = c * t + <a class="code" href="Makefile_8in.html#a5">f</a>;
00260         }
00261       }
00262     }
00263     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t &lt; 0) {
00264       <span class="comment">// region 6</span>
00265       <span class="comment">// minimum could be on edge s + t = 1 or t = 0</span>
00266       <span class="comment">// t = 0: (-1, 0) * dQ(1, 0) = (-1, 0) * (2a + 2d, 2b + 2e) = -2 * (a + d)                if &lt; 0 then minimum on t = 0</span>
00267       <span class="comment">// s + t = 1: (-1, 1) * dQ(1, 0) = (-1, 1) * (2a + 2d, 2b + 2e) = -2 * (a + d) + 2 * (b + e)              if &lt; 0 then minimum on s + t = 1</span>
00268       <a class="code" href="namespacebase.html#a5">Real</a> ad = a + d;
00269       <a class="code" href="namespacebase.html#a5">Real</a> be = b + e;
00270       <span class="keywordflow">if</span> (be &lt; ad) {
00271         <span class="comment">// minimum is on s + t = 1</span>
00272         <span class="comment">// F(t) = Q(1 - t, t) = (a - 2b + c)t^2 + 2(b - a - d + e)t + a + 2d + f</span>
00273         <span class="comment">// F'(t) = 2(a - 2b + c)t + 2(b - a - d + e) = 0 ==&gt; t = (a + d - b - e) / (a - 2b + c)</span>
00274         <a class="code" href="namespacebase.html#a5">Real</a> temp = ad - be;
00275         <a class="code" href="namespacebase.html#a5">Real</a> temp2 = a - 2 * b + c;
00276         <span class="keywordflow">if</span> (temp &gt; temp2) {             <span class="comment">// t &gt; 1?</span>
00277           t = 1;
00278           s = 0;
00279           ds = c + 2 * e + <a class="code" href="Makefile_8in.html#a5">f</a>;
00280         }
00281         <span class="keywordflow">else</span> {
00282           t = temp / temp2;
00283           s = 1 - t;
00284           ds = <a class="code" href="Makefile_8in.html#a5">f</a> + s * (a + 2 * (b * t + d)) + t * (c * t + 2 * e);
00285         }
00286       }
00287       <span class="keywordflow">else</span> {
00288         <span class="comment">// minimum is on t = 0, so we minimize</span>
00289         <span class="comment">// F(s) = Q(s, 0) = as^2 + 2ds + f</span>
00290         <span class="comment">// F'(s) = 2as + 2d = 0 ==&gt; s = -d / a</span>
00291         t = 0;
00292         <span class="keywordflow">if</span> (d &gt;= 0) {           <span class="comment">// s &lt; 0?</span>
00293           s = 0;
00294           ds = <a class="code" href="Makefile_8in.html#a5">f</a>;
00295         }
00296         <span class="keywordflow">if</span> (-d &gt; a) {           <span class="comment">// s &gt; 1?</span>
00297           s = 1;
00298           ds = a + 2 * d + <a class="code" href="Makefile_8in.html#a5">f</a>;
00299         }
00300         <span class="keywordflow">else</span> {
00301           s = -d / a;
00302           ds = d * s + <a class="code" href="Makefile_8in.html#a5">f</a>;
00303         }
00304       }
00305     }
00306     <span class="keywordflow">else</span> {
00307       <span class="comment">// region 1</span>
00308       <span class="comment">// minimum on edge s + t = 1 so we minimize</span>
00309       <span class="comment">// F(s) = Q(s, 1 - s) = (a - 2b + c)s^2 + 2(b - c + d - e)s + c + 2e + f</span>
00310       <span class="comment">// F'(s) = 2(a - 2b + c)s + 2(b - c + d - e) = 0 ==&gt; s = (c + e - b - d) / (a - 2b + c)</span>
00311       <a class="code" href="namespacebase.html#a5">Real</a> temp = c + e - b - d;
00312       <span class="keywordflow">if</span> (temp &lt; 0) {           <span class="comment">// s &lt; 0?</span>
00313         s = 0;
00314         t = 1;
00315         ds = c + 2 * e + <a class="code" href="Makefile_8in.html#a5">f</a>;
00316       }
00317       <span class="keywordflow">else</span> {
00318         <a class="code" href="namespacebase.html#a5">Real</a> temp2 = a - 2 * b + c;
00319         <span class="keywordflow">if</span> (temp &gt; temp2)               <span class="comment">// s &gt; 1?</span>
00320         {
00321           s = 1;
00322           t = 0;
00323           ds = a + 2 * d + <a class="code" href="Makefile_8in.html#a5">f</a>;
00324         }
00325         <span class="keywordflow">else</span> {
00326           s = temp / temp2;
00327           t = 1 - s;
00328           ds = <a class="code" href="Makefile_8in.html#a5">f</a> + s * (a + 2 * (b * t + d)) + t * (c * t + 2 * e);
00329         }
00330       }
00331     }
00332   }
00333   
00334   
00335   ds = Math::abs(ds);
00336   <span class="keywordflow">return</span> tp + s * e0 + t * e1;
00337 }
00338 
00339 
00340 
00341 
00342 
00343 <span class="comment">// this implementation and its explanation was basically ripped from the XEngine code by Martin Ecker</span>
00344 <span class="comment">//  (email: martin.ecker@liwest.at - see http://xengine.sourceforge.net )</span>
00345 <span class="comment">// it looks a lot like the Magic Software algorithm ( http://www.magic-software.com )</span>
00346 <span class="comment">/* </span>
00347 <span class="comment">        The problem of computing the minimal squared distance between a segment and</span>
00348 <span class="comment">        a triangle is very similar to the one of calculating the distance between</span>
00349 <span class="comment">        a line and a triangle.</span>
00350 <span class="comment">        However the domain for the parameter r of the segment this time is r in [0, 1].</span>
00351 <span class="comment">        Therefore we get more regions when partitioning the space spanned by (s, t, r)</span>
00352 <span class="comment">        into regions. </span>
00353 <span class="comment">        Consider the following two figures:</span>
00354 <span class="comment"></span>
00355 <span class="comment">           t                           t</span>
00356 <span class="comment">           </span>
00357 <span class="comment">        \ 2|                           |       |</span>
00358 <span class="comment">         \ |                      3n-2n|  3-2  |3p-2p</span>
00359 <span class="comment">          \|                           |       |</span>
00360 <span class="comment">           |\                  --------|-----------------</span>
00361 <span class="comment">           | \                         |       |</span>
00362 <span class="comment">           |  \                        |       |</span>
00363 <span class="comment">         3 | 0 \  1            3n-0n-1n| 3-0-1 |3p-0p-1p</span>
00364 <span class="comment">           |    \                      |       |</span>
00365 <span class="comment">        ---r----------- s      --------s----------------- r</span>
00366 <span class="comment">           |      \                    |       |</span>
00367 <span class="comment">         4 | 5     \ 6            4n-5n|  4-5  |4p-5p</span>
00368 <span class="comment">           |        \                  |       |</span>
00369 <span class="comment"></span>
00370 <span class="comment">        The first figure shows a cut with the s-t plane and shows the regions</span>
00371 <span class="comment">        we got with line-to-triangle distance calculation. The second figure</span>
00372 <span class="comment">        shows a cut with the t-r plane and shows the new regions we get since</span>
00373 <span class="comment">        the prism that represents region 0 is no longer an infinite prism but</span>
00374 <span class="comment">        a finite prism along the positive r-axis where r in [0, 1]. </span>
00375 <span class="comment">        The 7 regions where r &lt; 0 have the same names as the regions where r</span>
00376 <span class="comment">        is in [0, 1] except that they have an additional letter n for negative.</span>
00377 <span class="comment">        The 7 regions where r &gt; 1 have the same names as the regions where r</span>
00378 <span class="comment">        is in [0, 1] except that they have an additional letter p for positive.</span>
00379 <span class="comment">*/</span>
00380 Segment3 Triangle3::shortestSegmentBetween(<span class="keyword">const</span> Segment3&amp; seg, Real&amp; ds)<span class="keyword"> const</span>
00381 <span class="keyword"></span>{
00382   <a class="code" href="namespacebase.html#a5">Real</a> s, t, r;
00383   ds=0; <span class="comment">// distance squared</span>
00384 
00385   <span class="comment">// express triangle as T(s, t) = B + s * E0 + t * E1 with s and t in [0, 1] and s + t &lt;= 1.</span>
00386   <a class="code" href="namespacebase.html#a26">Point3</a>  tp = _p2; <span class="comment">// triangle 'point' - B</span>
00387   Vector3 e0 = _p1 - _p2; <span class="comment">// triangle edge 0</span>
00388   Vector3 e1 = _p3 - _p2; <span class="comment">// triangle edge 1</span>
00389   Vector3 diff = _p2 - seg.s;
00390   Vector3 segdir = seg.e-seg.s; <span class="comment">// seg direction</span>
00391   <a class="code" href="namespacebase.html#a26">Point3</a> p1,p2; <span class="comment">// between segment end-points</span>
00392   <a class="code" href="namespacebase.html#a5">Real</a> a00 = <a class="code" href="namespacebase.html#a209">dot</a>(e0,e0);
00393   <a class="code" href="namespacebase.html#a5">Real</a> a11 = <a class="code" href="namespacebase.html#a209">dot</a>(e1,e1);
00394   <a class="code" href="namespacebase.html#a5">Real</a> a22 = <a class="code" href="namespacebase.html#a209">dot</a>(segdir,segdir);
00395   <a class="code" href="namespacebase.html#a5">Real</a> a01 = <a class="code" href="namespacebase.html#a209">dot</a>(e0,e1);
00396   <a class="code" href="namespacebase.html#a5">Real</a> a02 = -<a class="code" href="namespacebase.html#a209">dot</a>(e0,segdir);
00397   <a class="code" href="namespacebase.html#a5">Real</a> a12 = -<a class="code" href="namespacebase.html#a209">dot</a>(e1,segdir);
00398   <a class="code" href="namespacebase.html#a5">Real</a> b0 = <a class="code" href="namespacebase.html#a209">dot</a>(e0,diff);
00399   <a class="code" href="namespacebase.html#a5">Real</a> b1 = <a class="code" href="namespacebase.html#a209">dot</a>(e1,diff);
00400   <a class="code" href="namespacebase.html#a5">Real</a> b2 = -<a class="code" href="namespacebase.html#a209">dot</a>(segdir,diff);
00401   
00402   <span class="comment">// cofactors for calculating the determinant and later on to invert A</span>
00403   <a class="code" href="namespacebase.html#a5">Real</a> cf00 = a11 * a22 - a12 * a12;
00404   <a class="code" href="namespacebase.html#a5">Real</a> cf01 = a02 * a12 - a22 * a01;
00405   <a class="code" href="namespacebase.html#a5">Real</a> cf02 = a01 * a12 - a02 * a11;
00406   <a class="code" href="namespacebase.html#a5">Real</a> det = a00 * cf00 + a01 * cf01 + a02 * cf02;
00407   
00408   <span class="keywordflow">if</span> (Math::abs(det) &gt;= consts::epsilon)                <span class="comment">// det != 0?</span>
00409   {
00410     <span class="comment">// to be able to invert A we need some more cofactors</span>
00411     <a class="code" href="namespacebase.html#a5">Real</a> cf11 = a00 * a22 - a02 * a02;
00412     <a class="code" href="namespacebase.html#a5">Real</a> cf12 = a02 * a01 - a00 * a12;
00413     <a class="code" href="namespacebase.html#a5">Real</a> cf22 = a00 * a11 - a01 * a01;
00414     
00415     det = 1 / det;
00416     s = (-b0 * cf00 - b1 * cf01 - b2 * cf02) * det;
00417     t = (-b0 * cf01 - b1 * cf11 - b2 * cf12) * det;
00418     r = (-b0 * cf02 - b1 * cf12 - b2 * cf22) * det;
00419     
00420     <span class="keywordflow">if</span> (s + t &lt;= 1) {
00421       <span class="keywordflow">if</span> (s &lt; 0) {
00422         <span class="keywordflow">if</span> (t &lt; 0) {
00423           <span class="comment">// region 4 or 4n or 4p</span>
00424           <span class="comment">// the minimum is either on face s = 0 or t = 0 or r = 0/1</span>
00425           Segment3 segment1(_p2, _p1);
00426           Segment3 segment2(_p2, _p3);
00427           Segment3 sb1(segment1.shortestSegmentBetween(seg));
00428           Segment3 sb2(segment2.shortestSegmentBetween(seg));
00429           <a class="code" href="namespacebase.html#a5">Real</a> ds1 = sb1.norm();
00430           <a class="code" href="namespacebase.html#a5">Real</a> ds2 = sb2.norm();
00431           <span class="keywordflow">if</span> (ds1 &lt; ds2) {
00432             ds = ds1;
00433             p1 = sb1.s; p2 = sb1.e;
00434           }
00435           <span class="keywordflow">else</span> {
00436             ds = ds2;
00437             p1 = sb2.s; p2 = sb2.e;
00438           }
00439         }
00440         <span class="keywordflow">else</span> {
00441           <span class="comment">// region 3 or 3n or 3p</span>
00442           <span class="comment">// the minimum is on the face s = 0 or r = 0/1</span>
00443           Segment3 sb = seg.shortestSegmentBetween(Segment3(_p2, _p3), ds);
00444           p1 = sb.e; p2 = sb.s;
00445         }
00446       }
00447       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t &lt; 0) {
00448         <span class="comment">// region 5 or 5n or 5p</span>
00449         <span class="comment">// the minimum is on the face t = 0 or r = 0/1</span>
00450         Segment3 sb = seg.shortestSegmentBetween(Segment3(_p2, _p1), ds);
00451         p1 = sb.e; p2 = sb.s;
00452       }
00453       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r &gt;= 0 &amp;&amp; r &lt;= 1) {
00454         <span class="comment">// region 0</span>
00455         <a class="code" href="namespacebase.html#a5">Real</a> c = <a class="code" href="namespacebase.html#a209">dot</a>(diff,diff);
00456         ds = s * (a00 * s + 2 * (a01 * t + a02 * r + b0)) + 
00457         t * (a11 * t + 2 * (a12 * r + b1)) +
00458         r * (a22 * r + 2 * b2) + c;
00459         
00460         p1 = seg.s + r * segdir;
00461         p2 = tp + s * e0 + t * e1;
00462       }                 
00463     }
00464     <span class="keywordflow">else</span> {
00465       <span class="keywordflow">if</span> (s &lt; 0) {
00466         <span class="comment">// region 1 or 2n or 2p</span>
00467         <span class="comment">// the minimum is either on the face s = 0 or s + t = 1 or r = 0/1</span>
00468         Segment3 segment1(_p2, _p3);
00469         Segment3 segment2(_p1, _p3);
00470         Segment3 sb1(segment1.shortestSegmentBetween(seg));
00471         Segment3 sb2(segment1.shortestSegmentBetween(seg));
00472         <a class="code" href="namespacebase.html#a5">Real</a> ds1 = sb1.norm();
00473         <a class="code" href="namespacebase.html#a5">Real</a> ds2 = sb2.norm();
00474         <span class="keywordflow">if</span> (ds1 &lt; ds2) {
00475           ds = ds1;
00476           p1 = sb1.s; p2 = sb1.e;
00477         }
00478         <span class="keywordflow">else</span> {
00479           ds = ds2;
00480           p1 = sb2.s; p2 = sb2.e;
00481         }
00482       }
00483       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t &lt; 0) {
00484         <span class="comment">// region 6n</span>
00485         <span class="comment">// the minimum is either on the face t = 0 or s + t = 1 or r = 0/1</span>
00486         Segment3 segment1(_p2, _p1);
00487         Segment3 segment2(_p1, _p3);
00488         Segment3 sb1(segment1.shortestSegmentBetween(seg));
00489         Segment3 sb2(segment1.shortestSegmentBetween(seg));
00490         <a class="code" href="namespacebase.html#a5">Real</a> ds1 = sb1.norm();
00491         <a class="code" href="namespacebase.html#a5">Real</a> ds2 = sb2.norm();
00492         <span class="keywordflow">if</span> (ds1 &lt; ds2) {
00493           ds = ds1;
00494           p1 = sb1.s; p2 = sb1.e;
00495         }
00496         <span class="keywordflow">else</span> {
00497           ds = ds2;
00498           p1 = sb2.s; p2 = sb2.e;
00499         }
00500       }
00501       <span class="keywordflow">else</span> {
00502         <span class="comment">// region 1 or 1n or 1p</span>
00503         <span class="comment">// minimum is on face s + t = 1 or r = 0/1</span>
00504         Segment3 segment1(_p1, _p3);
00505         Segment3 sb = segment1.shortestSegmentBetween(seg, ds);
00506         p1 = sb.s; p2 = sb.e;
00507       }
00508     }
00509     
00510     <span class="comment">// if r outside [0, 1] the minimum might be on r = 0 or r = 1</span>
00511     <span class="keywordflow">if</span> (r &lt; 0 || r &gt; 1) {
00512       <span class="comment">// determine squared distance from start-point or end-point of the segment to the triangle</span>
00513       <span class="comment">// this is for face r = 0 or r = 1 depending on the value of r</span>
00514       <a class="code" href="namespacebase.html#a26">Point3</a> p1temp, p2temp;
00515       <a class="code" href="namespacebase.html#a5">Real</a> distTemp;
00516       <span class="keywordflow">if</span> (r &lt; 0) {
00517         Segment3 sb(pointClosestTo(seg.s), seg.s);
00518         distTemp = sb.norm();
00519         p1temp = sb.s; p2temp = sb.e;
00520       }
00521       <span class="keywordflow">else</span> {
00522         Segment3 sb(pointClosestTo(seg.e), seg.e);
00523         distTemp = sb.norm();
00524         p1temp = sb.s; p2temp = sb.e;
00525       }
00526       <span class="keywordflow">if</span> (distTemp &lt; ds || (s &gt;= 0 &amp;&amp; t &gt;= 0)) {        <span class="comment">// the part after || is for region 0n or 0p where the minimum is on r = 0 or r = 1</span>
00527         ds = distTemp;
00528         p1 = p1temp;
00529         p2 = p2temp;
00530       }
00531     }
00532   }
00533   <span class="keywordflow">else</span> {
00534     <span class="comment">// segment and triangle are parallel, so we'll just compute the minimum </span>
00535     <span class="comment">// distance of the segment to each of the three triangle edges and of the segment end-points to the triangle</span>
00536     Segment3 segment1(_p2, _p1);
00537     Segment3 segment2(_p2, _p3);
00538     Segment3 segment3(_p1, _p3);
00539     Segment3 sb1(segment1.shortestSegmentBetween(seg));
00540     Segment3 sb2(segment2.shortestSegmentBetween(seg));
00541     Segment3 sb3(segment3.shortestSegmentBetween(seg));
00542     <a class="code" href="namespacebase.html#a5">Real</a> ds1 = sb1.norm();
00543     <a class="code" href="namespacebase.html#a5">Real</a> ds2 = sb2.norm();
00544     <a class="code" href="namespacebase.html#a5">Real</a> ds3 = sb3.norm();
00545     <span class="keywordflow">if</span> (ds1 &lt; ds2) {
00546       <span class="keywordflow">if</span> (ds1 &lt; ds3) {
00547         ds = ds1;
00548         p1 = sb1.s; p2 = sb1.e;
00549       }
00550       <span class="keywordflow">else</span> {
00551         ds = ds3;
00552         p1 = sb3.s; p2 = sb3.e;
00553       }
00554     }
00555     <span class="keywordflow">else</span> { <span class="comment">// ds2 &lt; ds1</span>
00556       <span class="keywordflow">if</span> (ds2 &lt; ds3) {
00557         ds = ds2;
00558         p1 = sb2.s; p2 = sb2.e;
00559       }
00560       <span class="keywordflow">else</span> {
00561         ds = ds3;
00562         p1 = sb3.s; p2 = sb3.e;
00563       }
00564     }
00565     
00566     <a class="code" href="namespacebase.html#a26">Point3</a> p1temp, p2temp;
00567     Segment3 sbp(pointClosestTo(seg.s), seg.s);
00568     <a class="code" href="namespacebase.html#a5">Real</a> distTemp = sbp.norm();
00569     p1temp = sbp.s; p2temp = sbp.e;
00570     <span class="keywordflow">if</span> (distTemp &lt; ds) {
00571       ds = distTemp;
00572       p1 = p1temp;
00573       p2 = p2temp;
00574     }
00575     Segment3 sbp2(pointClosestTo(seg.e), seg.e);
00576     distTemp = sbp2.norm();
00577     p1temp = sbp2.s; p2temp = sbp2.e;
00578     <span class="keywordflow">if</span> (distTemp &lt; ds) {
00579       ds = distTemp;
00580       p1 = p1temp;
00581       p2 = p2temp;
00582     }
00583   }
00584   
00585   
00586   ds = Math::abs(ds);
00587 
00588   <span class="comment">//Assert(this-&gt;contains(p1)); // can fail is interpenetration</span>
00589   <span class="comment">//Assert(seg.contains(p2));</span>
00590   
00591   <span class="keywordflow">return</span> Segment3(p1,p2);
00592 }
00593 
00594 
00595 
00596 Segment3 Triangle3::shortestSegmentBetween(<span class="keyword">const</span> Triangle3&amp; t)<span class="keyword"> const</span>
00597 <span class="keyword"></span>{
00598   <span class="comment">// compare the shortest distance between each edge of this with t</span>
00599   <span class="comment">//  and each edge of t with this</span>
00600   Segment3 t11(p1(), p2());
00601   Segment3 t12(p2(), p3());
00602   Segment3 t13(p3(), p1());
00603   
00604   Segment3 t21(t.p1(), t.p2());
00605   Segment3 t22(t.p2(), t.p3());
00606   Segment3 t23(t.p3(), t.p1());
00607 
00608   Segment3 seg = shortestSegmentBetween(t21);
00609   Segment3 shortest = seg;
00610   
00611   seg = shortestSegmentBetween(t22);
00612   <span class="keywordflow">if</span> (seg.norm() &lt; shortest.norm()) shortest = seg;
00613   
00614   seg = shortestSegmentBetween(t23);
00615   <span class="keywordflow">if</span> (seg.norm() &lt; shortest.norm()) shortest = seg;
00616   
00617   seg = t.shortestSegmentBetween(t11);
00618   <span class="keywordflow">if</span> (seg.norm() &lt; shortest.norm()) shortest = seg;
00619 
00620   seg = t.shortestSegmentBetween(t12);
00621   <span class="keywordflow">if</span> (seg.norm() &lt; shortest.norm()) shortest = seg;
00622 
00623   seg = t.shortestSegmentBetween(t13);
00624   <span class="keywordflow">if</span> (seg.norm() &lt; shortest.norm()) shortest = seg;
00625 
00626   <span class="keywordflow">return</span> shortest;
00627 }
00628   
00629   
00630 <a class="code" href="namespacebase.html#a5">Real</a> Triangle3::distanceTo(<span class="keyword">const</span> Triangle3&amp; t)<span class="keyword"> const</span>
00631 <span class="keyword"></span>{
00632   <span class="keywordflow">return</span> shortestSegmentBetween(t).length();
00633 }
00634 
00635 
00636 
00637 
00638 
00639 
00640 
00641 
00642 <span class="comment">// helper class for computing triangle intersections</span>
00643 <span class="keyword">namespace </span><a class="code" href="gfx_2Jamfile_8ft.html#a0">gfx</a> {
00644 
<a name="l00645"></a><a class="code" href="classgfx_1_1TriangleDesc.html">00645</a> <span class="keyword">class </span><a class="code" href="classgfx_1_1TriangleDesc.html">TriangleDesc</a> : <span class="keyword">public</span> <a class="code" href="classgfx_1_1Triangle3.html">Triangle3</a>
00646 {
00647 <span class="keyword">public</span>:
<a name="l00648"></a><a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesca0">00648</a>   <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesca0">TriangleDesc</a>(<span class="keyword">const</span> <a class="code" href="classgfx_1_1Triangle3.html">Triangle3</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Plane.html">Plane</a>&amp; p)
00649     : <a class="code" href="classgfx_1_1Triangle3.html">Triangle3</a>(t) 
00650   {
00651     <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">Vector3</a>&amp; n=p.<a class="code" href="classgfx_1_1Plane.html#gfx_1_1Planeo0">normal</a>;
00652     <a class="code" href="classbase_1_1Vector3.html">Vector3</a> a(base::abs(n.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>),base::abs(n.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>),base::abs(n.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>));
00653     <span class="keywordflow">if</span> (a.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>&gt;a.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>) {
00654       <span class="keywordflow">if</span> (a.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>&gt;a.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>) { <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>=2; <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>=3; }
00655       <span class="keywordflow">else</span>         { <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>=1; <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>=2; }
00656     }
00657     <span class="keywordflow">else</span> {
00658       <span class="keywordflow">if</span> (a.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>&gt;a.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>) { <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>=1; <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>=3; }
00659       <span class="keywordflow">else</span>         { <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>=1; <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>=2; }
00660     }
00661   }
00662   
<a name="l00663"></a><a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesca1">00663</a>   <span class="keywordtype">bool</span> <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesca1">pointInTri</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">Vector3</a>&amp; P)<span class="keyword"> const</span>
00664 <span class="keyword">  </span>{
00665     <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">Point3</a>&amp; v1( (*<span class="keyword">this</span>)[1] );
00666     <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">Point3</a>&amp; v2( (*<span class="keyword">this</span>)[2] );
00667     <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">Point3</a>&amp; v3( (*<span class="keyword">this</span>)[3] );
00668     <a class="code" href="classbase_1_1Vector3.html">Vector3</a> u(P[<a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>]-v1[<a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>],
00669               v2[i1]-v1[i1],
00670               v3[i1]-v1[i1]);
00671     <a class="code" href="classbase_1_1Vector3.html">Vector3</a> v(P[<a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>]-v1[<a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>],
00672               v2[i2]-v1[i2],
00673               v3[i2]-v1[i2]);
00674     Real a,b;
00675     <span class="keywordflow">if</span> (u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>==0.0) {
00676       b=u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>/u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>;
00677       <span class="keywordflow">if</span> (b&gt;=0.0 &amp;&amp; b&lt;=1.0) a=(v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>-b*v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>)/v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>;
00678       <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
00679     }
00680     <span class="keywordflow">else</span> {
00681       b=(v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>-u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>*v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>)/(v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>-u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>*v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>);
00682       <span class="keywordflow">if</span> (b&gt;=0.0 &amp;&amp; b&lt;=1.0) a=(u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a>-b*u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o2">z</a>)/u.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o1">y</a>;
00683       <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
00684     }
00685     <span class="keywordflow">return</span> (a&gt;=0 &amp;&amp; (a+b)&lt;=1);
00686   }
00687   
00688   <span class="comment">// A more forgiving version</span>
<a name="l00689"></a><a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesca2">00689</a>   <span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">Point3</a>&amp; <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesca2">operator[] </a>(Int i) <span class="keyword">const</span> <span class="keywordflow">throw</span>()
00690   {
00691     SInt zi = i-1;
00692     <span class="keywordflow">if</span> (zi&lt;0) zi += 3;
00693     zi = zi%3;
00694     
00695     <span class="keywordflow">switch</span> (zi) {
00696     <span class="keywordflow">case</span> 0: <span class="keywordflow">return</span> <a class="code" href="classgfx_1_1Triangle3.html#gfx_1_1TriangleDesca11">at</a>(1);
00697     <span class="keywordflow">case</span> 1: <span class="keywordflow">return</span> <a class="code" href="classgfx_1_1Triangle3.html#gfx_1_1TriangleDesca11">at</a>(2);
00698     <span class="keywordflow">case</span> 2: <span class="keywordflow">return</span> <a class="code" href="classgfx_1_1Triangle3.html#gfx_1_1TriangleDesca11">at</a>(3);
00699     <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <a class="code" href="classgfx_1_1Triangle3.html#gfx_1_1TriangleDesca11">at</a>(1); <span class="comment">// never</span>
00700     }
00701   }
00702         
<a name="l00703"></a><a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">00703</a>   Int <a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco0">i1</a>,<a class="code" href="classgfx_1_1TriangleDesc.html#gfx_1_1TriangleDesco1">i2</a>;
00704 };
00705   
00706 }<span class="comment">// gfx</span>
00707 
00708 <span class="keyword">using</span> <a class="code" href="classgfx_1_1TriangleDesc.html">gfx::TriangleDesc</a>;
00709 
00710 
00711 <span class="comment">// </span>
00712 <span class="comment">// Some 'C' triangle intersection code</span>
00713 <span class="comment">//</span>
00714 <span class="comment">// The implementation of Triangle follows at the bottom</span>
00715 
00716 
00717 
00718 
00719 <span class="comment">/* Triangle/triangle intersection test routine,</span>
00720 <span class="comment"> * by Tomas Moller, 1997.</span>
00721 <span class="comment"> * See article "A Fast Triangle-Triangle Intersection Test",</span>
00722 <span class="comment"> * Journal of Graphics Tools, 2(2), 1997</span>
00723 <span class="comment"> * updated: 2001-06-20 (added line of intersection)</span>
00724 <span class="comment"> *</span>
00725 <span class="comment"> * int tri_tri_intersect(Real V0[3],Real V1[3],Real V2[3],</span>
00726 <span class="comment"> *                       Real U0[3],Real U1[3],Real U2[3])</span>
00727 <span class="comment"> *</span>
00728 <span class="comment"> * parameters: vertices of triangle 1: V0,V1,V2</span>
00729 <span class="comment"> *             vertices of triangle 2: U0,U1,U2</span>
00730 <span class="comment"> * result    : returns 1 if the triangles intersect, otherwise 0</span>
00731 <span class="comment"> *</span>
00732 <span class="comment"> * Here is a version withouts divisions (a little faster)</span>
00733 <span class="comment"> * int NoDivTriTriIsect(Real V0[3],Real V1[3],Real V2[3],</span>
00734 <span class="comment"> *                      Real U0[3],Real U1[3],Real U2[3]);</span>
00735 <span class="comment"> * </span>
00736 <span class="comment"> * This version computes the line of intersection as well (if they are not coplanar):</span>
00737 <span class="comment"> * int tri_tri_intersect_with_isectline(Real V0[3],Real V1[3],Real V2[3], </span>
00738 <span class="comment"> *                                      Real U0[3],Real U1[3],Real U2[3],int *coplanar,</span>
00739 <span class="comment"> *                                      Real isectpt1[3],Real isectpt2[3]);</span>
00740 <span class="comment"> * coplanar returns whether the tris are coplanar</span>
00741 <span class="comment"> * isectpt1, isectpt2 are the endpoints of the line of intersection</span>
00742 <span class="comment"> */</span>
00743 
00744 
<a name="l00745"></a><a class="code" href="Triangle3_8cpp.html#a0">00745</a> <span class="preprocessor">#define FABS(x) (base::abs(x))        </span><span class="comment">/* implement as is fastest on your machine */</span>
00746 
00747 <span class="comment">/* if USE_EPSILON_TEST is true then we do a check: </span>
00748 <span class="comment">         if |dv|&lt;EPSILON then dv=0.0;</span>
00749 <span class="comment">   else no check is done (which is less robust)</span>
00750 <span class="comment">*/</span>
00751 <span class="preprocessor">#define USE_EPSILON_TEST TRUE  </span>
<a name="l00752"></a><a class="code" href="Triangle3_8cpp.html#a1">00752</a> <span class="preprocessor"></span><span class="preprocessor">#define EPSILON 0.000001</span>
<a name="l00753"></a><a class="code" href="Triangle3_8cpp.html#a2">00753</a> <span class="preprocessor"></span>
00754 
00755 <span class="comment">/* some macros */</span>
00756 <span class="preprocessor">#define CROSS(dest,v1,v2)                      \</span>
<a name="l00757"></a><a class="code" href="Triangle3_8cpp.html#a3">00757</a> <span class="preprocessor">              dest[0]=v1[1]*v2[2]-v1[2]*v2[1]; \</span>
00758 <span class="preprocessor">              dest[1]=v1[2]*v2[0]-v1[0]*v2[2]; \</span>
00759 <span class="preprocessor">              dest[2]=v1[0]*v2[1]-v1[1]*v2[0];</span>
00760 <span class="preprocessor"></span>
00761 <span class="preprocessor">#define DOT(v1,v2) (v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2])</span>
<a name="l00762"></a><a class="code" href="Triangle3_8cpp.html#a4">00762</a> <span class="preprocessor"></span>
00763 <span class="preprocessor">#define SUB(dest,v1,v2) dest[0]=v1[0]-v2[0]; dest[1]=v1[1]-v2[1]; dest[2]=v1[2]-v2[2]; </span>
<a name="l00764"></a><a class="code" href="Triangle3_8cpp.html#a5">00764</a> <span class="preprocessor"></span>
00765 <span class="preprocessor">#define ADD(dest,v1,v2) dest[0]=v1[0]+v2[0]; dest[1]=v1[1]+v2[1]; dest[2]=v1[2]+v2[2]; </span>
<a name="l00766"></a><a class="code" href="Triangle3_8cpp.html#a6">00766</a> <span class="preprocessor"></span>
00767 <span class="preprocessor">#define MULT(dest,v,factor) dest[0]=factor*v[0]; dest[1]=factor*v[1]; dest[2]=factor*v[2];</span>
<a name="l00768"></a><a class="code" href="Triangle3_8cpp.html#a7">00768</a> <span class="preprocessor"></span>
00769 <span class="preprocessor">#define SET(dest,src) dest[0]=src[0]; dest[1]=src[1]; dest[2]=src[2]; </span>
<a name="l00770"></a><a class="code" href="Triangle3_8cpp.html#a8">00770</a> <span class="preprocessor"></span>
00771 <span class="comment">/* sort so that a&lt;=b */</span>
00772 <span class="preprocessor">#define SORT(a,b)       \</span>
<a name="l00773"></a><a class="code" href="Triangle3_8cpp.html#a9">00773</a> <span class="preprocessor">             if(a&gt;b)    \</span>
00774 <span class="preprocessor">             {          \</span>
00775 <span class="preprocessor">               Real c; \</span>
00776 <span class="preprocessor">               c=a;     \</span>
00777 <span class="preprocessor">               a=b;     \</span>
00778 <span class="preprocessor">               b=c;     \</span>
00779 <span class="preprocessor">             }</span>
00780 <span class="preprocessor"></span>
00781 <span class="preprocessor">#define ISECT(VV0,VV1,VV2,D0,D1,D2,isect0,isect1) \</span>
<a name="l00782"></a><a class="code" href="Triangle3_8cpp.html#a10">00782</a> <span class="preprocessor">              isect0=VV0+(VV1-VV0)*D0/(D0-D1);    \</span>
00783 <span class="preprocessor">              isect1=VV0+(VV2-VV0)*D0/(D0-D2);</span>
00784 <span class="preprocessor"></span>
00785 
00786 <span class="preprocessor">#define COMPUTE_INTERVALS(VV0,VV1,VV2,D0,D1,D2,D0D1,D0D2,isect0,isect1) \</span>
<a name="l00787"></a><a class="code" href="Triangle3_8cpp.html#a11">00787</a> <span class="preprocessor">  if(D0D1&gt;0.0f)                                         \</span>
00788 <span class="preprocessor">  {                                                     \</span>
00789 <span class="preprocessor">    </span><span class="comment">/* here we know that D0D2&lt;=0.0 */</span>                   \
00790     <span class="comment">/* that is D0, D1 are on the same side, D2 on the other or on the plane */</span> \
00791     ISECT(VV2,VV0,VV1,D2,D0,D1,isect0,isect1);          \
00792   }                                                     \
00793   else if(D0D2&gt;0.0f)                                    \
00794   {                                                     \
00795     <span class="comment">/* here we know that d0d1&lt;=0.0 */</span>                   \
00796     ISECT(VV1,VV0,VV2,D1,D0,D2,isect0,isect1);          \
00797   }                                                     \
00798   else if(D1*D2&gt;0.0f || D0!=0.0f)                       \
00799   {                                                     \
00800     <span class="comment">/* here we know that d0d1&lt;=0.0 or that D0!=0.0 */</span>   \
00801     ISECT(VV0,VV1,VV2,D0,D1,D2,isect0,isect1);          \
00802   }                                                     \
00803   else if(D1!=0.0f)                                     \
00804   {                                                     \
00805     ISECT(VV1,VV0,VV2,D1,D0,D2,isect0,isect1);          \
00806   }                                                     \
00807   else if(D2!=0.0f)                                     \
00808   {                                                     \
00809     ISECT(VV2,VV0,VV1,D2,D0,D1,isect0,isect1);          \
00810   }                                                     \
00811   else                                                  \
00812   {                                                     \
00813     <span class="comment">/* triangles are coplanar */</span>                        \
00814     return coplanar_tri_tri(N1,V0,V1,V2,U0,U1,U2);      \
00815   }
00816 
00817 
00818 
00819 <span class="comment">/* this edge to edge test is based on Franlin Antonio's gem:</span>
00820 <span class="comment">   "Faster Line Segment Intersection", in Graphics Gems III,</span>
00821 <span class="comment">   pp. 199-202 */</span> 
00822 <span class="preprocessor">#define EDGE_EDGE_TEST(V0,U0,U1)                      \</span>
<a name="l00823"></a><a class="code" href="Triangle3_8cpp.html#a12">00823</a> <span class="preprocessor">  Bx=U0[i0]-U1[i0];                                   \</span>
00824 <span class="preprocessor">  By=U0[i1]-U1[i1];                                   \</span>
00825 <span class="preprocessor">  Cx=V0[i0]-U0[i0];                                   \</span>
00826 <span class="preprocessor">  Cy=V0[i1]-U0[i1];                                   \</span>
00827 <span class="preprocessor">  f=Ay*Bx-Ax*By;                                      \</span>
00828 <span class="preprocessor">  d=By*Cx-Bx*Cy;                                      \</span>
00829 <span class="preprocessor">  if((f&gt;0 &amp;&amp; d&gt;=0 &amp;&amp; d&lt;=f) || (f&lt;0 &amp;&amp; d&lt;=0 &amp;&amp; d&gt;=f))  \</span>
00830 <span class="preprocessor">  {                                                   \</span>
00831 <span class="preprocessor">    e=Ax*Cy-Ay*Cx;                                    \</span>
00832 <span class="preprocessor">    if(f&gt;0)                                           \</span>
00833 <span class="preprocessor">    {                                                 \</span>
00834 <span class="preprocessor">      if(e&gt;=0 &amp;&amp; e&lt;=f) return 1;                      \</span>
00835 <span class="preprocessor">    }                                                 \</span>
00836 <span class="preprocessor">    else                                              \</span>
00837 <span class="preprocessor">    {                                                 \</span>
00838 <span class="preprocessor">      if(e&lt;=0 &amp;&amp; e&gt;=f) return 1;                      \</span>
00839 <span class="preprocessor">    }                                                 \</span>
00840 <span class="preprocessor">  }                                </span>
00841 <span class="preprocessor"></span>
00842 <span class="preprocessor">#define EDGE_AGAINST_TRI_EDGES(V0,V1,U0,U1,U2) \</span>
<a name="l00843"></a><a class="code" href="Triangle3_8cpp.html#a13">00843</a> <span class="preprocessor">{                                              \</span>
00844 <span class="preprocessor">  Real Ax,Ay,Bx,By,Cx,Cy,e,d,f;               \</span>
00845 <span class="preprocessor">  Ax=V1[i0]-V0[i0];                            \</span>
00846 <span class="preprocessor">  Ay=V1[i1]-V0[i1];                            \</span>
00847 <span class="preprocessor">  </span><span class="comment">/* test edge U0,U1 against V0,V1 */</span>          \
00848   EDGE_EDGE_TEST(V0,U0,U1);                    \
00849   <span class="comment">/* test edge U1,U2 against V0,V1 */</span>          \
00850   EDGE_EDGE_TEST(V0,U1,U2);                    \
00851   <span class="comment">/* test edge U2,U1 against V0,V1 */</span>          \
00852   EDGE_EDGE_TEST(V0,U2,U0);                    \
00853 }
00854 
00855 <span class="preprocessor">#define POINT_IN_TRI(V0,U0,U1,U2)           \</span>
<a name="l00856"></a><a class="code" href="Triangle3_8cpp.html#a14">00856</a> <span class="preprocessor">{                                           \</span>
00857 <span class="preprocessor">  Real a,b,c,d0,d1,d2;                     \</span>
00858 <span class="preprocessor">  </span><span class="comment">/* is T1 completly inside T2? */</span>          \
00859   <span class="comment">/* check if V0 is inside tri(U0,U1,U2) */</span> \
00860   a=U1[i1]-U0[i1];                          \
00861   b=-(U1[i0]-U0[i0]);                       \
00862   c=-a*U0[i0]-b*U0[i1];                     \
00863   d0=a*V0[i0]+b*V0[i1]+c;                   \
00864                                             \
00865   a=U2[i1]-U1[i1];                          \
00866   b=-(U2[i0]-U1[i0]);                       \
00867   c=-a*U1[i0]-b*U1[i1];                     \
00868   d1=a*V0[i0]+b*V0[i1]+c;                   \
00869                                             \
00870   a=U0[i1]-U2[i1];                          \
00871   b=-(U0[i0]-U2[i0]);                       \
00872   c=-a*U2[i0]-b*U2[i1];                     \
00873   d2=a*V0[i0]+b*V0[i1]+c;                   \
00874   if(d0*d1&gt;0.0)                             \
00875   {                                         \
00876     if(d0*d2&gt;0.0) return 1;                 \
00877   }                                         \
00878 }
00879 
00880 <span class="keywordtype">int</span> <a class="code" href="Triangle3_8cpp.html#a18">coplanar_tri_tri</a>(Real N[3],Real V0[3],Real V1[3],Real V2[3],
<a name="l00881"></a><a class="code" href="Triangle3_8cpp.html#a18">00881</a>                      Real U0[3],Real U1[3],Real U2[3])
00882 {
00883    Real A[3];
00884    <span class="keywordtype">short</span> i0,i1;
00885    <span class="comment">/* first project onto an axis-aligned plane, that maximizes the area */</span>
00886    <span class="comment">/* of the triangles, compute indices: i0,i1. */</span>
00887    A[0]=fabs(N[0]);
00888    A[1]=fabs(N[1]);
00889    A[2]=fabs(N[2]);
00890    <span class="keywordflow">if</span>(A[0]&gt;A[1])
00891    {
00892       <span class="keywordflow">if</span>(A[0]&gt;A[2])  
00893       {
00894           i0=1;      <span class="comment">/* A[0] is greatest */</span>
00895           i1=2;
00896       }
00897       <span class="keywordflow">else</span>
00898       {
00899           i0=0;      <span class="comment">/* A[2] is greatest */</span>
00900           i1=1;
00901       }
00902    }
00903    <span class="keywordflow">else</span>   <span class="comment">/* A[0]&lt;=A[1] */</span>
00904    {
00905       <span class="keywordflow">if</span>(A[2]&gt;A[1])
00906       {
00907           i0=0;      <span class="comment">/* A[2] is greatest */</span>
00908           i1=1;                                           
00909       }
00910       <span class="keywordflow">else</span>
00911       {
00912           i0=0;      <span class="comment">/* A[1] is greatest */</span>
00913           i1=2;
00914       }
00915     }               
00916                 
00917     <span class="comment">/* test all edges of triangle 1 against the edges of triangle 2 */</span>
00918     <a class="code" href="Triangle3_8cpp.html#a13">EDGE_AGAINST_TRI_EDGES</a>(V0,V1,U0,U1,U2);
00919     <a class="code" href="Triangle3_8cpp.html#a13">EDGE_AGAINST_TRI_EDGES</a>(V1,V2,U0,U1,U2);
00920     <a class="code" href="Triangle3_8cpp.html#a13">EDGE_AGAINST_TRI_EDGES</a>(V2,V0,U0,U1,U2);
00921                 
00922     <span class="comment">/* finally, test if tri1 is totally contained in tri2 or vice versa */</span>
00923     <a class="code" href="Triangle3_8cpp.html#a14">POINT_IN_TRI</a>(V0,U0,U1,U2);
00924     <a class="code" href="Triangle3_8cpp.html#a14">POINT_IN_TRI</a>(U0,V0,V1,V2);
00925 
00926     <span class="keywordflow">return</span> 0;
00927 }
00928 
00929 
00930 <span class="keywordtype">int</span> <a class="code" href="Triangle3_8cpp.html#a19">tri_tri_intersect</a>(Real V0[3],Real V1[3],Real V2[3],
<a name="l00931"></a><a class="code" href="Triangle3_8cpp.html#a19">00931</a>                       Real U0[3],Real U1[3],Real U2[3])
00932 {
00933   Real <a class="code" href="Globals_8h.html#a29">E1</a>[3],<a class="code" href="Globals_8h.html#a30">E2</a>[3];
00934   Real N1[3],N2[3],d1,d2;
00935   Real du0,du1,du2,dv0,dv1,dv2;
00936   Real D[3];
00937   Real isect1[2], <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[2];
00938   Real du0du1,du0du2,dv0dv1,dv0dv2;
00939   <span class="keywordtype">short</span> index;
00940   Real vp0,vp1,vp2;
00941   Real up0,up1,up2;
00942   Real b,c,max;
00943 
00944   <span class="comment">/* compute plane equation of triangle(V0,V1,V2) */</span>
00945   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a29">E1</a>,V1,V0);
00946   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a30">E2</a>,V2,V0);
00947   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(N1,<a class="code" href="Globals_8h.html#a29">E1</a>,<a class="code" href="Globals_8h.html#a30">E2</a>);
00948   d1=-<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,V0);
00949   <span class="comment">/* plane equation 1: N1.X+d1=0 */</span>
00950 
00951   <span class="comment">/* put U0,U1,U2 into plane equation 1 to compute signed distances to the plane*/</span>
00952   du0=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U0)+d1;
00953   du1=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U1)+d1;
00954   du2=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U2)+d1;
00955 
00956   <span class="comment">/* coplanarity robustness check */</span>
00957 <span class="preprocessor">#if USE_EPSILON_TEST==TRUE</span>
00958 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(fabs(du0)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du0=0.0;
00959   <span class="keywordflow">if</span>(fabs(du1)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du1=0.0;
00960   <span class="keywordflow">if</span>(fabs(du2)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du2=0.0;
00961 <span class="preprocessor">#endif</span>
00962 <span class="preprocessor"></span>  du0du1=du0*du1;
00963   du0du2=du0*du2;
00964 
00965   <span class="keywordflow">if</span>(du0du1&gt;0.0f &amp;&amp; du0du2&gt;0.0f) <span class="comment">/* same sign on all of them + not equal 0 ? */</span>
00966     <span class="keywordflow">return</span> 0;                    <span class="comment">/* no intersection occurs */</span>
00967 
00968   <span class="comment">/* compute plane of triangle (U0,U1,U2) */</span>
00969   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a29">E1</a>,U1,U0);
00970   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a30">E2</a>,U2,U0);
00971   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(N2,<a class="code" href="Globals_8h.html#a29">E1</a>,<a class="code" href="Globals_8h.html#a30">E2</a>);
00972   d2=-<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,U0);
00973   <span class="comment">/* plane equation 2: N2.X+d2=0 */</span>
00974 
00975   <span class="comment">/* put V0,V1,V2 into plane equation 2 */</span>
00976   dv0=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V0)+d2;
00977   dv1=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V1)+d2;
00978   dv2=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V2)+d2;
00979 
00980 <span class="preprocessor">#if USE_EPSILON_TEST==TRUE</span>
00981 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(fabs(dv0)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv0=0.0;
00982   <span class="keywordflow">if</span>(fabs(dv1)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv1=0.0;
00983   <span class="keywordflow">if</span>(fabs(dv2)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv2=0.0;
00984 <span class="preprocessor">#endif</span>
00985 <span class="preprocessor"></span>
00986   dv0dv1=dv0*dv1;
00987   dv0dv2=dv0*dv2;
00988         
00989   <span class="keywordflow">if</span>(dv0dv1&gt;0.0f &amp;&amp; dv0dv2&gt;0.0f) <span class="comment">/* same sign on all of them + not equal 0 ? */</span>
00990     <span class="keywordflow">return</span> 0;                    <span class="comment">/* no intersection occurs */</span>
00991 
00992   <span class="comment">/* compute direction of intersection line */</span>
00993   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(D,N1,N2);
00994 
00995   <span class="comment">/* compute and index to the largest component of D */</span>
00996   max=fabs(D[0]);
00997   index=0;
00998   b=fabs(D[1]);
00999   c=fabs(D[2]);
01000   <span class="keywordflow">if</span>(b&gt;max) max=b,index=1;
01001   <span class="keywordflow">if</span>(c&gt;max) max=c,index=2;
01002 
01003   <span class="comment">/* this is the simplified projection onto L*/</span>
01004   vp0=V0[index];
01005   vp1=V1[index];
01006   vp2=V2[index];
01007   
01008   up0=U0[index];
01009   up1=U1[index];
01010   up2=U2[index];
01011 
01012   <span class="comment">/* compute interval for triangle 1 */</span>
01013   <a class="code" href="Triangle3_8cpp.html#a11">COMPUTE_INTERVALS</a>(vp0,vp1,vp2,dv0,dv1,dv2,dv0dv1,dv0dv2,isect1[0],isect1[1]);
01014 
01015   <span class="comment">/* compute interval for triangle 2 */</span>
01016   <a class="code" href="Triangle3_8cpp.html#a11">COMPUTE_INTERVALS</a>(up0,up1,up2,du0,du1,du2,du0du1,du0du2,<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0],<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]);
01017 
01018   <a class="code" href="Triangle3_8cpp.html#a9">SORT</a>(isect1[0],isect1[1]);
01019   <a class="code" href="Triangle3_8cpp.html#a9">SORT</a>(<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0],<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]);
01020 
01021   <span class="keywordflow">if</span>(isect1[1]&lt;<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0] || <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]&lt;isect1[0]) <span class="keywordflow">return</span> 0;
01022   <span class="keywordflow">return</span> 1;
01023 }
01024 
01025 
01026 <span class="preprocessor">#define NEWCOMPUTE_INTERVALS(VV0,VV1,VV2,D0,D1,D2,D0D1,D0D2,A,B,C,X0,X1) \</span>
<a name="l01027"></a><a class="code" href="Triangle3_8cpp.html#a15">01027</a> <span class="preprocessor">{ \</span>
01028 <span class="preprocessor">        if(D0D1&gt;0.0f) \</span>
01029 <span class="preprocessor">        { \</span>
01030 <span class="preprocessor">                </span><span class="comment">/* here we know that D0D2&lt;=0.0 */</span> \
01031             <span class="comment">/* that is D0, D1 are on the same side, D2 on the other or on the plane */</span> \
01032                 A=VV2; B=(VV0-VV2)*D2; C=(VV1-VV2)*D2; X0=D2-D0; X1=D2-D1; \
01033         } \
01034         else if(D0D2&gt;0.0f)\
01035         { \
01036                 <span class="comment">/* here we know that d0d1&lt;=0.0 */</span> \
01037             A=VV1; B=(VV0-VV1)*D1; C=(VV2-VV1)*D1; X0=D1-D0; X1=D1-D2; \
01038         } \
01039         else if(D1*D2&gt;0.0f || D0!=0.0f) \
01040         { \
01041                 <span class="comment">/* here we know that d0d1&lt;=0.0 or that D0!=0.0 */</span> \
01042                 A=VV0; B=(VV1-VV0)*D0; C=(VV2-VV0)*D0; X0=D0-D1; X1=D0-D2; \
01043         } \
01044         else if(D1!=0.0f) \
01045         { \
01046                 A=VV1; B=(VV0-VV1)*D1; C=(VV2-VV1)*D1; X0=D1-D0; X1=D1-D2; \
01047         } \
01048         else if(D2!=0.0f) \
01049         { \
01050                 A=VV2; B=(VV0-VV2)*D2; C=(VV1-VV2)*D2; X0=D2-D0; X1=D2-D1; \
01051         } \
01052         else \
01053         { \
01054                 <span class="comment">/* triangles are coplanar */</span> \
01055                 return coplanar_tri_tri(N1,V0,V1,V2,U0,U1,U2); \
01056         } \
01057 }
01058 
01059 
01060 
01061 <span class="keywordtype">int</span> <a class="code" href="Triangle3_8cpp.html#a20">NoDivTriTriIsect</a>(Real V0[3],Real V1[3],Real V2[3],
<a name="l01062"></a><a class="code" href="Triangle3_8cpp.html#a20">01062</a>                      Real U0[3],Real U1[3],Real U2[3])
01063 {
01064   Real <a class="code" href="Globals_8h.html#a29">E1</a>[3],<a class="code" href="Globals_8h.html#a30">E2</a>[3];
01065   Real N1[3],N2[3],d1,d2;
01066   Real du0,du1,du2,dv0,dv1,dv2;
01067   Real D[3];
01068   Real isect1[2], <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[2];
01069   Real du0du1,du0du2,dv0dv1,dv0dv2;
01070   <span class="keywordtype">short</span> index;
01071   Real vp0,vp1,vp2;
01072   Real up0,up1,up2;
01073   Real bb,cc,max;
01074   Real a,b,c,x0,x1;
01075   Real d,e,<a class="code" href="Makefile_8in.html#a5">f</a>,y0,y1;
01076   Real xx,yy,xxyy,tmp;
01077 
01078   <span class="comment">/* compute plane equation of triangle(V0,V1,V2) */</span>
01079   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a29">E1</a>,V1,V0);
01080   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a30">E2</a>,V2,V0);
01081   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(N1,<a class="code" href="Globals_8h.html#a29">E1</a>,<a class="code" href="Globals_8h.html#a30">E2</a>);
01082   d1=-<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,V0);
01083   <span class="comment">/* plane equation 1: N1.X+d1=0 */</span>
01084 
01085   <span class="comment">/* put U0,U1,U2 into plane equation 1 to compute signed distances to the plane*/</span>
01086   du0=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U0)+d1;
01087   du1=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U1)+d1;
01088   du2=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U2)+d1;
01089 
01090   <span class="comment">/* coplanarity robustness check */</span>
01091 <span class="preprocessor">#if USE_EPSILON_TEST==TRUE</span>
01092 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(du0)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du0=0.0;
01093   <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(du1)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du1=0.0;
01094   <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(du2)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du2=0.0;
01095 <span class="preprocessor">#endif</span>
01096 <span class="preprocessor"></span>  du0du1=du0*du1;
01097   du0du2=du0*du2;
01098 
01099   <span class="keywordflow">if</span>(du0du1&gt;0.0f &amp;&amp; du0du2&gt;0.0f) <span class="comment">/* same sign on all of them + not equal 0 ? */</span>
01100     <span class="keywordflow">return</span> 0;                    <span class="comment">/* no intersection occurs */</span>
01101 
01102   <span class="comment">/* compute plane of triangle (U0,U1,U2) */</span>
01103   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a29">E1</a>,U1,U0);
01104   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a30">E2</a>,U2,U0);
01105   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(N2,<a class="code" href="Globals_8h.html#a29">E1</a>,<a class="code" href="Globals_8h.html#a30">E2</a>);
01106   d2=-<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,U0);
01107   <span class="comment">/* plane equation 2: N2.X+d2=0 */</span>
01108 
01109   <span class="comment">/* put V0,V1,V2 into plane equation 2 */</span>
01110   dv0=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V0)+d2;
01111   dv1=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V1)+d2;
01112   dv2=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V2)+d2;
01113 
01114 <span class="preprocessor">#if USE_EPSILON_TEST==TRUE</span>
01115 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(dv0)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv0=0.0;
01116   <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(dv1)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv1=0.0;
01117   <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(dv2)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv2=0.0;
01118 <span class="preprocessor">#endif</span>
01119 <span class="preprocessor"></span>
01120   dv0dv1=dv0*dv1;
01121   dv0dv2=dv0*dv2;
01122 
01123   <span class="keywordflow">if</span>(dv0dv1&gt;0.0f &amp;&amp; dv0dv2&gt;0.0f) <span class="comment">/* same sign on all of them + not equal 0 ? */</span>
01124     <span class="keywordflow">return</span> 0;                    <span class="comment">/* no intersection occurs */</span>
01125 
01126   <span class="comment">/* compute direction of intersection line */</span>
01127   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(D,N1,N2);
01128 
01129   <span class="comment">/* compute and index to the largest component of D */</span>
01130   max=(Real)<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(D[0]);
01131   index=0;
01132   bb=(Real)<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(D[1]);
01133   cc=(Real)<a class="code" href="Triangle3_8cpp.html#a0">FABS</a>(D[2]);
01134   <span class="keywordflow">if</span>(bb&gt;max) max=bb,index=1;
01135   <span class="keywordflow">if</span>(cc&gt;max) max=cc,index=2;
01136 
01137   <span class="comment">/* this is the simplified projection onto L*/</span>
01138   vp0=V0[index];
01139   vp1=V1[index];
01140   vp2=V2[index];
01141 
01142   up0=U0[index];
01143   up1=U1[index];
01144   up2=U2[index];
01145 
01146   <span class="comment">/* compute interval for triangle 1 */</span>
01147   <a class="code" href="Triangle3_8cpp.html#a15">NEWCOMPUTE_INTERVALS</a>(vp0,vp1,vp2,dv0,dv1,dv2,dv0dv1,dv0dv2,a,b,c,x0,x1);
01148 
01149   <span class="comment">/* compute interval for triangle 2 */</span>
01150   <a class="code" href="Triangle3_8cpp.html#a15">NEWCOMPUTE_INTERVALS</a>(up0,up1,up2,du0,du1,du2,du0du1,du0du2,d,e,<a class="code" href="Makefile_8in.html#a5">f</a>,y0,y1);
01151 
01152   xx=x0*x1;
01153   yy=y0*y1;
01154   xxyy=xx*yy;
01155 
01156   tmp=a*xxyy;
01157   isect1[0]=tmp+b*x1*yy;
01158   isect1[1]=tmp+c*x0*yy;
01159 
01160   tmp=d*xxyy;
01161   <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0]=tmp+e*xx*y1;
01162   <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]=tmp+<a class="code" href="Makefile_8in.html#a5">f</a>*xx*y0;
01163 
01164   <a class="code" href="Triangle3_8cpp.html#a9">SORT</a>(isect1[0],isect1[1]);
01165   <a class="code" href="Triangle3_8cpp.html#a9">SORT</a>(<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0],<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]);
01166 
01167   <span class="keywordflow">if</span>(isect1[1]&lt;<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0] || <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]&lt;isect1[0]) <span class="keywordflow">return</span> 0;
01168   <span class="keywordflow">return</span> 1;
01169 }
01170 
01171 <span class="comment">/* sort so that a&lt;=b */</span>
01172 <span class="preprocessor">#define SORT2(a,b,smallest)       \</span>
<a name="l01173"></a><a class="code" href="Triangle3_8cpp.html#a16">01173</a> <span class="preprocessor">             if(a&gt;b)       \</span>
01174 <span class="preprocessor">             {             \</span>
01175 <span class="preprocessor">               Real c;    \</span>
01176 <span class="preprocessor">               c=a;        \</span>
01177 <span class="preprocessor">               a=b;        \</span>
01178 <span class="preprocessor">               b=c;        \</span>
01179 <span class="preprocessor">               smallest=1; \</span>
01180 <span class="preprocessor">             }             \</span>
01181 <span class="preprocessor">             else smallest=0;</span>
01182 <span class="preprocessor"></span>
01183 
01184 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(Real VTX0[3],Real VTX1[3],Real VTX2[3],Real VV0,Real VV1,Real VV2,
<a name="l01185"></a><a class="code" href="Triangle3_8cpp.html#a21">01185</a>             Real D0,Real D1,Real D2,Real *isect0,Real *isect1,Real isectpoint0[3],Real isectpoint1[3]) 
01186 {
01187   Real tmp=D0/(D0-D1);          
01188   Real diff[3];
01189   *isect0=VV0+(VV1-VV0)*tmp;         
01190   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(diff,VTX1,VTX0);              
01191   <a class="code" href="Triangle3_8cpp.html#a7">MULT</a>(diff,diff,tmp);               
01192   <a class="code" href="Triangle3_8cpp.html#a6">ADD</a>(isectpoint0,diff,VTX0);        
01193   tmp=D0/(D0-D2);                    
01194   *isect1=VV0+(VV2-VV0)*tmp;          
01195   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(diff,VTX2,VTX0);                   
01196   <a class="code" href="Triangle3_8cpp.html#a7">MULT</a>(diff,diff,tmp);                 
01197   <a class="code" href="Triangle3_8cpp.html#a6">ADD</a>(isectpoint1,VTX0,diff);          
01198 }
01199 
01200 
01201 
01202 <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="Triangle3_8cpp.html#a22">compute_intervals_isectline</a>(Real VERT0[3],Real VERT1[3],Real VERT2[3],
<a name="l01203"></a><a class="code" href="Triangle3_8cpp.html#a22">01203</a>                                        Real VV0,Real VV1,Real VV2,Real D0,Real D1,Real D2,
01204                                        Real D0D1,Real D0D2,Real *isect0,Real *isect1,
01205                                        Real isectpoint0[3],Real isectpoint1[3])
01206 {
01207   <span class="keywordflow">if</span>(D0D1&gt;0.0f)                                        
01208   {                                                    
01209     <span class="comment">/* here we know that D0D2&lt;=0.0 */</span>                  
01210     <span class="comment">/* that is D0, D1 are on the same side, D2 on the other or on the plane */</span>
01211     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT2,VERT0,VERT1,VV2,VV0,VV1,D2,D0,D1,isect0,isect1,isectpoint0,isectpoint1);
01212   } 
01213   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D0D2&gt;0.0f)                                   
01214     {                                                   
01215     <span class="comment">/* here we know that d0d1&lt;=0.0 */</span>             
01216     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT1,VERT0,VERT2,VV1,VV0,VV2,D1,D0,D2,isect0,isect1,isectpoint0,isectpoint1);
01217   }                                                  
01218   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D1*D2&gt;0.0f || D0!=0.0f)   
01219   {                                   
01220     <span class="comment">/* here we know that d0d1&lt;=0.0 or that D0!=0.0 */</span>
01221     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT0,VERT1,VERT2,VV0,VV1,VV2,D0,D1,D2,isect0,isect1,isectpoint0,isectpoint1);   
01222   }                                                  
01223   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D1!=0.0f)                                  
01224   {                                               
01225     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT1,VERT0,VERT2,VV1,VV0,VV2,D1,D0,D2,isect0,isect1,isectpoint0,isectpoint1); 
01226   }                                         
01227   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D2!=0.0f)                                  
01228   {                                                   
01229     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT2,VERT0,VERT1,VV2,VV0,VV1,D2,D0,D1,isect0,isect1,isectpoint0,isectpoint1);     
01230   }                                                 
01231   <span class="keywordflow">else</span>                                               
01232   {                                                   
01233     <span class="comment">/* triangles are coplanar */</span>    
01234     <span class="keywordflow">return</span> 1;
01235   }
01236   <span class="keywordflow">return</span> 0;
01237 }
01238 
01239 <span class="preprocessor">#define COMPUTE_INTERVALS_ISECTLINE(VERT0,VERT1,VERT2,VV0,VV1,VV2,D0,D1,D2,D0D1,D0D2,isect0,isect1,isectpoint0,isectpoint1) \</span>
<a name="l01240"></a><a class="code" href="Triangle3_8cpp.html#a17">01240</a> <span class="preprocessor">  if(D0D1&gt;0.0f)                                         \</span>
01241 <span class="preprocessor">  {                                                     \</span>
01242 <span class="preprocessor">    </span><span class="comment">/* here we know that D0D2&lt;=0.0 */</span>                   \
01243     <span class="comment">/* that is D0, D1 are on the same side, D2 on the other or on the plane */</span> \
01244     isect2(VERT2,VERT0,VERT1,VV2,VV0,VV1,D2,D0,D1,&amp;isect0,&amp;isect1,isectpoint0,isectpoint1);          \
01245   }                                                     
01246 <span class="preprocessor">#if 0</span>
01247 <span class="preprocessor"></span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D0D2&gt;0.0f)                                    \
01248   {                                                     \
01249     <span class="comment">/* here we know that d0d1&lt;=0.0 */</span>                   \
01250     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT1,VERT0,VERT2,VV1,VV0,VV2,D1,D0,D2,&amp;isect0,&amp;isect1,isectpoint0,isectpoint1);          \
01251   }                                                     \
01252   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D1*D2&gt;0.0f || D0!=0.0f)                       \
01253   {                                                     \
01254     <span class="comment">/* here we know that d0d1&lt;=0.0 or that D0!=0.0 */</span>   \
01255     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT0,VERT1,VERT2,VV0,VV1,VV2,D0,D1,D2,&amp;isect0,&amp;isect1,isectpoint0,isectpoint1);          \
01256   }                                                     \
01257   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D1!=0.0f)                                     \
01258   {                                                     \
01259     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT1,VERT0,VERT2,VV1,VV0,VV2,D1,D0,D2,&amp;isect0,&amp;isect1,isectpoint0,isectpoint1);          \
01260   }                                                     \
01261   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(D2!=0.0f)                                     \
01262   {                                                     \
01263     <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>(VERT2,VERT0,VERT1,VV2,VV0,VV1,D2,D0,D1,&amp;isect0,&amp;isect1,isectpoint0,isectpoint1);          \
01264   }                                                     \
01265   <span class="keywordflow">else</span>                                                  \
01266   {                                                     \
01267     <span class="comment">/* triangles are coplanar */</span>                        \
01268     coplanar=1;                                         \
01269     <span class="keywordflow">return</span> <a class="code" href="Triangle3_8cpp.html#a18">coplanar_tri_tri</a>(N1,V0,V1,V2,U0,U1,U2);      \
01270   }
01271 <span class="preprocessor">#endif</span>
01272 <span class="preprocessor"></span>
01273 <span class="keywordtype">int</span> <a class="code" href="Triangle3_8cpp.html#a23">tri_tri_intersect_with_isectline</a>(Real V0[3],Real V1[3],Real V2[3],
<a name="l01274"></a><a class="code" href="Triangle3_8cpp.html#a23">01274</a>                                      Real U0[3],Real U1[3],Real U2[3],<span class="keywordtype">int</span> *coplanar,
01275                                      Real isectpt1[3],Real isectpt2[3])
01276 {
01277   Real <a class="code" href="Globals_8h.html#a29">E1</a>[3],<a class="code" href="Globals_8h.html#a30">E2</a>[3];
01278   Real N1[3],N2[3],d1,d2;
01279   Real du0,du1,du2,dv0,dv1,dv2;
01280   Real D[3];
01281   Real isect1[2], <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[2];
01282   Real isectpointA1[3],isectpointA2[3];
01283   Real isectpointB1[3],isectpointB2[3];
01284   Real du0du1,du0du2,dv0dv1,dv0dv2;
01285   <span class="keywordtype">short</span> index;
01286   Real vp0,vp1,vp2;
01287   Real up0,up1,up2;
01288   Real b,c,max;
01289   <span class="comment">//  Real tmp,diff[3];</span>
01290   <span class="keywordtype">int</span> smallest1,smallest2;
01291   
01292   <span class="comment">/* compute plane equation of triangle(V0,V1,V2) */</span>
01293   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a29">E1</a>,V1,V0);
01294   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a30">E2</a>,V2,V0);
01295   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(N1,<a class="code" href="Globals_8h.html#a29">E1</a>,<a class="code" href="Globals_8h.html#a30">E2</a>);
01296   d1=-<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,V0);
01297   <span class="comment">/* plane equation 1: N1.X+d1=0 */</span>
01298 
01299   <span class="comment">/* put U0,U1,U2 into plane equation 1 to compute signed distances to the plane*/</span>
01300   du0=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U0)+d1;
01301   du1=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U1)+d1;
01302   du2=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N1,U2)+d1;
01303 
01304   <span class="comment">/* coplanarity robustness check */</span>
01305 <span class="preprocessor">#if USE_EPSILON_TEST==TRUE</span>
01306 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(fabs(du0)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du0=0.0;
01307   <span class="keywordflow">if</span>(fabs(du1)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du1=0.0;
01308   <span class="keywordflow">if</span>(fabs(du2)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) du2=0.0;
01309 <span class="preprocessor">#endif</span>
01310 <span class="preprocessor"></span>  du0du1=du0*du1;
01311   du0du2=du0*du2;
01312 
01313   <span class="keywordflow">if</span>(du0du1&gt;0.0f &amp;&amp; du0du2&gt;0.0f) <span class="comment">/* same sign on all of them + not equal 0 ? */</span>
01314     <span class="keywordflow">return</span> 0;                    <span class="comment">/* no intersection occurs */</span>
01315 
01316   <span class="comment">/* compute plane of triangle (U0,U1,U2) */</span>
01317   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a29">E1</a>,U1,U0);
01318   <a class="code" href="Triangle3_8cpp.html#a5">SUB</a>(<a class="code" href="Globals_8h.html#a30">E2</a>,U2,U0);
01319   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(N2,<a class="code" href="Globals_8h.html#a29">E1</a>,<a class="code" href="Globals_8h.html#a30">E2</a>);
01320   d2=-<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,U0);
01321   <span class="comment">/* plane equation 2: N2.X+d2=0 */</span>
01322 
01323   <span class="comment">/* put V0,V1,V2 into plane equation 2 */</span>
01324   dv0=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V0)+d2;
01325   dv1=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V1)+d2;
01326   dv2=<a class="code" href="Triangle3_8cpp.html#a4">DOT</a>(N2,V2)+d2;
01327 
01328 <span class="preprocessor">#if USE_EPSILON_TEST==TRUE</span>
01329 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(fabs(dv0)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv0=0.0;
01330   <span class="keywordflow">if</span>(fabs(dv1)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv1=0.0;
01331   <span class="keywordflow">if</span>(fabs(dv2)&lt;<a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>) dv2=0.0;
01332 <span class="preprocessor">#endif</span>
01333 <span class="preprocessor"></span>
01334   dv0dv1=dv0*dv1;
01335   dv0dv2=dv0*dv2;
01336         
01337   <span class="keywordflow">if</span>(dv0dv1&gt;0.0f &amp;&amp; dv0dv2&gt;0.0f) <span class="comment">/* same sign on all of them + not equal 0 ? */</span>
01338     <span class="keywordflow">return</span> 0;                    <span class="comment">/* no intersection occurs */</span>
01339 
01340   <span class="comment">/* compute direction of intersection line */</span>
01341   <a class="code" href="Triangle3_8cpp.html#a3">CROSS</a>(D,N1,N2);
01342 
01343   <span class="comment">/* compute and index to the largest component of D */</span>
01344   max=fabs(D[0]);
01345   index=0;
01346   b=fabs(D[1]);
01347   c=fabs(D[2]);
01348   <span class="keywordflow">if</span>(b&gt;max) max=b,index=1;
01349   <span class="keywordflow">if</span>(c&gt;max) max=c,index=2;
01350 
01351   <span class="comment">/* this is the simplified projection onto L*/</span>
01352   vp0=V0[index];
01353   vp1=V1[index];
01354   vp2=V2[index];
01355   
01356   up0=U0[index];
01357   up1=U1[index];
01358   up2=U2[index];
01359 
01360   <span class="comment">/* compute interval for triangle 1 */</span>
01361   *coplanar=<a class="code" href="Triangle3_8cpp.html#a22">compute_intervals_isectline</a>(V0,V1,V2,vp0,vp1,vp2,dv0,dv1,dv2,
01362                                        dv0dv1,dv0dv2,&amp;isect1[0],&amp;isect1[1],isectpointA1,isectpointA2);
01363   <span class="keywordflow">if</span>(*coplanar) <span class="keywordflow">return</span> <a class="code" href="Triangle3_8cpp.html#a18">coplanar_tri_tri</a>(N1,V0,V1,V2,U0,U1,U2);     
01364 
01365 
01366   <span class="comment">/* compute interval for triangle 2 */</span>
01367   <a class="code" href="Triangle3_8cpp.html#a22">compute_intervals_isectline</a>(U0,U1,U2,up0,up1,up2,du0,du1,du2,
01368                               du0du1,du0du2,&amp;<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0],&amp;<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1],isectpointB1,isectpointB2);
01369 
01370   <a class="code" href="Triangle3_8cpp.html#a16">SORT2</a>(isect1[0],isect1[1],smallest1);
01371   <a class="code" href="Triangle3_8cpp.html#a16">SORT2</a>(<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0],<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1],smallest2);
01372 
01373   <span class="keywordflow">if</span>(isect1[1]&lt;<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0] || <a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]&lt;isect1[0]) <span class="keywordflow">return</span> 0;
01374 
01375   <span class="comment">/* at this point, we know that the triangles intersect */</span>
01376 
01377   <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[0]&lt;isect1[0])
01378   {
01379     <span class="keywordflow">if</span>(smallest1==0) { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt1,isectpointA1); }
01380     <span class="keywordflow">else</span> { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt1,isectpointA2); }
01381 
01382     <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]&lt;isect1[1])
01383     {
01384       <span class="keywordflow">if</span>(smallest2==0) { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointB2); }
01385       <span class="keywordflow">else</span> { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointB1); }
01386     }
01387     <span class="keywordflow">else</span>
01388     {
01389       <span class="keywordflow">if</span>(smallest1==0) { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointA2); }
01390       <span class="keywordflow">else</span> { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointA1); }
01391     }
01392   }
01393   <span class="keywordflow">else</span>
01394   {
01395     <span class="keywordflow">if</span>(smallest2==0) { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt1,isectpointB1); }
01396     <span class="keywordflow">else</span> { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt1,isectpointB2); }
01397 
01398     <span class="keywordflow">if</span>(<a class="code" href="Triangle3_8cpp.html#a21">isect2</a>[1]&gt;isect1[1])
01399     {
01400       <span class="keywordflow">if</span>(smallest1==0) { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointA2); }
01401       <span class="keywordflow">else</span> { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointA1); }      
01402     }
01403     <span class="keywordflow">else</span>
01404     {
01405       <span class="keywordflow">if</span>(smallest2==0) { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointB2); }
01406       <span class="keywordflow">else</span> { <a class="code" href="Triangle3_8cpp.html#a8">SET</a>(isectpt2,isectpointB1); } 
01407     }
01408   }
01409   <span class="keywordflow">return</span> 1;
01410 }
01411 
01412 
01413 
01414 
01415 <span class="comment">//</span>
01416 <span class="comment">// class Triangle3 implementation</span>
01417 <span class="comment">//</span>
01418 
01419 
01420 <span class="keywordtype">bool</span> Triangle3::intersect(<span class="keyword">const</span> Triangle3&amp; t)<span class="keyword"> const</span>
01421 <span class="keyword"></span>{
01422   <span class="keyword">const</span> Triangle3&amp; t2(*<span class="keyword">this</span>);
01423 
01424   <span class="comment">// C doesn't know about const</span>
01425   Real* t1p1 = const_cast&lt;Real*&gt;(t.p1().c_array());
01426   Real* t1p2 = const_cast&lt;Real*&gt;(t.p2().c_array());
01427   Real* t1p3 = const_cast&lt;Real*&gt;(t.p3().c_array());
01428   Real* t2p1 = const_cast&lt;Real*&gt;(t2.p1().c_array());
01429   Real* t2p2 = const_cast&lt;Real*&gt;(t2.p2().c_array());
01430   Real* t2p3 = const_cast&lt;Real*&gt;(t2.p3().c_array());
01431 
01432   <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)<a class="code" href="Triangle3_8cpp.html#a20">NoDivTriTriIsect</a>(t1p1,t1p2,t1p3,
01433                                 t2p1,t2p2,t2p3);
01434 
01435   <span class="comment">/* Old code to compute intersection point</span>
01436 <span class="comment">  const Triangle&amp; t1(*this);</span>
01437 <span class="comment">  const Triangle&amp; t2(t);</span>
01438 <span class="comment">  Plane p1(t1);</span>
01439 <span class="comment">  Int other_side=0;</span>
01440 <span class="comment">  {</span>
01441 <span class="comment">    Real f1=p1.classify(t2[1]);</span>
01442 <span class="comment">    Real f2=p1.classify(t2[2]);</span>
01443 <span class="comment">    Real f3=p1.classify(t2[3]);</span>
01444 <span class="comment">    Real f12=f1*f2;</span>
01445 <span class="comment">    Real f23=f2*f3;</span>
01446 <span class="comment">    if (f12&gt;0.0 &amp;&amp; f23&gt;0.0) return Vector3::zero;</span>
01447 <span class="comment">    other_side=(f12&lt;0.0?(f23&lt;0.0?1:0):2);</span>
01448 <span class="comment">  }</span>
01449 <span class="comment">  Plane p2(t2);</span>
01450 <span class="comment">  Vector3 n12(p1.normal+p2.normal);</span>
01451 <span class="comment">  TriangleDesc td2(t2,p2);</span>
01452 <span class="comment">  const Vector3&amp; a2=td2[other_side+2];</span>
01453 <span class="comment">  const Vector3&amp; b2=td2[other_side+1];</span>
01454 <span class="comment">  const Vector3&amp; c2=td2[other_side+3];</span>
01455 <span class="comment">  Real t21=-(p1.d+p2.d+a2*n12)/((b2-a2)*n12);</span>
01456 <span class="comment">  TriangleDesc td1(t1,p1);</span>
01457 <span class="comment">  Vector3 P21(a2+t21*(b2-a2));</span>
01458 <span class="comment">  if (td1.pointInTri(P21)) return P21;</span>
01459 <span class="comment">  Real t22=-(p1.d+p2.d+c2*n12)/((b2-c2)*n12);</span>
01460 <span class="comment">  Vector3 P22(c2+t22*(b2-c2));</span>
01461 <span class="comment">  if (td1.pointInTri(P22)) return P22;</span>
01462 <span class="comment">  </span>
01463 <span class="comment">  {</span>
01464 <span class="comment">    Real f1=p2.classify(t1[1]);</span>
01465 <span class="comment">    Real f2=p2.classify(t1[2]);</span>
01466 <span class="comment">    Real f3=p2.classify(t1[3]);</span>
01467 <span class="comment">    Real f12=f1*f2;</span>
01468 <span class="comment">    Real f23=f2*f3;</span>
01469 <span class="comment">    if (f12&gt;0.0 &amp;&amp; f23&gt;0.0) return Vector3::zero;</span>
01470 <span class="comment">    other_side=(f12&lt;0.0?(f23&lt;0.0?1:0):2);</span>
01471 <span class="comment">  }</span>
01472 <span class="comment">  const Vector3&amp; a1=td1[other_side+2];</span>
01473 <span class="comment">  const Vector3&amp; b1=td1[other_side+1];</span>
01474 <span class="comment">  const Vector3&amp; c1=td1[other_side+3];</span>
01475 <span class="comment">  Real t11=-(p1.d+p2.d+a1*n12)/((b1-a1)*n12);</span>
01476 <span class="comment">  Vector3 P11(a1+t11*(b1-a1));</span>
01477 <span class="comment">  if (td2.pointInTri(P11)) return P11;</span>
01478 <span class="comment">  Real t12=-(p1.d+p2.d+c1*n12)/((b1-c1)*n12);</span>
01479 <span class="comment">  Vector3 P12(c1+t12*(b1-c1));</span>
01480 <span class="comment">  if (td2.pointInTri(P12)) return P12;</span>
01481 <span class="comment">  return Point3::zero;</span>
01482 <span class="comment">  */</span>
01483 }
01484 
01485 
01486 <span class="keywordtype">bool</span> Triangle3::contact(<span class="keyword">const</span> Triangle3&amp; t, Contact&amp; contact)<span class="keyword"> const</span>
01487 <span class="keyword"></span>{
01488   <span class="keyword">const</span> Triangle3&amp; t2(*<span class="keyword">this</span>);
01489 
01490   <span class="comment">// C doesn't know about const</span>
01491   <a class="code" href="namespacebase.html#a5">Real</a>* t1p1 = const_cast&lt;Real*&gt;(t.p1().c_array());
01492   <a class="code" href="namespacebase.html#a5">Real</a>* t1p2 = const_cast&lt;Real*&gt;(t.p2().c_array());
01493   <a class="code" href="namespacebase.html#a5">Real</a>* t1p3 = const_cast&lt;Real*&gt;(t.p3().c_array());
01494   <a class="code" href="namespacebase.html#a5">Real</a>* t2p1 = const_cast&lt;Real*&gt;(t2.p1().c_array());
01495   <a class="code" href="namespacebase.html#a5">Real</a>* t2p2 = const_cast&lt;Real*&gt;(t2.p2().c_array());
01496   <a class="code" href="namespacebase.html#a5">Real</a>* t2p3 = const_cast&lt;Real*&gt;(t2.p3().c_array());
01497 
01498   <span class="keywordtype">int</span> coplanar = 0;
01499   <a class="code" href="namespacebase.html#a26">Point3</a> i1, i2;
01500   <span class="keywordtype">int</span> intersected = <a class="code" href="Triangle3_8cpp.html#a23">tri_tri_intersect_with_isectline</a>(t1p1,t1p2,t1p3,
01501                                                      t2p1,t2p2,t2p3,
01502                                                      &amp;coplanar, 
01503                                                      i1.c_array(), i2.c_array());
01504   <span class="keywordflow">if</span> (!intersected) {
01505     contact.type = Contact::None;
01506     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01507   }
01508   
01509     <span class="keywordflow">if</span> (!coplanar) {
01510     <span class="keywordflow">if</span> (i1.equals(i2)) {
01511       contact.type = Contact::Point;
01512       contact.point = i1;
01513       contact.depth = 0;
01514   }
01515     <span class="keywordflow">else</span> {
01516       contact.type = Contact::Segment;
01517       contact.segment = Segment3(i1,i2);<span class="comment"></span>
01518 <span class="comment">      //!!! calculate depth</span>
01519 <span class="comment"></span>      contact.depth = 0;
01520     }
01521   }
01522   <span class="keywordflow">else</span> { <span class="comment">// co-planar triangles</span>
01523     
01524     <span class="comment">// First check the common case, where one triangle in completely</span>
01525     <span class="comment">//  inside the other</span>
01526 
01527     
01528 
01529 
01530   }
01531 
01532   <span class="keywordflow">return</span> <span class="keyword">true</span>;
01533 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:20 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
