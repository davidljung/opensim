<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/MathTest.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/MathTest.cpp</h1><a href="MathTest_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: MathTest.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.12 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="MathTest.html">base/MathTest</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="SVD.html">base/SVD</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="Path.html">base/Path</a>&gt;</span>
00029 
00030 <span class="keyword">using</span> <a class="code" href="classbase_1_1MathTest.html">base::MathTest</a>;
00031 
00032 <span class="keyword">using</span> base::consts;
00033 <span class="keyword">using</span> <a class="code" href="classbase_1_1matrix.html">base::Matrix</a>;
00034 <span class="keyword">using</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>;
00035 <span class="keyword">using</span> <a class="code" href="classbase_1_1SVD.html">base::SVD</a>;
00036 <span class="keyword">using</span> <a class="code" href="classbase_1_1Path.html">base::Path</a>;
00037 
00038 
00039 
00040 MathTest::MathTest()
00041   : I(4,4), A(4,4), S(3,3),
00042     b(4), x(4)
00043 {
00044 }
00045 
00046 
00047 <span class="keywordtype">void</span> MathTest::setUp() 
00048 { 
00049   <span class="comment">// identity</span>
00050   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp0">I</a> = <a class="code" href="namespacebase.html#a101">identityMatrix</a>(4,4);
00051   
00052   <span class="comment">// a matrix with a unique inverse</span>
00053   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(0,0) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(0,1) = -1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(0,2) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(0,3) = 0;
00054   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(1,0) = 2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(1,1) = -2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(1,2) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(1,3) = 2;
00055   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(2,0) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(2,1) = 1;  <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(2,2) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(2,3) = 1;
00056   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(3,0) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(3,1) = 0;  <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(3,2) = 2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(3,3) = 1;
00057   
00058   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp4">b</a>[0] = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp4">b</a>[1] = 4; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp4">b</a>[2] = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp4">b</a>[3] = 5;
00059   
00060   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp5">x</a>[0] = -1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp5">x</a>[1]=-1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp5">x</a>[2] = 2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp5">x</a>[3] = 1; <span class="comment">// Ax=b</span>
00061 
00062   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(0,0) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(0,1) = 2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(0,2) = 3; <span class="comment">// singluar</span>
00063   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(1,0) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(1,1) = 2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(1,2) = 2;
00064   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(2,0) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(2,1) = 2; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(2,2) = 3;
00065   
00066   
00067   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa15">resize</a>(3,9);
00068   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,0) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,1) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,2) = -0.71595; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,3) = -0.13884; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,4) = -0.46236; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,5) = -0.29068; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,6) = 0.06875; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,7) = -0.36885; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(0,8) = -0.24926;
00069   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,0) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,1) = 1; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,2) = 0.94988;  <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,3) = 0.20359;  <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,4) = -0.66261; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,5) = -0.98019; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,6) = -0.55012; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,7) = -0.10177; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(1,8) = 0.23327;
00070   <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,0) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,1) = 0; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,2) = 0;        <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,3) = 0;        <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,4) = -0.11290; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,5) = -0.53204; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,6) = -0.54088; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,7) = -0.60098; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp3">P</a>(2,8) = -0.20846;
00071   
00072 }
00073   
00074 
00075 <span class="keywordtype">void</span> MathTest::tearDown()
00076 { 
00077 }
00078 
00079  
00080 <span class="keywordtype">void</span> MathTest::testMatrixVector()
00081 {
00082   <span class="comment">// just test some elementary Matrix &amp; Vector ops first</span>
00083   <a class="code" href="classbase_1_1matrix.html">Matrix</a> m(3,3);
00084   m = <a class="code" href="namespacebase.html#a101">identityMatrix</a>(3,3);
00085   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;3; r++)
00086     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt;3; c++)
00087       CPPUNIT_ASSERT( m(r,c) == ((r==c)?1:0) );
00088 
00089   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> u(3);
00090   u = <a class="code" href="namespacebase.html#a203">unitVector</a>(3,2);
00091   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a61">equals</a>(<a class="code" href="namespacebase.html#a219">norm_2</a>(u),1) );
00092   CPPUNIT_ASSERT( u[2] == 1 );
00093   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> mr(3), mc(3);
00094   mr = <a class="code" href="namespacebase.html#a82">matrixRow</a>(m,2);
00095   mc = <a class="code" href="namespacebase.html#a84">matrixColumn</a>(m,1);
00096 
00097   CPPUNIT_ASSERT( mr[2] == 1 );
00098   CPPUNIT_ASSERT( mc[1] == 1 );
00099 
00100   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a219">norm_2</a>(<a class="code" href="namespacebase.html#a201">zeroVector</a>(3)) == 0 );
00101 
00102   <a class="code" href="classbase_1_1matrix.html">Matrix</a> z(3,3);
00103   z = <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(3,3);
00104   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a219">norm_2</a>(<a class="code" href="namespacebase.html#a82">matrixRow</a>(z,0)) == 0 );
00105 
00106   <a class="code" href="namespacebase.html#a82">matrixRow</a>(z,0) = <a class="code" href="namespacebase.html#a203">unitVector</a>(3,2); 
00107   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a219">norm_2</a>(<a class="code" href="namespacebase.html#a82">matrixRow</a>(z,0)) == 1 );
00108 
00109   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v6(<a class="code" href="namespacebase.html#a201">zeroVector</a>(6));
00110   <a class="code" href="namespacebase.html#a205">vectorRange</a>(v6,<a class="code" href="namespacebase.html#a30">Range</a>(0,3)) = <a class="code" href="namespacebase.html#a203">unitVector</a>(3,0);
00111   CPPUNIT_ASSERT( v6[0] == 1 );
00112   
00113   <a class="code" href="classbase_1_1matrix.html">Matrix</a> sm(2,2);
00114   sm = <a class="code" href="namespacebase.html#a86">matrixRange</a>(m,<a class="code" href="namespacebase.html#a30">Range</a>(0,2), <a class="code" href="namespacebase.html#a30">Range</a>(0,2));
00115   CPPUNIT_ASSERT( base::equals(sm, <a class="code" href="namespacebase.html#a101">identityMatrix</a>(2,2)) );
00116 
00117   <a class="code" href="classbase_1_1matrix.html">Matrix</a> m1(3,3);
00118   m1(0,0) = 1; m1(0,1) = 2; m1(0,2) = 3;
00119   m1(1,0) = 4; m1(1,1) = 5; m1(1,2) = 6;
00120   m1(2,0) = 7; m1(2,1) = 8; m1(2,2) = 9;
00121 
00122   
00123   <a class="code" href="classbase_1_1matrix.html">Matrix</a> newm1(m1);
00124   <a class="code" href="namespacebase.html#a86">matrixRange</a>(newm1, <a class="code" href="namespacebase.html#a30">Range</a>(0,2), <a class="code" href="namespacebase.html#a30">Range</a>(0,2)) = <a class="code" href="namespacebase.html#a101">identityMatrix</a>(2,2);
00125   CPPUNIT_ASSERT( base::equals( <a class="code" href="namespacebase.html#a86">matrixRange</a>(newm1, <a class="code" href="namespacebase.html#a30">Range</a>(0,2), <a class="code" href="namespacebase.html#a30">Range</a>(0,2)), <a class="code" href="namespacebase.html#a101">identityMatrix</a>(2,2)) );
00126   
00127   
00128   <a class="code" href="classbase_1_1matrix.html">Matrix</a> m2(3,3);
00129   m2(0,0) = 0; m2(0,1) = 3; m2(0,2) = 6;
00130   m2(1,0) = 7; m2(1,1) = 3; m2(1,2) = 5;
00131   m2(2,0) = -4;m2(2,1) = 5; m2(2,2) = -3;
00132   
00133   <span class="comment">// test simple multiplication</span>
00134   <a class="code" href="classbase_1_1matrix.html">Matrix</a> m12(3,3); <span class="comment">// m1*m2</span>
00135   m12(0,0) = 2; m12(0,1) = 24; m12(0,2) = 7;
00136   m12(1,0) = 11;m12(1,1) = 57; m12(1,2) = 31;
00137   m12(2,0) = 20;m12(2,1) = 90; m12(2,2) = 55;
00138 
00139   CPPUNIT_ASSERT( base::equals(m1*m2, m12) );
00140   
00141   
00142   <span class="comment">// and matrix*vector mult</span>
00143   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v1(3);
00144   v1[0] = 2; v1[1] = 5; v1[2] = 7;
00145   
00146   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> m1v1(3);
00147   m1v1[0] = 33; m1v1[1] = 75; m1v1[2] = 117;
00148   
00149   CPPUNIT_ASSERT( base::equals(m1*v1, m1v1) );
00150 
00151   <span class="comment">// test correct negate behaviour</span>
00152   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> n(1); n[0]=1;
00153   -n;
00154   CPPUNIT_ASSERT( base::equals(n[0], 1) );
00155   n = -n;
00156   CPPUNIT_ASSERT( base::equals(n[0], -1) );
00157   
00158   <a class="code" href="classbase_1_1matrix.html">Matrix</a> nm(1,1);
00159   nm(0,0) = 1;
00160   -nm;
00161   CPPUNIT_ASSERT( base::equals(nm(0,0), 1) );
00162   nm = -nm;
00163   CPPUNIT_ASSERT( base::equals(nm(0,0), -1) );
00164   
00165 }
00166 
00167 
00168 <span class="keywordtype">void</span> MathTest::testNullSpace()
00169 {
00170   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> r(3); r[0]=1; r[1]=2; r[2]=3;
00171 
00172   <a class="code" href="classbase_1_1matrix.html">Matrix</a> <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp1">A</a>(3,3);
00173   <a class="code" href="namespacebase.html#a82">matrixRow</a>(A,0) = r;
00174   <a class="code" href="namespacebase.html#a82">matrixRow</a>(A,1) = r;
00175   <a class="code" href="namespacebase.html#a82">matrixRow</a>(A,2) = r;
00176 
00177   <a class="code" href="namespacebase.html#a2">Int</a> rank;
00178   <a class="code" href="namespacebase.html#a5">Real</a> k2;
00179   <a class="code" href="classbase_1_1matrix.html">Matrix</a> Z( Math::nullSpace(A,rank,k2) );
00180 
00181   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a61">equals</a>(rank,2) ); <span class="comment">// rank of null space (not of A)</span>
00182 
00183   CPPUNIT_ASSERT( base::equals(A*Z, <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(3,2), 0.00001) );
00184 
00185   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp5">x</a>(3);
00186   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;10; i++) {
00187     <a class="code" href="namespacebase.html#a5">Real</a> r = Math::random();
00188     <a class="code" href="namespacebase.html#a5">Real</a> s = r-1;
00189     x = <a class="code" href="namespacebase.html#a84">matrixColumn</a>(Z,0)*r + <a class="code" href="namespacebase.html#a84">matrixColumn</a>(Z,1)*s;
00190     CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a61">equals</a>(A*x, <a class="code" href="namespacebase.html#a201">zeroVector</a>(3), 0.00001) );
00191   }
00192 
00193 }
00194 
00195 
00196 <span class="keywordtype">void</span> MathTest::testInverse() 
00197 {
00198   <span class="comment">// check fixture first</span>
00199   <a class="code" href="base.html#a19">Assert</a>( <a class="code" href="namespacebase.html#a61">equals</a>(A*x,b) ); 
00200   <a class="code" href="base.html#a19">Assert</a>( A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() ); <span class="comment">// invert only works for square Matrices</span>
00201 
00202   <span class="comment">// calc inverse and check it's the right size</span>
00203   <a class="code" href="classbase_1_1matrix.html">Matrix</a> Ainv( Math::inverse(A) );
00204   CPPUNIT_ASSERT( Ainv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() );
00205   CPPUNIT_ASSERT( Ainv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() == A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() );
00206 
00207   <span class="comment">// mult A by its inverse, should give same size</span>
00208   <a class="code" href="classbase_1_1matrix.html">Matrix</a> AAinv( A*Ainv );
00209   CPPUNIT_ASSERT( AAinv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() );
00210   CPPUNIT_ASSERT( AAinv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() == Ainv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() );
00211   
00212   <span class="comment">// and = identity</span>
00213   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a61">equals</a>(AAinv, I) );
00214   
00215   <span class="comment">// check we get x back</span>
00216   CPPUNIT_ASSERT( <a class="code" href="namespacebase.html#a61">equals</a>(Ainv*b, x) );
00217 }
00218 
00219 
00220 <span class="keywordtype">void</span> MathTest::testInverseSingular()
00221 {
00222   <span class="comment">// should throw an std::invalid_argument exception</span>
00223   <a class="code" href="classbase_1_1matrix.html">Matrix</a> Sinv( Math::inverse(S) );
00224 }
00225 
00226 
00227 <span class="keywordtype">void</span> MathTest::testSVD() 
00228 {
00229   <span class="comment">// decompose square A</span>
00230   SVD svda(A);
00231   
00232   <a class="code" href="classbase_1_1matrix.html">Matrix</a> U(svda.U());
00233   <a class="code" href="classbase_1_1matrix.html">Matrix</a> V(svda.V());
00234   <a class="code" href="classbase_1_1matrix.html">Matrix</a> <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(svda.S());
00235 
00236   <a class="code" href="classbase_1_1matrix.html">Matrix</a> NA( U * S * <a class="code" href="namespacebase.html#a98">transpose</a>(V) );
00237 
00238   CPPUNIT_ASSERT( NA.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa12">equals</a>(A,0.000001) );
00239 
00240   <span class="comment">// compare singular values with those calc'd using Octave</span>
00241   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> so(4);
00242   so[3] = 3.95858;
00243   so[2] = 2.16562;
00244   so[1] = 1.24951;
00245   so[0] = 0.28007;
00246 
00247   <span class="comment">// sort from lowest to highest</span>
00248   <span class="keywordtype">bool</span> swapped=<span class="keyword">false</span>;
00249   <span class="keywordflow">do</span> {
00250     swapped = <span class="keyword">false</span>;
00251     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;3; i++)
00252     <span class="keywordflow">if</span> (<a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(i,i) &gt; <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(i+1,i+1)) {
00253       <a class="code" href="namespacebase.html#a46">base::swap</a>( <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(i,i), <a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(i+1,i+1) );
00254       swapped=<span class="keyword">true</span>;
00255     }
00256   } <span class="keywordflow">while</span> (swapped);
00257   
00258   <a class="code" href="base.html#a19">Assert</a>(S.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == 4);
00259   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;S.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(); i++) {
00260     CPPUNIT_ASSERT( Math::equals(<a class="code" href="classbase_1_1MathTest.html#base_1_1MathTestp2">S</a>(i,i), so[i], 0.00001) );
00261   }
00262   
00263 
00264   <span class="comment">// and a non-square matrix (underconstrained)</span>
00265   <a class="code" href="classbase_1_1matrix.html">Matrix</a> A1(A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>(), A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>()+2);
00266   <a class="code" href="namespacebase.html#a86">matrixRange</a>(A1, <a class="code" href="namespacebase.html#a30">Range</a>(0,A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>()), <a class="code" href="namespacebase.html#a30">Range</a>(0,A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>())) = A;
00267   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v1( <a class="code" href="namespacebase.html#a201">zeroVector</a>(A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>()) );
00268   v1[0] = 1; v1[1] = 5; v1[2] = -0.2; v1[v1.size()-1] = -4;
00269   <a class="code" href="namespacebase.html#a20">MatrixColumn</a>(A1, A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>()) = v1;
00270   v1[0] = 3; v1[1] = -6; v1[2] = -0.3; v1[v1.size()-1] = 2;
00271   <a class="code" href="namespacebase.html#a20">MatrixColumn</a>(A1, A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>()+1) = v1;
00272   
00273   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> M1 = A1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>();
00274   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> N1 = A1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>();
00275   
00276   SVD svda1(A1);
00277   
00278   <a class="code" href="classbase_1_1matrix.html">Matrix</a> U1(svda1.U());
00279   <a class="code" href="classbase_1_1matrix.html">Matrix</a> V1(svda1.V());
00280   <a class="code" href="classbase_1_1matrix.html">Matrix</a> S1(svda1.S());
00281   
00282   CPPUNIT_ASSERT( U1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>() == M1 );
00283   CPPUNIT_ASSERT( U1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>() == M1 );
00284   CPPUNIT_ASSERT( S1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>() == M1 );
00285   CPPUNIT_ASSERT( S1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>() == N1 );
00286   CPPUNIT_ASSERT( V1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>() == N1 );
00287   CPPUNIT_ASSERT( V1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>() == N1 );
00288   
00289   <a class="code" href="classbase_1_1matrix.html">Matrix</a> NA1( U1 * S1 * <a class="code" href="namespacebase.html#a98">transpose</a>(V1) );
00290 
00291   CPPUNIT_ASSERT( NA1.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa12">equals</a>(A1,0.00001) );
00292 
00293   
00294   <span class="comment">// a non-square matrix (overconstrained)</span>
00295   <a class="code" href="classbase_1_1matrix.html">Matrix</a> A2(A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>()+2, A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>());
00296   <a class="code" href="namespacebase.html#a86">matrixRange</a>(A2, <a class="code" href="namespacebase.html#a30">Range</a>(0,A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>()), <a class="code" href="namespacebase.html#a30">Range</a>(0,A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>())) = A;
00297   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v( <a class="code" href="namespacebase.html#a201">zeroVector</a>(A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>()) );
00298   v[0] = 1; v[1] = 5; v[2] = -0.2; v[v.size()-1] = -4;
00299   <a class="code" href="namespacebase.html#a19">MatrixRow</a>(A2, A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>()) = v;
00300   v[0] = 3; v[1] = -6; v[2] = -0.3; v[v.size()-1] = 2;
00301   <a class="code" href="namespacebase.html#a19">MatrixRow</a>(A2, A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>()+1) = v;
00302   
00303   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a54">M</a> = A2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>();
00304   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a53">N</a> = A2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>();
00305   
00306   SVD svda2(A2);
00307   
00308   <a class="code" href="classbase_1_1matrix.html">Matrix</a> U2(svda2.U());
00309   <a class="code" href="classbase_1_1matrix.html">Matrix</a> V2(svda2.V());
00310   <a class="code" href="classbase_1_1matrix.html">Matrix</a> S2(svda2.S());
00311 
00312   CPPUNIT_ASSERT( U2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>() == <a class="code" href="general_8h.html#a54">M</a> );
00313   CPPUNIT_ASSERT( U2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>() == <a class="code" href="general_8h.html#a54">M</a> );
00314   CPPUNIT_ASSERT( S2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>() == <a class="code" href="general_8h.html#a54">M</a> );
00315   CPPUNIT_ASSERT( S2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>() == <a class="code" href="general_8h.html#a53">N</a> );
00316   CPPUNIT_ASSERT( V2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa6">rows</a>() == <a class="code" href="general_8h.html#a53">N</a> );
00317   CPPUNIT_ASSERT( V2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa7">cols</a>() == <a class="code" href="general_8h.html#a53">N</a> );
00318   
00319   <a class="code" href="classbase_1_1matrix.html">Matrix</a> NA2( U2 * S2 * <a class="code" href="namespacebase.html#a98">transpose</a>(V2) );
00320 
00321   CPPUNIT_ASSERT( NA2.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa12">equals</a>(A2,0.00001) );
00322 }
00323 
00324 
00325 
00326 <span class="keywordtype">void</span> MathTest::testPseudoInverse()
00327 {
00328   <a class="code" href="classbase_1_1matrix.html">Matrix</a> PInv( Math::pseudoInverse(P) );
00329   
00330   <a class="code" href="classbase_1_1matrix.html">Matrix</a> PIO(9,3); <span class="comment">// pinv according to Octave</span>
00331   
00332   PIO(0,0) = 0.5819252;   PIO(0,1) = 0.1170694;  PIO(0,2) = -0.3666462;
00333   PIO(1,0) =  0.1170694;  PIO(1,1) = 0.3703392;  PIO(1,2) = -0.3903029;
00334   PIO(2,0) = -0.3054275;  PIO(2,1) = 0.2679620;  PIO(2,2) = -0.1082405;
00335   PIO(3,0) = -0.0569603;  PIO(3,1) = 0.0591435;  PIO(3,2) = -0.0285566;
00336   PIO(4,0) = -0.3052359;  PIO(4,1) = -0.2554535; PIO(4,2) =  0.2557433;
00337   PIO(5,0) = -0.0888338;  PIO(5,1) = -0.1893758; PIO(5,2) = -0.3232752;
00338   PIO(6,0) =  0.1739168;  PIO(6,1) = 0.0154245;  PIO(6,2) = -0.6364151;
00339   PIO(7,0) = -0.0062102;  PIO(7,1) = 0.1536938;  PIO(7,2) = -0.7427355;
00340   PIO(8,0) = -0.0413108;  PIO(8,1) = 0.1385709;  PIO(8,2) = -0.3179733;
00341 
00342   CPPUNIT_ASSERT( PInv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa12">equals</a>(PIO, 0.00001) );
00343 }
00344 
00345 
00346 
00347 
00348 <span class="keywordtype">void</span> MathTest::testExpression()
00349 {
00350   Expression e(<span class="stringliteral">"tan(0.1)*-2*sin(p[0])+-4.4e-1*((1+1.00)*0.5)/cos(p[0]+0.01+0*(100.0/-3.3e-8))"</span>);
00351   e.simplify();
00352   
00353   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> p(1);
00354   p[0] = consts::Pi/2.0;
00355   
00356   CPPUNIT_ASSERT(Math::equals( e.evaluate(p), Math::tan(0.1)*-2.0*Math::sin(p[0])+-4.4e-1*((1+1)*0.5)/Math::cos(p[0]+0.01) ));
00357 }
00358 
00359 
00360 
00361 
00362 <span class="keywordtype">void</span> MathTest::testPath() 
00363 {
00364   <span class="comment">// check default path is 0</span>
00365   Path zp;
00366   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a5">Real</a> t=0.0; t&lt;=1.0; t+=0.05) {
00367     CPPUNIT_ASSERT( zp.position(t).equalsZero() );
00368     CPPUNIT_ASSERT( zp.orientation(t).getVector3(Orient::EulerRPY).equalsZero() );
00369   }
00370 
00371   <span class="comment">// unit length const orientation line segment</span>
00372   <a class="code" href="namespacebase.html#a26">Point3</a> p1(1,1,1);
00373   <a class="code" href="namespacebase.html#a26">Point3</a> p2(2,2,2);
00374   Path up(p1,Orient(),p2,Orient());
00375   CPPUNIT_ASSERT( up.position(0.0).equals(p1) );
00376   CPPUNIT_ASSERT( up.position(1.0).equals(p2) );
00377   CPPUNIT_ASSERT( up.position(0.5).equals(<a class="code" href="namespacebase.html#a26">Point3</a>(1.5,1.5,1.5)) );
00378   CPPUNIT_ASSERT( up.orientation(0.5).getVector3(Orient::EulerRPY).equalsZero() );
00379 
00380   <span class="comment">// test interpolation of both pos &amp; orient</span>
00381   Quat4 q1(Vector3(0,0,1),consts::Pi/4.0);
00382   Quat4 q2(Vector3(0,0,1),consts::Pi/2.0);
00383   Orient o1(q1), o2(q2);
00384   Path path(p1,o1,p2,o2);
00385   CPPUNIT_ASSERT( path.position(0.0).equals(p1) );
00386   CPPUNIT_ASSERT( path.position(1.0).equals(p2) );
00387   CPPUNIT_ASSERT( path.position(0.5).equals(<a class="code" href="namespacebase.html#a26">Point3</a>(1.5,1.5,1.5)) );
00388   CPPUNIT_ASSERT( path.orientation(0.0).equals(o1) );
00389   CPPUNIT_ASSERT( path.orientation(1.0).equals(o2) );
00390   CPPUNIT_ASSERT( path.orientation(0.5).equals(Orient::interpolate(o1,o2,0.5)) );
00391 
00392   array&lt;Point3&gt; ps(3);
00393   array&lt;Orient&gt; os(3);
00394   ps[0] = p1; ps[1] = <a class="code" href="namespacebase.html#a26">Point3</a>(1.5,3.0,-2.5); ps[2] = p2;
00395   Quat4 q3(Vector3(0,0,1),consts::Pi/3.0);
00396   Orient o3(q3);
00397   os[0] = o1; os[1] = o3; os[2] = o2;
00398   Path wpath(ps,os);
00399   CPPUNIT_ASSERT( wpath.position(0.0).equals(p1) );
00400   CPPUNIT_ASSERT( wpath.position(1.0).equals(p2) );
00401   CPPUNIT_ASSERT( wpath.position(0.5).equals(<a class="code" href="namespacebase.html#a26">Point3</a>(1.53099,2.93802,-2.22108),1e-4) );
00402   CPPUNIT_ASSERT( wpath.position(0.6).equals(<a class="code" href="namespacebase.html#a26">Point3</a>(1.62479,2.75042,-1.37687),1e-4) );
00403   CPPUNIT_ASSERT( wpath.position(0.8).equals(<a class="code" href="namespacebase.html#a26">Point3</a>(1.8124,2.37521,0.311566),1e-4) );
00404 
00405   CPPUNIT_ASSERT( wpath.orientation(0.0).equals(o1) );
00406   CPPUNIT_ASSERT( wpath.orientation(1.0).equals(o2) );
00407 
00408   <span class="comment">// construct an orientation only (const position) path to test orientatin interpolation</span>
00409   ps.clear();
00410   Path wpath2(ps,os);
00411   CPPUNIT_ASSERT( wpath2.orientation(0.0).equals(o1) );
00412   CPPUNIT_ASSERT( wpath2.orientation(1.0).equals(o2) );
00413   CPPUNIT_ASSERT( wpath2.orientation(0.5).getQuat4().equals(Quat4(Vector3(0,0,1),3.0*consts::Pi/8.0)) );
00414   
00415   
00416   <span class="comment">// a parametric path</span>
00417   <a class="code" href="namespacebase.html#a17">ExpressionVector</a> v(3);
00418   v[0] = <a class="code" href="namespacebase.html#a65">base::cos</a>( Expression::p[0] * 2.0 * consts::Pi ); v[0].simplify();
00419   v[1] = <a class="code" href="namespacebase.html#a64">base::sin</a>( Expression::p[0] * 2.0 * consts::Pi ); v[1].simplify();
00420   v[2] = 0;
00421   Path unitcircle(v);
00422   
00423   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a5">Real</a> s=0.0; s&lt;=1.0; s+=1/100.0) {
00424     <a class="code" href="namespacebase.html#a26">Point3</a> p( Math::cos(s*2.0*consts::Pi), Math::sin(s*2.0*consts::Pi), 0);
00425     CPPUNIT_ASSERT( unitcircle.position(s).equals(p) );
00426   }
00427   
00428 }
00429 
00430 
00431 <span class="preprocessor">#ifdef DEBUG</span>
00432 <span class="preprocessor"></span>CPPUNIT_TEST_SUITE_REGISTRATION( MathTest );
00433 <span class="preprocessor">#endif</span>
00434 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:06 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
