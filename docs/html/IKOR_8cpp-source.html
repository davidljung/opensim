<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: robot/control/kinematics/IKOR.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>robot/control/kinematics/IKOR.cpp</h1><a href="IKOR_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment"></span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment"></span>
00018 <span class="comment">  $Id: IKOR.cpp 1080 2004-07-28 19:51:26Z jungd $</span>
00019 <span class="comment">  $Revision: 1.17 $</span>
00020 <span class="comment">  $Date: 2004-07-28 15:51:26 -0400 (Wed, 28 Jul 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"></span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="IKOR.html">robot/control/kinematics/IKOR</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="solution__error.html">robot/control/kinematics/solution_error</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="SVDFullSpaceSolver.html">robot/control/kinematics/SVDFullSpaceSolver</a>&gt;</span>
00029 <span class="preprocessor">#include &lt;<a class="code" href="Optimizer.html">robot/control/kinematics/Optimizer</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;<a class="code" href="ReferenceOpVectorFormObjective.html">robot/control/kinematics/ReferenceOpVectorFormObjective</a>&gt;</span>
00031 <span class="preprocessor">#include &lt;<a class="code" href="AnalyticLagrangianFSBetaOptimizer.html">robot/control/kinematics/AnalyticLagrangianFSBetaOptimizer</a>&gt;</span>
00032 <span class="preprocessor">#include &lt;<a class="code" href="AnalyticLagrangianNullSpaceBetaOptimizer.html">robot/control/kinematics/AnalyticLagrangianNullSpaceBetaOptimizer</a>&gt;</span>
00033 
00034 
00035 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1IKOR.html">robot::control::kinematics::IKOR</a>;
00036 
00037 <span class="keyword">using</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>;
00038 <span class="keyword">using</span> <a class="code" href="classbase_1_1Orient.html">base::Orient</a>;
00039 <span class="keyword">using</span> base::dot;
00040 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1SVDFullSpaceSolver.html">robot::control::kinematics::SVDFullSpaceSolver</a>;
00041 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1ReferenceOpVectorFormObjective.html">robot::control::kinematics::ReferenceOpVectorFormObjective</a>;
00042 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1BetaFormConstraints.html">robot::control::kinematics::BetaFormConstraints</a>;
00043 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1AnalyticLagrangianFSBetaOptimizer.html">robot::control::kinematics::AnalyticLagrangianFSBetaOptimizer</a>;
00044 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1AnalyticLagrangianNullSpaceBetaOptimizer.html">robot::control::kinematics::AnalyticLagrangianNullSpaceBetaOptimizer</a>;
00045 
00046 
<a name="l00047"></a><a class="code" href="IKOR_8cpp.html#a0">00047</a> <span class="keyword">const</span> Real <a class="code" href="IKOR_8cpp.html#a0">small</a> = 5.0e-05;
00048 
00049 
00050 IKOR::IKOR(<span class="keyword">const</span> <a class="code" href="classrobot_1_1KinematicChain.html">robot::KinematicChain</a>&amp; chain, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; jointWeights,
00051            <span class="keywordtype">bool</span> nonHolonomicPlatformActive, Real platformL)
00052   : chain(chain), weights(jointWeights),
00053     nonHolonomicPlatformActive(nonHolonomicPlatformActive), L(platformL)
00054 {
00055   <span class="keywordflow">if</span> (weights.size() == 0) {
00056     weights.reset(<a class="code" href="classdemeter_1_1Vector.html">Vector</a>(chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina6">dof</a>()));
00057     <span class="keywordflow">for</span>(Int i=0; i&lt;weights.size(); i++) weights[i]=1.0;
00058   }
00059 
00060   solver = ref&lt;SVDFullSpaceSolver&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1SVDFullSpaceSolver.html">SVDFullSpaceSolver</a>());
00061 }
00062 
00063 
00064 
00065 <span class="keywordtype">bool</span> IKOR::isConstraintTypeSupported(OptimizationConstraint  optConstraint,
00066                                          OptimizationMethod      optMethod,
00067                                          OptimizationCriterion   optCriterion)
00068 {
00069   <span class="keywordflow">if</span> (optMethod==DefaultMethod) optMethod=Lagrangian;
00070   <span class="keywordflow">if</span> (optCriterion==DefaultCriterion) optCriterion=LeastNorm;
00071 
00072   <span class="keywordflow">if</span> (optMethod == Lagrangian) {
00073 
00074     <span class="keywordflow">if</span> (optCriterion == LeastNorm) {
00075 
00076       <span class="keywordflow">return</span> (   (optConstraint == JointLimits)
00077               || (optConstraint == ObstacleAvoidance) );
00078 
00079     }
00080 
00081   }
00082 
00083   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00084 }
00085 
00086 
00087 <a class="code" href="classdemeter_1_1Vector.html">Vector</a> IKOR::solve(<span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; dx, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; q,
00088                    <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">base::Matrix</a>&amp; J,
00089                    OptimizationMethod    optMethod,
00090                    OptimizationCriterion optCriterion,
00091                    OptimizationConstraints optConstraints,
00092                    <a class="code" href="classbase_1_1Orient.html#base_1_1Orientw0">base::Orient::Representation</a>  orientationRepresentation)
00093 {
00094   <span class="keywordflow">if</span> (optMethod==DefaultMethod) optMethod=Lagrangian;
00095   <span class="keywordflow">if</span> (optCriterion==DefaultCriterion) optCriterion=LeastNorm;
00096   <span class="keywordflow">if</span> (optConstraints.test(DefaultConstraints)) optConstraints.reset();
00097 
00098   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a53">N</a> = J.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(); <span class="comment">// rows</span>
00099   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a54">M</a> = J.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>(); <span class="comment">// cols</span>
00100 
00101   <a class="code" href="base.html#a19">Assert</a>(dx.size() == x.size());
00102   <a class="code" href="base.html#a19">Assert</a>(q.size() == <a class="code" href="general_8h.html#a54">M</a>);
00103 
00104   <span class="comment">// First, convert the orientation component of dx (if any) to</span>
00105   <span class="comment">//  angular velocity (omega)</span>
00106   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> newdx;
00107   <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>&gt;3) {
00108     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> dpos(3);
00109     dpos = <a class="code" href="namespacebase.html#a205">vectorRange</a>(dx,<a class="code" href="namespacebase.html#a30">Range</a>(0,3));
00110     Orient orient(<a class="code" href="namespacebase.html#a205">vectorRange</a>(x,<a class="code" href="namespacebase.html#a30">Range</a>(3,x.size())),orientationRepresentation);
00111     Orient dorient(<a class="code" href="namespacebase.html#a205">vectorRange</a>(dx,<a class="code" href="namespacebase.html#a30">Range</a>(3,dx.size())),orientationRepresentation);
00112     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> omega(3);
00113     omega = orient.getBinv()*<a class="code" href="classdemeter_1_1Vector.html">Vector</a>(dorient); <span class="comment">// w = B(o)^-1 . do/dt</span>
00114     newdx.resize(6);
00115     <a class="code" href="namespacebase.html#a205">vectorRange</a>(newdx,<a class="code" href="namespacebase.html#a30">Range</a>(0,3)) = dpos;
00116     <a class="code" href="namespacebase.html#a205">vectorRange</a>(newdx,<a class="code" href="namespacebase.html#a30">Range</a>(3,6)) = omega;
00117   }
00118   <span class="keywordflow">else</span>
00119     newdx.reset(dx);
00120 
00121   <a class="code" href="base.html#a19">Assert</a>(newdx.size() == <a class="code" href="general_8h.html#a53">N</a>);
00122 
00123   <span class="keywordtype">bool</span> nullSpaceMotion = <a class="code" href="namespacebase.html#a61">base::equals</a>(dx,<a class="code" href="namespacebase.html#a201">zeroVector</a>(N),small);
00124 
00125 
00126   <span class="comment">// First use the FullSpaceSolver to obtain the g Vectors</span>
00127   array&lt;Int&gt; dependentRowsEliminated;
00128   <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; b(newdx);
00129   <a class="code" href="classbase_1_1matrix.html">Matrix</a> gs;
00130   <span class="keywordflow">try</span> {
00131     gs = solver-&gt;solve(J, b, dependentRowsEliminated); <span class="comment">// gis are the columns Vectors of gs</span>
00132   } <span class="keywordflow">catch</span> (std::exception&amp; e) {
00133     <span class="keywordflow">throw</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1solution__error.html">solution_error</a>(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Unable to generate solution space for the given dx in the current state (impossible motion?) - FSP failed:"</span>)+e.what()));
00134   }
00135 
00136   <span class="comment">// Which concrete Optimizer and corresponding Objective and Constraints</span>
00137   <span class="comment">//  get instantiated, depends on the opt&lt;X&gt; parameters</span>
00138   ref&lt;Optimizer&gt;              optimizer;
00139   ref&lt;Optimizer::Objective&gt;   objective;
00140   ref&lt;Optimizer::Constraints&gt; constraints;
00141 
00142   ref&lt;LagrangianOptimizer&gt; lagOptimizer;
00143 
00144 
00145   <span class="comment">//</span>
00146   <span class="comment">// First we run the optimization with only constraints</span>
00147   <span class="comment">//  due to dependent rows (&amp; the platform non-holonomic constraint if appropriate)</span>
00148   <span class="comment">// Next, we test for violation of any other constrant types</span>
00149   <span class="comment">//  such as joint limit or obstacle constraints.</span>
00150   <span class="comment">//  If any constraints were violated we add them in and run the optimization</span>
00151   <span class="comment">//  again.  This is repeated until all constraints are satisfied.</span>
00152 
00153 
00154   <span class="keywordflow">if</span> (optMethod==Lagrangian) {
00155 
00156     <span class="comment">// First setup the objective function</span>
00157     <span class="comment">//  - the objective is defined in terms of the Matrix B and Vector dZr</span>
00158     <a class="code" href="classbase_1_1matrix.html">Matrix</a> B(M,M);
00159     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> dZr(M);
00160 
00161     <span class="keywordflow">switch</span> (optCriterion) {
00162     <span class="keywordflow">case</span> LeastNorm: weightedLeastNorm(B,dZr, weights); <span class="keywordflow">break</span>;
00163     <span class="keywordflow">case</span> LeastFlow: <span class="keywordflow">throw</span> std::runtime_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"LeastFlow criteria not implemented for Larganrian method."</span>));
00164     <span class="keywordflow">default</span>:
00165       <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"unsupported/unknown criteria for Largangian Method"</span>));
00166     }
00167 
00168     ref&lt;ReferenceOpVectorFormObjective&gt; rovfObjective(NewObj <a class="code" href="classrobot_1_1control_1_1kinematics_1_1ReferenceOpVectorFormObjective.html">ReferenceOpVectorFormObjective</a>());
00169     objective = rovfObjective;
00170     rovfObjective-&gt;setB(B);
00171     rovfObjective-&gt;setdZr(dZr);
00172 
00173 
00174     <span class="comment">// setup constraints for first optimization step</span>
00175     ref&lt;BetaFormConstraints&gt; betaconstraints(NewObj <a class="code" href="classrobot_1_1control_1_1kinematics_1_1BetaFormConstraints.html">BetaFormConstraints</a>());
00176     constraints = betaconstraints;
00177     betaconstraints-&gt;clear();
00178 
00179     <span class="keywordflow">if</span> (nonHolonomicPlatformActive)
00180       addNonholonomicConstraint(gs, q, betaconstraints);
00181 
00182 
00183     <span class="keywordflow">if</span> (dependentRowsEliminated.size() &gt; 0)
00184       addDependentRowConstraints(dependentRowsEliminated, gs, J, b, betaconstraints);
00185 
00186 
00187     <span class="comment">// create the Optimizer</span>
00188     <span class="keywordflow">if</span> (!nullSpaceMotion)
00189       lagOptimizer = ref&lt;AnalyticLagrangianFSBetaOptimizer&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> AnalyticLagrangianFSBetaOptimizer());
00190     <span class="keywordflow">else</span>
00191       lagOptimizer = ref&lt;AnalyticLagrangianNullSpaceBetaOptimizer&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> AnalyticLagrangianNullSpaceBetaOptimizer());
00192     lagOptimizer-&gt;setGs(gs);
00193     optimizer = lagOptimizer;
00194 
00195   }
00196   <span class="keywordflow">else</span>
00197     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"unimplemented optimization method"</span>));
00198 
00199 
00200   <span class="comment">// Now use the optimizer, objective and constraints to narrow the solution</span>
00201   <span class="comment">//  space down to a single dq Vector</span>
00202   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> dq(M);
00203 
00204   <span class="keywordflow">try</span> {
00205 <span class="comment">//Debugln(DJ,"++++++++++++ optimizing1");</span>
00206     dq = optimizer-&gt;optimize(objective, constraints);
00207 
00208   } <span class="keywordflow">catch</span> (<a class="code" href="classrobot_1_1control_1_1kinematics_1_1solution__error.html">solution_error</a>&amp; e) {
00209     dq = <a class="code" href="namespacebase.html#a201">zeroVector</a>(M);
00210     <span class="keywordflow">throw</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1solution__error.html">solution_error</a>(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Unable to solve for the given dx in the current state - optimization failed:"</span>)+e.what()),e);
00211   }
00212 <span class="comment"></span>
00213 <span class="comment">//!!! this loop will probably cause some constraints to be added in more than once - FIX</span>
00214 <span class="comment"></span>
00215   <span class="comment">// Now loop adding extra constraints for any constraint types that are violated,</span>
00216   <span class="comment">//  until all are satisfied.</span>
00217   <a class="code" href="namespacebase.html#a2">Int</a> numConstraints;
00218   <span class="keywordflow">do</span> {
00219     numConstraints = constraints-&gt;numConstraints(); <span class="comment">// initial no. of constraints</span>
00220 
00221 
00222 
00223     <span class="comment">// check for other constraint violations and add them</span>
00224     <span class="keywordflow">if</span> (optMethod == Lagrangian) {
00225 
00226       ref&lt;BetaFormConstraints&gt; betaconstraints(narrow_ref&lt;BetaFormConstraints&gt;(constraints));
00227 
00228       <span class="comment">// add constraint that are always active</span>
00229       betaconstraints-&gt;clear();
00230       <span class="keywordflow">if</span> (nonHolonomicPlatformActive)
00231         addNonholonomicConstraint(gs, q, betaconstraints);
00232       <span class="keywordflow">if</span> (dependentRowsEliminated.size() &gt; 0)
00233         addDependentRowConstraints(dependentRowsEliminated, gs, J, b, betaconstraints);
00234 
00235       <span class="comment">// add constraints for any other constraint types that</span>
00236       <span class="comment">// are violated</span>
00237       <span class="keywordflow">if</span> (optConstraints.test(JointLimits)) {
00238         addJointLimitConstraints(gs, q, dq, betaconstraints);
00239       }
00240 
00241       <span class="keywordflow">if</span> (optConstraints.test(ObstacleAvoidance))
00242         addObstacleAvoidanceConstraints(gs, q, dq, betaconstraints);
00243 
00244     }
00245     <span class="keywordflow">else</span>
00246       <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"unimplemented optimization method"</span>));
00247 
00248 
00249     <span class="keywordflow">if</span> ( constraints-&gt;numConstraints() &gt; numConstraints) {
00250 
00251       <span class="comment">// more were added, run the optimizer again</span>
00252       <span class="keywordflow">try</span> {
00253 <a class="code" href="debugtools.html#a11">Debugcln</a>(DJ,<span class="stringliteral">"optimizing2:"</span>);
00254 <a class="code" href="debugtools.html#a11">Debugcln</a>(DJ,<span class="stringliteral">"constraints:\n"</span> &lt;&lt; *constraints);
00255 <a class="code" href="debugtools.html#a11">Debugcln</a>(DJ,<span class="stringliteral">" extra constraints:"</span> &lt;&lt; (constraints-&gt;numConstraints()-numConstraints));
00256         dq = optimizer-&gt;optimize(objective, constraints);
00257 
00258       } <span class="keywordflow">catch</span> (<a class="code" href="classrobot_1_1control_1_1kinematics_1_1solution__error.html">solution_error</a>&amp; e) {
00259         dq = <a class="code" href="namespacebase.html#a201">zeroVector</a>(M);
00260         <span class="keywordflow">throw</span> <a class="code" href="classrobot_1_1control_1_1kinematics_1_1solution__error.html">solution_error</a>(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Unable to solve for the given dx in the current state - optimization failed:"</span>)+e.what()),e);
00261       }
00262 
00263     }
00264 
00265 
00266   } <span class="keywordflow">while</span> ( constraints-&gt;numConstraints() &gt; numConstraints); <span class="comment">// keep repeating as long as more were added</span>
00267 <span class="comment">//Debugcln(DJ,"opt done dq=" &lt;&lt; dq);</span>
00268 
00269   <span class="keywordflow">return</span> dq;
00270 }
00271 
00272 
00273 <span class="keywordtype">void</span> IKOR::setProximitySensorData(<span class="keyword">const</span> array&lt;LinkProximityData&gt;&amp; proximityData, Real d)
00274 {
00275   proximitySensorData = proximityData;
00276   this-&gt;d = d;
00277 }
00278 
00279 
00280 
00281 <span class="keywordtype">void</span> IKOR::setParameter(<span class="keyword">const</span> String&amp; name, Real value)
00282 {
00283   <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"unknown parameter name"</span>));
00284 }
00285 
00286 
00287 
00288 <span class="keywordtype">void</span> IKOR::weightedLeastNorm(<a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; B, <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; dZr, <a class="code" href="classdemeter_1_1Vector.html">Vector</a> weights)
00289 {
00290   <span class="comment">// for least norm criteria, B is the identity &amp; dZr=0</span>
00291   dZr = <a class="code" href="namespacebase.html#a201">zeroVector</a>(dZr.size());
00292 
00293   <span class="comment">// set B to identity</span>
00294   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> j=0; j&lt;B.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>(); j++)
00295     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;B.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(); i++)
00296       B(i,j) = (i!=j)?0:weights[i];
00297 }
00298 
00299 
00300 IKOR::RankLossBetaConstraint::RankLossBetaConstraint(Int row, <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; A, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; b, <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; gs)
00301   : row(row)
00302 {
00303   setName(<a class="code" href="namespacebase.html#a58">className</a>());
00304 
00305   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> span=gs.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>();
00306   beta.resize(span);
00307   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> Ar(<a class="code" href="namespacebase.html#a82">matrixRow</a>(A,row));
00308 
00309   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;span; i++)
00310     beta[i] = <a class="code" href="namespacebase.html#a209">dot</a>(Ar, <a class="code" href="namespacebase.html#a82">matrixRow</a>(gs,i) ) / b[row];
00311 
00312 }
00313 
00314 
00315 <span class="keywordtype">void</span> IKOR::addDependentRowConstraints(<span class="keyword">const</span> array&lt;Int&gt;&amp; rows, <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; gs, <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; A, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; b, ref&lt;BetaFormConstraints&gt; constraints)
00316 {
00317   <span class="comment">// add one beta per row</span>
00318   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;rows.size(); i++)
00319     constraints-&gt;addConstraint(ref&lt;BetaFormConstraints::BetaFormConstraint&gt;(NewObj RankLossBetaConstraint(rows[i], A, b, gs)) );
00320 }
00321 
00322 
00323 
00324 
00325 <span class="keywordtype">void</span> IKOR::addJointLimitConstraints(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; gs, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; q, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; dq, ref&lt;BetaFormConstraints&gt; constraints)
00326 {
00327   <span class="comment">// iterate through the joints and check if they will be moved out of limits by dq.</span>
00328   <span class="comment">//  If so, create a constraint</span>
00329   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a54">M</a> = gs.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>();
00330   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> tq(q+dq); <span class="comment">// target q</span>
00331 
00332   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> v=0; v&lt;<a class="code" href="general_8h.html#a54">M</a>; v++) { <span class="comment">// for each variable/component of q</span>
00333 
00334     <span class="comment">// check if there are limits</span>
00335     <a class="code" href="namespacebase.html#a5">Real</a> minValue = chain.variableMinLimit(v);
00336     <a class="code" href="namespacebase.html#a5">Real</a> maxValue = chain.variableMaxLimit(v);
00337     <span class="keywordtype">bool</span> hasMinLimit = <span class="keyword">true</span>;
00338     <span class="keywordtype">bool</span> hasMaxLimit = <span class="keyword">true</span>;
00339     <span class="keywordflow">if</span> (chain.variableUnitType(v)==KinematicChain::Angle) { <span class="comment">// angle</span>
00340       <span class="keywordflow">if</span> (  (Math::equals(minValue, KinematicChain::unboundedMinAngleLimit))
00341           ||(Math::equals(maxValue, KinematicChain::unboundedMaxAngleLimit)) ) {
00342         hasMinLimit = hasMaxLimit = <span class="keyword">false</span>;
00343       }
00344     }
00345     <span class="keywordflow">else</span> { <span class="comment">// distance</span>
00346       <span class="keywordflow">if</span> (Math::equals(minValue, KinematicChain::unboundedMinDistLimit,999))
00347         hasMinLimit = <span class="keyword">false</span>;
00348       <span class="keywordflow">if</span> (Math::equals(maxValue, KinematicChain::unboundedMaxDistLimit,999))
00349         hasMaxLimit = <span class="keyword">false</span>;
00350     }
00351 
00352 
00353     <span class="keywordflow">if</span> (hasMinLimit &amp;&amp; (tq[v] &lt; minValue)) {
00354       <a class="code" href="debugtools.html#a11">Debugcln</a>(IKOR,<span class="stringliteral">"v:"</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">" m"</span> &lt;&lt; Math::radToDeg(minValue) &lt;&lt; <span class="stringliteral">" &gt; "</span> &lt;&lt; Math::radToDeg(tq[v]) );
00355       constraints-&gt;addConstraint(
00356          ref&lt;BetaFormConstraints::BetaFormConstraint&gt;(NewObj JointLimitBetaConstraint(v,minValue-tq[v],gs))
00357        );
00358     }
00359 
00360     <span class="keywordflow">if</span> (hasMaxLimit &amp;&amp; (tq[v] &gt; maxValue)) {
00361       <a class="code" href="debugtools.html#a11">Debugcln</a>(IKOR,<span class="stringliteral">"v:"</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">" m"</span> &lt;&lt; Math::radToDeg(maxValue) &lt;&lt; <span class="stringliteral">" &lt; "</span> &lt;&lt; Math::radToDeg(tq[v]) );
00362       constraints-&gt;addConstraint(
00363         ref&lt;BetaFormConstraints::BetaFormConstraint&gt;(NewObj JointLimitBetaConstraint(v,maxValue-tq[v],gs))
00364       );
00365     }
00366 
00367   }
00368   <span class="comment">//Debugcln(IKOR,"");</span>
00369 }
00370 
00371 
00372 
00373 <span class="keywordtype">void</span> IKOR::addNonholonomicConstraint(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; gs, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; q, ref&lt;BetaFormConstraints&gt; constraints)
00374 {
00375   <span class="comment">// assume the platform parameters are the first three components of q, namely xp, yp, and thetap</span>
00376   <span class="comment">//  (i.e. 2D platform) - (in the paper they are the last three)</span>
00377 
00378   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> alpha(gs.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>());
00379 
00380   <a class="code" href="namespacebase.html#a5">Real</a> sqm = Math::sin(q[2]);
00381   <a class="code" href="namespacebase.html#a5">Real</a> cqm = Math::cos(q[2]);
00382   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;gs.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>(); i++) {
00383     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> gi( <a class="code" href="namespacebase.html#a84">matrixColumn</a>(gs,i) );
00384     alpha[i] = -sqm*gi[0] + cqm*gi[1] - L*gi[2];
00385   }
00386 <span class="comment">//Debugln(DJ,"alpha=" &lt;&lt; alpha);</span>
00387   constraints-&gt;setAlphaConstraint(alpha);
00388 }
00389 
00390 
00391 
00392 
00393 IKOR::PushAwayBetaConstraint::PushAwayBetaConstraint(Int v, Real Xvx,
00394                                                      <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; n, Real L,
00395                                                      <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; gs,
00396                                                      <span class="keyword">const</span> <a class="code" href="classrobot_1_1KinematicChain.html">robot::KinematicChain</a>&amp; chain, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; q)
00397   : v(v), Xvx(Xvx), n(n), L(L)
00398 {
00399   setName(<a class="code" href="namespacebase.html#a58">className</a>());
00400 
00401   <span class="comment">// see "Resolving Kinematic Redundancy with Constraints Using the FSP (Full Space Parameterization) Approach,</span>
00402   <span class="comment">//   Pin, Tulloch et.al. for a description of the obstacle constraint formulation</span>
00403 
00404   <span class="comment">// compute JXq, the Jacobian of the chain truncated at the push-away point, evaluated at q</span>
00405   <a class="code" href="namespacebase.html#a2">Int</a> l = chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina13">linkIndexOfVariable</a>(v);
00406   KinematicChain chainX; <span class="comment">// truncated chain</span>
00407   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> li=0; li&lt;l-1; li++) <span class="comment">// copy links before l</span>
00408     chainX += chain[li];
00409 
00410   <span class="comment">// now add shortened l link</span>
00411 <span class="comment">//Not sure how to achieve this. For now assume that the link is DH type and that d is 0, then</span>
00412 <span class="comment">//just shorten a</span>
00413   KinematicChain::Link ll(chain[l]);
00414   <a class="code" href="base.html#a21">Assertm</a>(ll.isDHType() &amp;&amp; Math::equals(ll.getD(),0), <span class="stringliteral">"is DH link &amp; d==0 (current impl. can't handle general case)"</span>);
00415   ll.setA(Xvx);
00416   chainX += ll;
00417 
00418   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> ql( chainX.dof() );
00419   ql = <a class="code" href="namespacebase.html#a205">vectorRange</a>( q, <a class="code" href="namespacebase.html#a30">Range</a>(0,ql.size()  ) );
00420 <span class="comment"></span>
00421 <span class="comment">//!!! debug -- dump 'push-away' point</span>
00422 <span class="comment"></span><span class="comment">//Matrix t( chainX.getForwardKinematics(ql) );</span>
00423 <span class="comment">//Debugln(DJ,"push away point (v=" &lt;&lt; v &lt;&lt; ":l=" &lt;&lt; l &lt;&lt; ")=" &lt;&lt; matrixColumn(t,3) &lt;&lt; " n=" &lt;&lt; n);</span><span class="comment"></span>
00424 <span class="comment">//!!!</span>
00425 <span class="comment"></span>
00426 
00427   <a class="code" href="classbase_1_1matrix.html">Matrix</a> JXq( chainX.getJacobian( ql, <span class="keyword">false</span> ) );
00428 <span class="comment">//Debugln(DJ,"v=" &lt;&lt; v &lt;&lt; " l=" &lt;&lt; l &lt;&lt; "chainX.size()=" &lt;&lt; chainX.size() &lt;&lt; " chainX.dof()=" &lt;&lt; chainX.dof());</span>
00429   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> span=gs.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>();
00430   <a class="code" href="namespacebase.html#a2">Int</a> m( ql.size() ); <span class="comment">// name used in paper</span>
00431   beta.resize(span);
00432 <span class="comment">//Debugln(DJ,"\nJX(q).q=" &lt;&lt; JXq*ql);</span>
00433   <span class="comment">// now evaluate beta (refer to paper for variable meanings)</span>
00434   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> k=0; k&lt;span; k++) {
00435     beta[k] = 0;
00436     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> gk( <a class="code" href="namespacebase.html#a84">matrixColumn</a>(gs, k) );
00437     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;3; i++) {
00438       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> j=0; j&lt;m; j++) {
00439 <span class="comment">//      Debugln(DJ,"k=" &lt;&lt; k &lt;&lt; " beta.size()=" &lt;&lt; beta.size() &lt;&lt; " span=" &lt;&lt; span);</span>
00440 <span class="comment">//      Debugcln(DJ,"i=" &lt;&lt; i &lt;&lt; " j=" &lt;&lt; j &lt;&lt; " JXq.size1()=" &lt;&lt; JXq.size1() &lt;&lt; " JXq.size2()=" &lt;&lt; JXq.size2()</span>
00441 <span class="comment">//      &lt;&lt; " gk.size()=" &lt;&lt; gk.size() &lt;&lt; " n.size()=" &lt;&lt; n.size());</span>
00442         beta[k] += JXq(i,j) * gk[j] * n[i];
00443 
00444       }
00445     }
00446     beta[k] /= L;
00447   }
00448 
00449 }
00450 
00451 
00452 
00453 
00454 <span class="keywordtype">void</span> IKOR::addObstacleAvoidanceConstraints(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; gs, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; q, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; dq, ref&lt;BetaFormConstraints&gt; constraints)
00455 {
00456   <span class="keywordflow">if</span> (proximitySensorData.size() == 0) <span class="keywordflow">return</span>; <span class="comment">// no proximity sensor data provided</span>
00457 
00458   <span class="comment">// if any data provided, must be data for each dof</span>
00459   <a class="code" href="base.html#a19">Assert</a>( proximitySensorData.size() == chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina6">dof</a>() );
00460 
00461   <span class="comment">// check for obstacle proximity to each 'link'</span>
00462   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> v=0; v&lt;chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina6">dof</a>(); v++) { <span class="comment">// for each variable (i.e. element of q)</span>
00463 
00464     LinkProximityData&amp; pd( proximitySensorData[v] );
00465 
00466     <span class="keywordflow">if</span> (pd.distance &lt; d) {
00467       <span class="keywordflow">if</span> (!pd.direction.equals( <a class="code" href="namespacebase.html#a201">zeroVector</a>(3) )) { <span class="comment">// ignore if direction is unknown</span>
00468         <span class="comment">// something is within the proximity sensor range of this 'link' &amp; within the 'danger' envelope</span>
00469         <a class="code" href="namespacebase.html#a5">Real</a> L = d - pd.distance + 1e-4; <span class="comment">// desired 'push-away' distance</span>
00470         <a class="code" href="classdemeter_1_1Vector.html">Vector</a> n( -pd.direction ); <span class="comment">// normal - direction to push point Xj - point closest to obstacle</span>
00471 
00472         <span class="comment">// Before adding the constraint, we need to check for a special case where the end of the link</span>
00473         <span class="comment">//  is the closest to the object.  In this case, the end of the previous link (which is</span>
00474         <span class="comment">//  conincident) may have already created an identical constraint (if it is revolute, the</span>
00475         <span class="comment">//  closest point will be at the joint).  In this case, we don't need a second identical constraint.</span>
00476         <span class="keywordflow">if</span> ( Math::equals(pd.intercept,0) &amp;&amp; (chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina13">linkIndexOfVariable</a>(v) &gt; 0) ) {
00477           <span class="keywordflow">if</span> ( chain[chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina13">linkIndexOfVariable</a>(v)].type() == KinematicChain::Link::Revolute )
00478             <span class="keywordflow">return</span>; <span class="comment">// skip this constraint</span>
00479         }
00480 
00481 <a class="code" href="debugtools.html#a7">Debugln</a>(DJ,<span class="stringliteral">"proximity: variable "</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">" (l="</span> &lt;&lt; chain.<a class="code" href="classrobot_1_1KinematicChain.html#robot_1_1KinematicChaina13">linkIndexOfVariable</a>(v) &lt;&lt; <span class="stringliteral">"):\nL="</span> &lt;&lt; L &lt;&lt; <span class="stringliteral">" n="</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" lXj="</span> &lt;&lt; pd.intercept &lt;&lt; <span class="stringliteral">" d="</span> &lt;&lt; d &lt;&lt; <span class="stringliteral">" dist="</span> &lt;&lt; pd.distance);
00482         constraints-&gt;addConstraint(ref&lt;BetaFormConstraints::BetaFormConstraint&gt;(NewObj PushAwayBetaConstraint(v,pd.intercept, n, L, gs, chain, q)) );
00483       }
00484 
00485     }
00486 
00487   }
00488 
00489 }
00490 
00491 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:32 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
