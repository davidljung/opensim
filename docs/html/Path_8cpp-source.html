<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/Path.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/Path.cpp</h1><a href="Path_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Path.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.8 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="Path.html">base/Path</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;sstream&gt;</span>
00028 
00029 <span class="preprocessor">#include &lt;<a class="code" href="PathRep.html">base/PathRep</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;<a class="code" href="Externalizer.html">base/Externalizer</a>&gt;</span>
00031 <span class="preprocessor">#include &lt;<a class="code" href="externalization__error.html">base/externalization_error</a>&gt;</span>
00032 <span class="preprocessor">#include &lt;<a class="code" href="Application.html">base/Application</a>&gt;</span>
00033 <span class="preprocessor">#include &lt;<a class="code" href="VFile.html">base/VFile</a>&gt;</span>
00034 
00035 <span class="comment">// concrete representations</span>
00036 <span class="preprocessor">#include &lt;<a class="code" href="LineSegPathRep.html">base/LineSegPathRep</a>&gt;</span>
00037 <span class="preprocessor">#include &lt;<a class="code" href="WaypointPathRep.html">base/WaypointPathRep</a>&gt;</span>
00038 <span class="preprocessor">#include &lt;<a class="code" href="ParametricPathRep.html">base/ParametricPathRep</a>&gt;</span>
00039 
00040 
00041 <span class="keyword">using</span> <a class="code" href="classbase_1_1Path.html">base::Path</a>;
00042 
00043 <span class="keyword">using</span> <a class="code" href="classbase_1_1LineSegPathRep.html">base::LineSegPathRep</a>;
00044 <span class="keyword">using</span> <a class="code" href="classbase_1_1WaypointPathRep.html">base::WaypointPathRep</a>;
00045 <span class="keyword">using</span> <a class="code" href="classbase_1_1ParametricPathRep.html">base::ParametricPathRep</a>;
00046 
00047 <span class="keyword">using</span> <a class="code" href="classbase_1_1externalization__error.html">base::externalization_error</a>;
00048 <span class="keyword">using</span> <a class="code" href="classbase_1_1Application.html">base::Application</a>;
00049 <span class="keyword">using</span> <a class="code" href="classbase_1_1VFile.html">base::VFile</a>;
00050 <span class="keyword">using</span> <a class="code" href="classbase_1_1PathName.html">base::PathName</a>;
00051 
00052 <span class="keyword">using</span> base::dom::DOMNode;
00053 <span class="keyword">using</span> base::dom::DOMElement;
00054 
00055 
00056 
00057 
00058 Path::Path()
00059 {
00060   create();
00061 }
00062 
00063 
00064 Path::Path(<span class="keyword">const</span> Path&amp; p)
00065 {
00066   create(p);
00067 }
00068 
00069 
00070 Path::Path(<span class="keyword">const</span> Point3&amp; sp, <span class="keyword">const</span> Orient&amp; so, <span class="keyword">const</span> Point3&amp; ep, <span class="keyword">const</span> Orient&amp; eo)
00071 {
00072   create(sp,so,ep,eo);
00073 }
00074 
00075 
00076 Path::Path(<span class="keyword">const</span> array&lt;Point3&gt;&amp; points, <span class="keyword">const</span> array&lt;Orient&gt;&amp; orients, <span class="keywordtype">bool</span> deltas)
00077 {
00078   create(points,orients,deltas);
00079 }
00080 
00081 
00082 Path::Path(<span class="keyword">const</span> array&lt;Vector&gt;&amp; points, <span class="keywordtype">bool</span> deltas)
00083 {
00084   create(points,deltas);
00085 }
00086 
00087 
00088 Path::Path(<span class="keyword">const</span> ExpressionVector&amp; p)
00089 {
00090   create(p);
00091 }
00092 
00093 
00094 
00095 <span class="keywordtype">void</span> Path::create()
00096 {
00097   <span class="comment">// default path (degenerate path - create as line segment with both ends the same)</span>
00098   rep = ref&lt;PathRep&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> LineSegPathRep(<a class="code" href="namespacebase.html#a26">Point3</a>(),Orient(),<a class="code" href="namespacebase.html#a26">Point3</a>(),Orient()));
00099 }
00100 
00101 <span class="keywordtype">void</span> Path::create(<span class="keyword">const</span> Path&amp; p)
00102 {
00103   rep = ref&lt;PathRep&gt;( &amp;<a class="code" href="namespacebase.html#a56">base::clone</a>( *p.rep ) );
00104 }
00105 
00106 <span class="keywordtype">void</span> Path::create(<span class="keyword">const</span> Point3&amp; sp, <span class="keyword">const</span> Orient&amp; so, <span class="keyword">const</span> Point3&amp; ep, <span class="keyword">const</span> Orient&amp; eo)
00107 {
00108   rep = ref&lt;PathRep&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> LineSegPathRep(sp,so,ep,eo));
00109 }
00110 
00111 <span class="keywordtype">void</span> Path::create(<span class="keyword">const</span> array&lt;Point3&gt;&amp; points, <span class="keyword">const</span> array&lt;Orient&gt;&amp; orients, <span class="keywordtype">bool</span> deltas)
00112 {
00113   init(points, orients, deltas);
00114 }
00115 
00116 <span class="keywordtype">void</span> Path::create(<span class="keyword">const</span> array&lt;Vector&gt;&amp; points, <span class="keywordtype">bool</span> deltas)
00117 {
00118   <span class="comment">// convert points to arrays of Point3 &amp; Orients</span>
00119   <a class="code" href="base.html#a19">Assert</a>(points.size() &gt; 0);
00120   <a class="code" href="base.html#a19">Assert</a>(points[0].size() &gt;= 3);
00121   
00122   array&lt;Point3&gt; pos(points.size());
00123   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;points.size(); i++) {
00124     <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; v(points[i]);
00125     pos[i] = <a class="code" href="namespacebase.html#a26">Point3</a>(v[0],v[1],v[2]);
00126   }
00127   
00128   array&lt;Orient&gt; orient(points.size());
00129   <span class="keywordflow">if</span> (points[0].size() == 6) { <span class="comment">// assuming EulerRPY</span>
00130     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;points.size(); i++) {
00131       <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; v(points[i]);
00132       orient[i] = Orient(v[3],v[4],v[5]);
00133     }
00134   }
00135   <span class="keywordflow">else</span>
00136     <span class="keywordflow">if</span> (points[0].size() == 7) { <span class="comment">// assuming quat</span>
00137       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;points.size(); i++) {
00138         <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; v(points[i]);
00139         orient[i] = Orient(Quat4(v[3],v[4],v[5],v[6]));
00140       }
00141     }
00142   
00143   init(pos,orient,deltas);
00144 }
00145 
00146 
00147 <span class="keywordtype">void</span> Path::create(<span class="keyword">const</span> ExpressionVector&amp; p)
00148 {
00149   rep = ref&lt;PathRep&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> ParametricPathRep(p));
00150 }
00151 
00152 
00153 <span class="keywordtype">void</span> Path::init(<span class="keyword">const</span> array&lt;Point3&gt;&amp; points, <span class="keyword">const</span> array&lt;Orient&gt;&amp; orients, <span class="keywordtype">bool</span> deltas)
00154 {
00155   <span class="keywordflow">if</span> (!deltas)
00156     rep = ref&lt;PathRep&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> WaypointPathRep(points, orients));
00157   <span class="keywordflow">else</span> {
00158     array&lt;Point3&gt; apoints(points.size()+1);
00159     apoints[0] = <a class="code" href="namespacebase.html#a26">Point3</a>(0,0,0);
00160     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;points.size(); i++)
00161       apoints[i+1] = apoints[i]+points[i];
00162 
00163     array&lt;Orient&gt; aorients(orients.size()+1);
00164     aorients[0] = Orient();
00165     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;orients.size(); i++) {
00166       Quat4 q1(aorients[i].getQuat4());
00167       Quat4 q2(orients[i].getQuat4());
00168       aorients[i+1] = Orient(q2*q1);
00169     }
00170 
00171     rep = ref&lt;PathRep&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> WaypointPathRep(apoints, aorients));
00172   }
00173 }
00174 
00175 
00176 
00177 <span class="keywordtype">void</span> Path::resample(Int samples)
00178 {
00179   array&lt;Point3&gt; points(samples);
00180   array&lt;Orient&gt; orients(samples);
00181 
00182   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;samples; i++) {
00183     <a class="code" href="namespacebase.html#a5">Real</a> s = <a class="code" href="namespacebase.html#a5">Real</a>(i)/<a class="code" href="namespacebase.html#a5">Real</a>(samples-1);
00184     points[i] =  Path::position(s);
00185     orients[i] = Path::orientation(s);
00186   }
00187 
00188   init(points, orients, <span class="keyword">false</span>);
00189    
00190 }
00191 
00192 
00193 <span class="keywordtype">void</span> Path::resample(<span class="keyword">const</span> Real dxmax)
00194 {
00195   <a class="code" href="base.html#a19">Assert</a>(dxmax &gt; 0);
00196   
00197   array&lt;Point3&gt; points;
00198   array&lt;Orient&gt; orients;
00199   
00200   <span class="comment">// start with first distinguished value</span>
00201   <a class="code" href="namespacebase.html#a5">Real</a> s = distinguishedValue(0);
00202   <a class="code" href="namespacebase.html#a26">Point3</a> pos( position(s) );
00203   Orient orient( orientation(s) );
00204   points.push_back( pos );
00205   orients.push_back( orient );
00206 
00207   <a class="code" href="namespacebase.html#a5">Real</a> lasts(s);
00208   <a class="code" href="namespacebase.html#a26">Point3</a> lastpos( pos );
00209   <a class="code" href="namespacebase.html#a2">Int</a> i = 1; <span class="comment">// current distinguished value index</span>
00210   <span class="keywordflow">while</span> (i &lt; numDistinguishedValues()) {
00211 
00212     <span class="comment">// get next distinguished value</span>
00213     s = distinguishedValue(i);
00214     pos = position(s);
00215     orient = orientation(s);
00216     
00217     <span class="comment">// calc dx = this pos - last pos</span>
00218     Vector3 dx = pos - lastpos;
00219     <span class="keywordflow">if</span> (dx.length() &gt; dxmax) { <span class="comment">// dist was too big, set current pos to a distance of maxdx from last pos</span>
00220       <a class="code" href="namespacebase.html#a5">Real</a> scale = dxmax/dx.length();
00221       s = lasts + scale*(s-lasts);
00222       pos = position(s);
00223       orient = orientation(s);
00224     }
00225     <span class="keywordflow">else</span>
00226       ++i;
00227     
00228     points.push_back( pos );
00229     orients.push_back( orient );
00230 
00231     lasts = s;
00232     lastpos = pos;
00233   }
00234   
00235   init(points, orients, <span class="keyword">false</span>);
00236   
00237 }
00238 
00239 
00240 
00241 
00242 
00243 
00244 <span class="keywordtype">void</span> Path::serialize(Serializer&amp; s)
00245 {
00246   <span class="comment">// register instantiators for all the PathRep classes for dynamic instantiation upon deserialization</span>
00247   Serializable::registerSerializableInstantiator&lt;PathRep,LineSegPathRep&gt;(lineSegPathRepInstantiator);
00248   Serializable::registerSerializableInstantiator&lt;PathRep,WaypointPathRep&gt;(waypointPathRepInstantiator);
00249   s.baseRef(rep,<span class="stringliteral">"PathRep"</span>);
00250 }
00251 
00252 
00253 <span class="keywordtype">bool</span> Path::formatSupported(String format, Real version, ExternalizationType type)<span class="keyword"> const</span>
00254 <span class="keyword"></span>{
00255   <span class="keywordflow">return</span>    ((format==<span class="stringliteral">"txt"</span>) &amp;&amp; (version==1.0))
00256          || ((format==<span class="stringliteral">"xml"</span>) &amp;&amp; (version==1.0));
00257 }
00258 
00259 
00260 <span class="keywordtype">void</span> Path::externalize(Externalizer&amp; e, String format, Real version)
00261 {
00262   <span class="keywordflow">if</span> (format==<span class="stringliteral">""</span>) format = <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"xml"</span>);
00263 
00264   <span class="keywordflow">if</span> (!formatSupported(format,version,e.ioType()))
00265     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"format "</span>)+format+<span class="stringliteral">" "</span>+base::realToString(version)+<span class="stringliteral">" unsupported"</span>));
00266 
00267   <span class="keywordflow">if</span> (format == <span class="stringliteral">"txt"</span>) {
00268 
00269     <span class="keywordflow">if</span> (e.isInput()) {
00270       
00271       array&lt;Point3&gt; points;
00272       array&lt;Orient&gt; orients;
00273       
00274       <span class="keywordflow">while</span> (e.moreInput()) {
00275         
00276         <a class="code" href="namespacebase.html#a4">String</a> line(e.readLine());
00277         <span class="keywordflow">if</span> (line.empty()) <span class="keywordflow">break</span>; <span class="comment">// empty line or eof indicates end of list</span>
00278         <span class="keywordflow">while</span> (line[0] == <span class="charliteral">'#'</span>) line = e.readLine(); <span class="comment">// skip comment lines</span>
00279         
00280         <span class="comment">// count separating spaces to determine if there are 6 or 7</span>
00281         <span class="comment">// numbers present</span>
00282         <a class="code" href="namespacebase.html#a2">Int</a> spaces=0;
00283         <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;line.size(); i++) 
00284           <span class="keywordflow">if</span> (line[i]==<span class="charliteral">' '</span>) { 
00285             spaces++;
00286             <span class="keywordflow">while</span> ( (i&lt;line.size()-1) &amp;&amp; (line[i]==<span class="charliteral">' '</span>)) i++;
00287           }
00288         <span class="keywordflow">if</span> (line[0]==<span class="charliteral">' '</span>) spaces--; <span class="comment">// don't count leading space(s)</span>
00289         
00290         <a class="code" href="base.html#a19">Assert</a>(spaces &gt;= 5);
00291         <span class="keywordtype">bool</span> quat = (spaces&gt;5);
00292         std::istringstream iss(line);
00293         iss.setf(std::ios_base::skipws | std::ios_base::dec);
00294         
00295         <a class="code" href="namespacebase.html#a26">Point3</a> p;
00296         iss &gt;&gt; p.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3o0">x</a> &gt;&gt; p.y &gt;&gt; p.z;
00297         <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v(quat?4:3);
00298         iss &gt;&gt; v[0] &gt;&gt; v[1] &gt;&gt; v[2];
00299         <span class="keywordflow">if</span> (quat) iss &gt;&gt; v[3];
00300 
00301         points.push_back(p);
00302         
00303         orients.push_back(Orient(v, quat? Orient::Quat : Orient::EulerRPY));
00304       }
00305 
00306       init(points,orients,<span class="keyword">false</span>);
00307       
00308     }
00309     <span class="keywordflow">else</span> { <span class="comment">// output</span>
00310       std::ostringstream out;
00311       
00312       <span class="comment">// comment header</span>
00313       out &lt;&lt; <span class="stringliteral">"# waypoint path (positions &amp; orientations)"</span> &lt;&lt; std::endl;
00314       out &lt;&lt; <span class="stringliteral">"#           x             y             z "</span>;
00315       <span class="keywordflow">if</span> (orientation(distinguishedValue(0)).representation() == Orient::EulerRPY)
00316         out &lt;&lt; <span class="stringliteral">"            R             P             Y"</span> &lt;&lt; std::endl;
00317       <span class="keywordflow">else</span>
00318         out &lt;&lt; <span class="stringliteral">"           qx            qy            qz            qw"</span> &lt;&lt; std::endl;
00319       
00320       std::ostream::fmtflags savedFlags = out.setf(std::ios_base::dec | std::ios_base::right);
00321       <a class="code" href="namespacebase.html#a2">Int</a> savedPrec = out.precision(10);
00322       <a class="code" href="namespacebase.html#a2">Int</a> savedWidth = out.width(13);
00323       
00324       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;numDistinguishedValues(); i++) {
00325         <a class="code" href="namespacebase.html#a26">Point3</a> p(position(distinguishedValue(i)));
00326         Orient o(orientation(distinguishedValue(i)));
00327         
00328 <span class="comment">// this is a hack, as under gcc the flags don't appear to stay set after an output op (!?)</span>
00329 <span class="preprocessor">#define setflags \</span>
00330 <span class="preprocessor">      out.setf(std::ios_base::dec | std::ios_base::right); \</span>
00331 <span class="preprocessor">      out.precision(10); \</span>
00332 <span class="preprocessor">      out.width(13); </span>
00333 <span class="preprocessor"></span>
00334         out &lt;&lt; p.x &lt;&lt; <span class="stringliteral">" "</span>; <a class="code" href="Path_8cpp.html#a0">setflags</a>;
00335         out &lt;&lt; p.y &lt;&lt; <span class="stringliteral">" "</span>; <a class="code" href="Path_8cpp.html#a0">setflags</a>;
00336         out &lt;&lt; p.z &lt;&lt; <span class="stringliteral">" "</span>; <a class="code" href="Path_8cpp.html#a0">setflags</a>;
00337         <span class="keywordflow">if</span> ( (o.representation() != Orient::Quat) &amp;&amp; (o.representation() != Orient::EulerRPY) )
00338           o.changeRepresentation(Orient::Quat);
00339 
00340         <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v(o);
00341         out &lt;&lt; v[0] &lt;&lt; <span class="stringliteral">" "</span>; <a class="code" href="Path_8cpp.html#a0">setflags</a>;
00342         out &lt;&lt; v[1] &lt;&lt; <span class="stringliteral">" "</span>; <a class="code" href="Path_8cpp.html#a0">setflags</a>;
00343         out &lt;&lt; v[2]; <a class="code" href="Path_8cpp.html#a0">setflags</a>;
00344         <span class="keywordflow">if</span> (v.size() &gt; 3 ) out &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; v[3];
00345         out &lt;&lt; std::endl;
00346 
00347       }
00348 
00349       out.setf(savedFlags);
00350       out.precision(savedPrec);
00351       out.width(savedWidth);
00352 
00353       e.writeString(out.str());
00354     }
00355 
00356   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (format == <span class="stringliteral">"xml"</span>) {
00357 
00358     <span class="keywordflow">if</span> (e.isOutput()) {
00359 
00360       DOMElement* pathElem = e.createElement(<span class="stringliteral">"path"</span>);
00361 
00362       <span class="keywordtype">bool</span> parametric = <a class="code" href="base.html#a25">instanceof</a>(*rep, ParametricPathRep);
00363       
00364       <span class="keywordflow">if</span> (parametric) { <a class="code" href="debugtools.html#a12">Unimplemented</a>; }
00365       
00366       Orient::Representation rep = orientation(distinguishedValue(0)).representation();
00367       <span class="keywordflow">if</span> ((rep != Orient::Quat) &amp;&amp; (rep != Orient::EulerRPY) )
00368         rep = Orient::Quat;
00369       
00370       <span class="keywordflow">if</span> (rep==Orient::Quat) {
00371         e.setElementAttribute(pathElem,<span class="stringliteral">"representation"</span>, <span class="stringliteral">"x y z qx qy qz qw"</span> );
00372         e.appendComment(pathElem, <span class="stringliteral">"position (x,y,z) orientation quaternion (qx,qy,qz,qw) [w is scalar component]"</span>);
00373       } <span class="keywordflow">else</span> {
00374         e.setElementAttribute(pathElem,<span class="stringliteral">"representation"</span>, <span class="stringliteral">"x y z r p y"</span> );
00375         e.appendComment(pathElem,<span class="stringliteral">"position (x,y,z) orientation Euler angles (roll, pitch yaw)"</span>);
00376       }
00377       
00378       e.setElementAttribute(pathElem,<span class="stringliteral">"pointtype"</span>, <span class="stringliteral">"absolute"</span>);
00379       <span class="keywordflow">if</span> (frame!=<span class="stringliteral">""</span>)
00380         e.setElementAttribute(pathElem,<span class="stringliteral">"frame"</span>, frame);
00381 
00382       <span class="keywordflow">if</span> (units!=<span class="stringliteral">""</span>)
00383         e.setElementAttribute(pathElem,<span class="stringliteral">"units"</span>, units);
00384       
00385       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;numDistinguishedValues(); i++) {
00386         <a class="code" href="namespacebase.html#a26">Point3</a> p(position(distinguishedValue(i)));
00387         Orient o(orientation(distinguishedValue(i)));
00388         
00389         <a class="code" href="classdemeter_1_1Vector.html">Vector</a> vo(o);
00390         <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v(3+vo.size());
00391         v[0] = p.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>; v[1] = p.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>; v[2] = p.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00392         <span class="keywordflow">if</span> (vo.size() == 3) { <span class="comment">// rpy</span>
00393           v[3] = vo[0]; v[4] = vo[1]; v[5] = vo[2];
00394         }
00395         <span class="keywordflow">else</span> { <span class="comment">// quat</span>
00396           v[3] = vo[0]; v[4] = vo[1]; v[5] = vo[2]; v[6] = vo[3];
00397         }
00398         
00399         e.appendText( pathElem, e.toString(v) );
00400         e.appendBreak( pathElem );
00401         
00402       }
00403       
00404       e.appendElement(pathElem);    
00405 
00406     }
00407     <span class="keywordflow">else</span> { <span class="comment">// input</span>
00408       DOMNode* context = e.context();
00409       
00410       DOMElement* pathElem = e.getFirstElement(context, <span class="stringliteral">"path"</span>);
00411 
00412       <span class="comment">// handle link</span>
00413       <a class="code" href="namespacebase.html#a4">String</a> link = e.getElementAttribute(pathElem,<span class="stringliteral">"link"</span>,<span class="keyword">false</span>);
00414       <span class="keywordflow">if</span> (link != <span class="stringliteral">""</span>) {
00415         
00416         ref&lt;VFile&gt; linkFile = Application::getInstance()-&gt;universe()-&gt;cache()-&gt;findFile(link,e.getArchivePath());
00417         load(linkFile,format,version);
00418       }
00419       <span class="keywordflow">else</span> {
00420         
00421         <a class="code" href="namespacebase.html#a4">String</a> repText = e.getElementAttribute(pathElem, <span class="stringliteral">"representation"</span>);
00422         
00423         <span class="keywordtype">bool</span> absolute = ( e.getDefaultedElementAttribute(pathElem, <span class="stringliteral">"pointtype"</span>, <span class="stringliteral">"absolute"</span>) == <span class="stringliteral">"absolute"</span> );
00424         frame = e.getDefaultedElementAttribute(pathElem, <span class="stringliteral">"frame"</span>, <span class="stringliteral">""</span>);
00425         units = e.getDefaultedElementAttribute(pathElem, <span class="stringliteral">"units"</span>, <span class="stringliteral">""</span>);
00426 
00427         Orient::Representation rep;
00428         <span class="keywordtype">bool</span> hasorient = <span class="keyword">true</span>;
00429         <span class="keywordtype">bool</span> parametric = <span class="keyword">false</span>;
00430         <span class="keywordtype">bool</span> scalarFirst = <span class="keyword">false</span>;
00431         
00432         <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x y z"</span>) {
00433           hasorient = <span class="keyword">false</span>;
00434         }
00435         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x y z qx qy qz qw"</span>) {
00436           rep = Orient::Quat;
00437         }
00438         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x y z qw qx qy qz"</span>) {
00439           rep = Orient::Quat;
00440           scalarFirst=<span class="keyword">true</span>;
00441         }
00442         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x y z r p y"</span>) {
00443           rep = Orient::EulerRPY;
00444         }
00445         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x(s) y(s) z(s)"</span>) {
00446           hasorient = <span class="keyword">false</span>;
00447           parametric = <span class="keyword">true</span>;
00448         }
00449         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x(s) y(s) z(s) qx(s) qy(s) qz(s) qw(s)"</span>) {
00450           parametric = <span class="keyword">true</span>;
00451           rep = Orient::Quat;
00452         }
00453         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x(s) y(s) z(s) qw(s) qx(s) qy(s) qz(s)"</span>) {
00454           parametric = <span class="keyword">true</span>;
00455           rep = Orient::Quat;
00456           scalarFirst=<span class="keyword">true</span>;
00457         }
00458         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (repText == <span class="stringliteral">"x(s) y(s) z(s) r(s) p(s) y(s)"</span>) {
00459           parametric = <span class="keyword">true</span>;
00460           rep = Orient::EulerRPY;
00461         }
00462         <span class="keywordflow">else</span> 
00463           <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"unknown or unsupported path representation"</span>));
00464 
00465         <a class="code" href="namespacebase.html#a4">String</a> pathText = e.getContainedText(pathElem,<span class="keyword">true</span>);
00466         array&lt;String&gt; pathLines = e.splitIntoLines(pathText);
00467 
00468         <span class="keywordflow">if</span> (!parametric) {      
00469           array&lt;Point3&gt; points;
00470           array&lt;Orient&gt; orients;
00471           
00472   
00473           <span class="keywordflow">if</span> (pathLines.size() &lt; 2)
00474             <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"path must contain at least two points"</span>));
00475   
00476           <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;pathLines.size(); i++) {
00477             array&lt;String&gt; elts = e.splitAtDelimiter(pathLines[i], <span class="charliteral">' '</span>);
00478             <span class="keywordflow">if</span> (    (hasorient &amp;&amp; (rep==Orient::Quat) &amp;&amp; (elts.size() != 7))
00479                  || (hasorient &amp;&amp; (rep==Orient::EulerRPY) &amp;&amp; (elts.size() != 6)) 
00480                  || (!hasorient &amp;&amp; (elts.size() != 3)) )
00481               <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"path point with wrong number of elements encountered"</span>));
00482             <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v( e.stringsToReals(elts) );
00483             points.push_back( <a class="code" href="namespacebase.html#a26">Point3</a>(v[0],v[1],v[2]) );
00484             <span class="keywordflow">if</span> (hasorient) {
00485               <span class="keywordflow">if</span> (rep==Orient::Quat) {
00486                 <span class="keywordflow">if</span> (!scalarFirst)
00487                   orients.push_back( Orient(Quat4(v[3],v[4],v[5],v[6])) );
00488                 <span class="keywordflow">else</span>
00489                   orients.push_back( Orient(Quat4(v[6],v[3],v[4],v[5])) );
00490               }
00491               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep==Orient::EulerRPY) {
00492                 orients.push_back( Orient(v[3],v[4],v[5]) );
00493               }
00494             }
00495             <span class="keywordflow">else</span>
00496               orients.push_back( Orient() );
00497             
00498           }
00499   
00500           init(points,orients,!absolute);
00501         }
00502         <span class="keywordflow">else</span> { <span class="comment">// parametric</span>
00503           
00504           <span class="keywordflow">if</span> (!absolute)
00505             <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"pointtype of 'relative' doesn't make sense for parametric expression paths"</span>));
00506           
00507           <a class="code" href="namespacebase.html#a17">ExpressionVector</a> v(3);
00508 
00509           <span class="keywordflow">try</span> {
00510           
00511             <span class="keywordflow">if</span> (!hasorient) {
00512               <span class="keywordflow">if</span> (pathLines.size() != 3)
00513                 <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"path should have one line for each parametric expression x(s), y(s) and z(s)"</span>));
00514               v[0] = Expression(pathLines[0]);
00515               v[1] = Expression(pathLines[1]);
00516               v[2] = Expression(pathLines[2]);
00517             }
00518             <span class="keywordflow">else</span> { <span class="comment">// hasorient</span>
00519               <span class="keywordflow">if</span> (rep == Orient::Quat) {
00520                 <span class="keywordflow">if</span> (pathLines.size() != 7)
00521                   <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"path should have one line for each parametric expression x(s), y(s), z(s), qx(s), qy(s), qz(s) and qw(s)"</span>));
00522                 v.resize(7);
00523                 v[0] = Expression(pathLines[0]);
00524                 v[1] = Expression(pathLines[1]);
00525                 v[2] = Expression(pathLines[2]);
00526                 <span class="keywordflow">if</span> (!scalarFirst) {
00527                   v[3] = Expression(pathLines[3]);
00528                   v[4] = Expression(pathLines[4]);
00529                   v[5] = Expression(pathLines[5]);
00530                   v[6] = Expression(pathLines[6]);
00531                 }
00532                 <span class="keywordflow">else</span> {
00533                   v[3] = Expression(pathLines[6]);
00534                   v[4] = Expression(pathLines[3]);
00535                   v[5] = Expression(pathLines[4]);
00536                   v[6] = Expression(pathLines[5]);
00537                 }
00538               }
00539               <span class="keywordflow">else</span> {
00540                 <span class="keywordflow">if</span> (pathLines.size() != 6)
00541                   <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"path should have one line for each parametric expression x(s), y(s), z(s), R(s), P(s), and Y(s)"</span>));
00542                 v.resize(6);
00543                 v[0] = Expression(pathLines[0]);
00544                 v[1] = Expression(pathLines[1]);
00545                 v[2] = Expression(pathLines[2]);
00546                 v[3] = Expression(pathLines[3]);
00547                 v[4] = Expression(pathLines[4]);
00548                 v[5] = Expression(pathLines[5]);
00549               }
00550             }
00551           } <span class="keywordflow">catch</span> (std::exception&amp; e) {
00552             <span class="keywordflow">throw</span> externalization_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"error parsing parametric path component expression:"</span>+<a class="code" href="namespacebase.html#a4">String</a>(e.what())));
00553           }
00554           
00555           this-&gt;rep = ref&lt;PathRep&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> ParametricPathRep(v));
00556           
00557         } <span class="comment">// else parametric</span>
00558 
00559       }
00560 
00561       e.removeElement(pathElem);
00562 
00563     }
00564 
00565   } <span class="comment">// format xml</span>
00566 
00567 
00568 }
00569 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:09 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
