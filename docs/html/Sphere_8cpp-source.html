<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: physics/Sphere.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>physics/Sphere.cpp</h1><a href="Sphere_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Sphere.cpp 1031 2004-02-11 20:46:36Z jungd $</span>
00019 <span class="comment"> </span>
00020 <span class="comment">****************************************************************************/</span>
00021 
00022 <span class="preprocessor">#include &lt;<a class="code" href="Sphere.html">physics/Sphere</a>&gt;</span>
00023 
00024 <span class="preprocessor">#include &lt;<a class="code" href="Externalizer.html">base/Externalizer</a>&gt;</span>
00025 <span class="preprocessor">#include &lt;<a class="code" href="VisualTriangles.html">gfx/VisualTriangles</a>&gt;</span>
00026 <span class="preprocessor">#include &lt;<a class="code" href="Material.html">physics/Material</a>&gt;</span>
00027 <span class="preprocessor">#include &lt;<a class="code" href="OBBCollisionModel.html">physics/OBBCollisionModel</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="GJKCollisionModel.html">physics/GJKCollisionModel</a>&gt;</span>
00029 
00030 <span class="preprocessor">#include &lt;osg/Group&gt;</span>
00031 <span class="preprocessor">#include &lt;osg/Geode&gt;</span>
00032 <span class="preprocessor">#include &lt;osg/ShapeDrawable&gt;</span>
00033 <span class="preprocessor">#include &lt;osg/LOD&gt;</span>
00034 
00035 <span class="keyword">using</span> base::dom::DOMNode;
00036 <span class="keyword">using</span> base::dom::DOMElement;
00037 <span class="keyword">using</span> gfx::Point2;
00038 <span class="keyword">using</span> gfx::Point3;
00039 <span class="keyword">using</span> gfx::Vector3;
00040 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Segment3.html">gfx::Segment3</a>;
00041 <span class="keyword">using</span> <a class="code" href="classgfx_1_1VisualTriangles.html">gfx::VisualTriangles</a>;
00042 <span class="keyword">using</span> <a class="code" href="classphysics_1_1Sphere.html">physics::Sphere</a>;
00043 <span class="keyword">using</span> <a class="code" href="classphysics_1_1MassProperties.html">physics::MassProperties</a>;
00044 <span class="keyword">using</span> <a class="code" href="classphysics_1_1CollisionModel.html">physics::CollisionModel</a>;
00045 <span class="keyword">using</span> <a class="code" href="classphysics_1_1OBBCollisionModel.html">physics::OBBCollisionModel</a>;
00046 <span class="keyword">using</span> <a class="code" href="classphysics_1_1GJKCollisionModel.html">physics::GJKCollisionModel</a>;
00047 
00048 
00049 <span class="keyword">using</span> osg::Node;
00050 <span class="keyword">using</span> osg::Group;
00051 <span class="keyword">using</span> osg::Geode;
00052 <span class="keyword">using</span> osg::LOD;
00053 <span class="keyword">using</span> osg::Vec3;
00054 <span class="keyword">using</span> osg::Vec2;
00055 
00056 
00057 Sphere::Sphere() 
00058   : _radius(1.0), massPropertiesCached(false)
00059 {
00060 }
00061 
00062 Sphere::Sphere(Real radius) 
00063   : _radius(radius), massPropertiesCached(false)
00064 {
00065 }
00066 
00067 Sphere::Sphere(<span class="keyword">const</span> Sphere&amp; s)
00068   : _radius(s._radius), massPropertiesCached(false)
00069 {
00070 }
00071 
00072 Sphere::~Sphere() 
00073 {
00074 }
00075 
00076 
00077 <span class="keyword">const</span> <a class="code" href="classphysics_1_1MassProperties.html">MassProperties</a>&amp; Sphere::getMassProperties(ref&lt;const Material&gt; material)<span class="keyword"> const </span>
00078 <span class="keyword"></span>{
00079   <span class="keywordflow">if</span> (massPropertiesCached &amp;&amp; (density == material-&gt;density()))
00080     <span class="keywordflow">return</span> massProperties;
00081  
00082   density = material-&gt;density();
00083   <a class="code" href="namespacebase.html#a5">Real</a> volume = 4.0*(consts::Pi*Math::cube(<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()))/3.0;
00084   massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertieso0">mass</a> = volume*density;
00085   
00086   Matrix3 Ibody; 
00087   Ibody(1,1) = Ibody(2,2) = Ibody(3,3) = (2.0*massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertieso0">mass</a>*Math::sqr(<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()))/5.0;
00088   massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertiesa7">setIbody</a>(Ibody);
00089   
00090   massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertieso1">centerOfMass</a> = <a class="code" href="namespacebase.html#a26">Point3</a>(0.0,0.0,0.0);
00091   
00092   massPropertiesCached = <span class="keyword">true</span>;
00093   <span class="keywordflow">return</span> massProperties;
00094 }
00095 
00096 
00097 Segment3 Sphere::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> Point3&amp; p)<span class="keyword"> const</span>
00098 <span class="keyword"></span>{
00099   <a class="code" href="namespacebase.html#a26">Point3</a> c(t.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma25">getTranslation</a>());
00100   Vector3 diff( p - c );
00101   <a class="code" href="namespacebase.html#a5">Real</a> diffLen = diff.length();
00102   Segment3 seg;
00103   seg.e = p;
00104   
00105   <span class="keywordflow">if</span> (diffLen &gt; consts::epsilon)
00106     seg.s = c + <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()*diff.normalize();
00107   <span class="keywordflow">else</span>
00108     seg.s = c + <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()*Vector3(1,0,0);  
00109 
00110   <span class="keywordflow">return</span> seg;
00111 }
00112 
00113 
00114 
00115 Segment3 Sphere::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Segment3.html">gfx::Segment3</a>&amp; s)<span class="keyword"> const</span>
00116 <span class="keyword"></span>{
00117   <span class="comment">// algorithm from XEngine by Martin Ecker ( http://xengine.sourceforge.net )</span>
00118   <a class="code" href="namespacebase.html#a26">Point3</a> c(t.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma25">getTranslation</a>());
00119   Vector3 segDir( s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o1">e</a> - s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a> );
00120   <a class="code" href="namespacebase.html#a5">Real</a> distance = 0;
00121   <a class="code" href="namespacebase.html#a26">Point3</a> p1,p2;
00122   <a class="code" href="namespacebase.html#a5">Real</a> DlengthSquared = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3a15">norm</a>();
00123   <a class="code" href="namespacebase.html#a5">Real</a> u = 0;
00124   <span class="keywordflow">if</span> (DlengthSquared &gt;= consts::epsilon)                <span class="comment">// avoid division by 0</span>
00125     u = <a class="code" href="namespacebase.html#a209">dot</a>(segDir, c - s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a>) / DlengthSquared;
00126 
00127   Vector3 <a class="code" href="Globals_8h.html#a15">R</a>;
00128   <span class="keywordflow">if</span> (u &lt;= 0)
00129     <a class="code" href="Globals_8h.html#a15">R</a> = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a>;
00130   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &gt;= 1)
00131     <a class="code" href="Globals_8h.html#a15">R</a> = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o1">e</a>;
00132   <span class="keywordflow">else</span>
00133     <a class="code" href="Globals_8h.html#a15">R</a> = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a> + u * segDir;
00134 
00135   Vector3 E = <a class="code" href="Globals_8h.html#a15">R</a> - c;
00136   <a class="code" href="namespacebase.html#a5">Real</a> Elength = E.length();
00137 
00138   <span class="keywordflow">if</span> (Elength &gt; <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>())               <span class="comment">// segment does not intersect the sphere</span>
00139   {
00140     p1 = <a class="code" href="Globals_8h.html#a15">R</a>;
00141     p2 = c + (<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>() / Elength) * E;          <span class="comment">// note that E cannot have zero length</span>
00142     distance = Elength - <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>();
00143   }
00144   <span class="keywordflow">else</span>                                                                                          <span class="comment">// segment intersects the sphere or is completely contained</span>
00145   {
00146     Vector3 centerToStart = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a>  - c;
00147     Vector3 centerToEnd = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o1">e</a> - c;
00148     <a class="code" href="namespacebase.html#a5">Real</a> centerToStartLength = centerToStart.length();
00149     <a class="code" href="namespacebase.html#a5">Real</a> centerToEndLength = centerToEnd.length();
00150     
00151     <span class="keywordflow">if</span> (centerToStartLength &lt; <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>() &amp;&amp; centerToEndLength &lt; <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()) {
00152       <span class="comment">// the segment is completely contained within the sphere</span>
00153       <span class="keywordflow">if</span> (centerToStartLength &lt; <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()) {             <span class="comment">// then the end point must be the closest to the sphere's shell</span>
00154         p1 = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o1">e</a>;
00155         p2 = c + <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>() * centerToEnd.normalize();
00156         distance = <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>() - centerToEndLength;
00157       }
00158       <span class="keywordflow">else</span> {                                    <span class="comment">// the start point is closest to the sphere's shell</span>
00159         p1 = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a>;
00160         p2 = c + <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>() * centerToStart.normalize();
00161         distance = <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>() - centerToStartLength;
00162       }
00163     }
00164     <span class="keywordflow">else</span> {      <span class="comment">// the segment intersects the sphere</span>
00165       Vector3 projCenter = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3o0">s</a> - u * segDir;
00166 
00167       Vector3 intersection = projCenter;
00168       <span class="keywordflow">if</span> (DlengthSquared &gt;= consts::epsilon)            <span class="comment">// to avoid division by 0</span>
00169       {
00170         <span class="comment">// take abs of radius^2 - (projCenter-c).norm() in case it's negative (DJ)</span>
00171         <a class="code" href="namespacebase.html#a5">Real</a> s = Math::sqrt(Math::abs( Math::sqr(<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()) - (projCenter - c).norm() ));
00172         <span class="comment">// if the end point of the segment is inside the sphere, the direction vector points from outside of </span>
00173         <span class="comment">// the sphere to the inside; therefore we have to swap the direction vector which we do by inverting s</span>
00174         <span class="keywordflow">if</span> (centerToEndLength &lt; <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>())
00175           s = -s;
00176         intersection += (s / Math::sqrt(DlengthSquared)) * segDir;
00177       }
00178       
00179       p1 = intersection;
00180       p2 = intersection;
00181       distance = 0;
00182     }
00183   }
00184 
00185   <span class="keywordflow">return</span> Segment3(p2,p1);
00186 }
00187 
00188 
00189 Segment3 Sphere::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>&amp; tri)<span class="keyword"> const</span>
00190 <span class="keyword"></span>{
00191   <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00192 }
00193 
00194 
00195 Segment3 Sphere::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Quad3.html">gfx::Quad3</a>&amp; q)<span class="keyword"> const</span>
00196 <span class="keyword"></span>{
00197   <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00198 }
00199 
00200 
00201 Segment3 Sphere::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t1, ref&lt;const Shape&gt; s, <span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t2)<span class="keyword"> const</span>
00202 <span class="keyword"></span>{
00203   <span class="keywordflow">if</span> (<a class="code" href="base.html#a25">instanceof</a>(*s, <span class="keyword">const</span> Sphere)) {
00204 
00205     ref&lt;const Sphere&gt; sphere1(<span class="keyword">this</span>);
00206     ref&lt;const Sphere&gt; sphere2(narrow_ref&lt;const Sphere&gt;(s));
00207     <a class="code" href="namespacebase.html#a26">Point3</a> c1(t1.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma25">getTranslation</a>());
00208     <a class="code" href="namespacebase.html#a26">Point3</a> c2(t2.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma25">getTranslation</a>());
00209     <a class="code" href="namespacebase.html#a5">Real</a> r1( sphere1-&gt;radius() );
00210     <a class="code" href="namespacebase.html#a5">Real</a> r2( sphere2-&gt;radius() );
00211 
00212     <a class="code" href="namespacebase.html#a26">Point3</a> p1,p2;
00213     Vector3 D = c2 - c1;
00214     <a class="code" href="namespacebase.html#a5">Real</a> Dlength = D.length();
00215     
00216     <span class="comment">// normalize D</span>
00217     <span class="keywordflow">if</span> (Dlength &lt; consts::epsilon)
00218       D.setZero();
00219     <span class="keywordflow">else</span>
00220       D /= Dlength;
00221     
00222     <span class="keywordflow">if</span> (Dlength &gt; r1 + r2) {            <span class="comment">// spheres do not intersect</span>
00223       p1 = c1 + r1 * D;
00224       p2 = c2 - r2 * D;
00225     }
00226     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Dlength &lt; Math::abs(r1 - r2))              <span class="comment">// one sphere is contained in the other</span>
00227     {
00228       p1 = c1 + r1 * D;
00229       p2 = c2 + r2 * D;
00230     }
00231     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Dlength &lt; consts::epsilon)         <span class="comment">// |D| == 0, the spheres are equal</span>
00232     {
00233       Vector3 intersection = c1;
00234       intersection.x += r1;
00235       
00236       p1 = intersection;
00237       p2 = intersection;
00238     }
00239     <span class="keywordflow">else</span> {              <span class="comment">// the spheres intersect</span>
00240       <a class="code" href="namespacebase.html#a5">Real</a> t = 0.5 * (1 + (Math::sqr(r1) - Math::sqr(r2)) / Math::sqr(Dlength));
00241       <a class="code" href="namespacebase.html#a5">Real</a> r = Math::sqrt(Math::sqr(r1) - Math::sqr(t * Dlength));
00242       Vector3 C = c1 + t * D;
00243       
00244       Matrix3 basis;
00245       basis.setOrthonormalBasisOf(D);<span class="comment">// get the coordinate system of the circle, D is the plane normal and therefore the z vector of the basis</span>
00246       Vector3 intersection = C + r * basis.row(1);
00247       
00248       p1 = intersection;
00249       p2 = intersection;
00250     }
00251 
00252     <span class="keywordflow">return</span> Segment3(p1,p2);
00253     
00254   }
00255   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="base.html#a25">instanceof</a>(*s, <span class="keyword">const</span> Box)) {
00256     
00257     <span class="keywordflow">return</span> s-&gt;shortestSegmentBetween(t2,ref&lt;const Shape&gt;(<span class="keyword">this</span>), t1).swapEnds(); 
00258     
00259   }
00260   <span class="keywordflow">else</span> {
00261     <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00262   }
00263 }
00264 
00265 
00266 
00267 
00268 
00269 
00270 gfx::Point3 Sphere::support(<span class="keyword">const</span> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; v)<span class="keyword"> const</span>
00271 <span class="keyword"></span>{
00272   <a class="code" href="namespacebase.html#a5">Real</a> s = v.<a class="code" href="classbase_1_1Vector3.html#base_1_1Vector3a20">length</a>();
00273   <span class="keywordflow">if</span> (s &gt; consts::epsilon) 
00274     <span class="keywordflow">return</span> v*(_radius/s);
00275   <span class="keywordflow">else</span>
00276     <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a26">base::Point3</a>(0,0,0);
00277 }
00278 
00279 
00280 osg::Node* Sphere::createOSGSphere(Visual::Attributes visualAttributes,
00281                                    Int slices)<span class="keyword"> const</span>
00282 <span class="keyword"></span>{
00283   <span class="comment">/*</span>
00284 <span class="comment">  bool onlyVerts = (visualAttributes &amp; VerticesOnly);</span>
00285 <span class="comment"></span>
00286 <span class="comment">  Real rho, drho, theta, dtheta;</span>
00287 <span class="comment">  Real x, y, z;</span>
00288 <span class="comment">  Real s, t, ds, dt;</span>
00289 <span class="comment">  Int index;</span>
00290 <span class="comment">  SInt i,j;</span>
00291 <span class="comment">  </span>
00292 <span class="comment">  drho = consts::Pi / Real(slices);</span>
00293 <span class="comment">  dtheta = 2.0*consts::Pi / Real(slices);</span>
00294 <span class="comment">  </span>
00295 <span class="comment">  // texturing: s goes from 0.0/0.25/0.5/0.75/1.0 at +y/+x/-y/-x/+y axis </span>
00296 <span class="comment">  // t goes from -1.0/+1.0 at z = -radius/+radius (linear along longitudes) </span>
00297 <span class="comment">  </span>
00298 <span class="comment">  ds = 1.0 / Real(slices);</span>
00299 <span class="comment">  dt = 1.0 / Real(slices);</span>
00300 <span class="comment">  t = 1.0;</span>
00301 <span class="comment">  </span>
00302 <span class="comment">  // draw stacks as quad strips </span>
00303 <span class="comment">  array&lt;Vec3&gt;&amp; coords = *new array&lt;Vec3&gt;(slices*(slices*2+2));</span>
00304 <span class="comment">  array&lt;Vec3&gt;&amp; normals = *new array&lt;Vec3&gt;(slices*(slices*2+2));</span>
00305 <span class="comment">  array&lt;Vec2&gt;&amp; texCoords = *new array&lt;Vec2&gt;(slices*(slices*2+2));</span>
00306 <span class="comment">  array&lt;int&gt;&amp; lengths = *new array&lt;int&gt;(slices);</span>
00307 <span class="comment">  for(Int i=0; i&lt;slices; i++)</span>
00308 <span class="comment">    lengths[i] = slices*2+2;</span>
00309 <span class="comment">  index=0;</span>
00310 <span class="comment">  </span>
00311 <span class="comment">  for (i = 0; i &lt; (SInt)slices; i++) {</span>
00312 <span class="comment">    rho = i * drho;</span>
00313 <span class="comment">    s = 0.0;</span>
00314 <span class="comment">    for (j = 0; j &lt;= (SInt)slices; j++) {</span>
00315 <span class="comment">      theta = (j == (SInt)slices) ? 0.0 : j * dtheta;</span>
00316 <span class="comment">      x = -Math::sin(theta) * Math::sin(rho);</span>
00317 <span class="comment">      y = Math::cos(theta) * Math::sin(rho);</span>
00318 <span class="comment">      z = Math::cos(rho);</span>
00319 <span class="comment"></span>
00320 <span class="comment">      normals[index] = Vec3(x,y,z);</span>
00321 <span class="comment">      if (!onlyVerts)</span>
00322 <span class="comment">        texCoords[index] = Vec2(s,t);</span>
00323 <span class="comment">      coords[index] = Vec3(x*radius(),y*radius(),z*radius());</span>
00324 <span class="comment">      index++;</span>
00325 <span class="comment">      </span>
00326 <span class="comment">      x = -Math::sin(theta) * Math::sin(rho + drho);</span>
00327 <span class="comment">      y = Math::cos(theta) * Math::sin(rho + drho);</span>
00328 <span class="comment">      z = Math::cos(rho + drho);</span>
00329 <span class="comment">      </span>
00330 <span class="comment">      normals[index] = Vec3(x,y,z);</span>
00331 <span class="comment">      if (!onlyVerts)</span>
00332 <span class="comment">        texCoords[index] = Vec2(s,t-dt);</span>
00333 <span class="comment">      s += ds;</span>
00334 <span class="comment">      coords[index] = Vec3(x*radius(),y*radius(),z*radius());</span>
00335 <span class="comment">      index++;</span>
00336 <span class="comment">    }</span>
00337 <span class="comment">    t -= dt;</span>
00338 <span class="comment">  }</span>
00339 <span class="comment"></span>
00340 <span class="comment">  GeoSet* sphere = new GeoSet();</span>
00341 <span class="comment">  sphere-&gt;setPrimType(GeoSet::QUAD_STRIP);</span>
00342 <span class="comment">  sphere-&gt;setNumPrims(slices);</span>
00343 <span class="comment">  sphere-&gt;setCoords(coords.c_array());</span>
00344 <span class="comment">  sphere-&gt;setPrimLengths(lengths.c_array());</span>
00345 <span class="comment">  if (!onlyVerts) {</span>
00346 <span class="comment">    sphere-&gt;setNormals(normals.c_array());</span>
00347 <span class="comment">    sphere-&gt;setNormalBinding(osg::GeoSet::BIND_PERVERTEX);</span>
00348 <span class="comment">    sphere-&gt;setTextureCoords(texCoords.c_array());</span>
00349 <span class="comment">    sphere-&gt;setTextureBinding(osg::GeoSet::BIND_PERVERTEX);</span>
00350 <span class="comment">  }</span>
00351 <span class="comment">*/</span>
00352   osg::Geode* geode = <span class="keyword">new</span> osg::Geode();
00353 <span class="comment">//  geode-&gt;addDrawable(sphere);</span>
00354   geode-&gt;addDrawable(<span class="keyword">new</span> osg::ShapeDrawable(<span class="keyword">new</span> osg::Sphere(osg::Vec3(0,0,0),<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>())));
00355 
00356   <span class="keywordflow">return</span> geode;
00357 }
00358 
00359 
00360 osg::Node* Sphere::createOSGVisual(Visual::Attributes visualAttributes)<span class="keyword"> const</span>
00361 <span class="keyword"></span>{
00362   <span class="keywordflow">if</span> ((node!=0) &amp;&amp; (attributes==visualAttributes))
00363     <span class="keywordflow">return</span> &amp;(*node);
00364 
00365   <a class="code" href="namespacebase.html#a5">Real</a> d = Math::maximum(<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>()*2.0,1.0);
00366 
00367   osg::Node* node0 = <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Sphereb0">createOSGSphere</a>(visualAttributes, <a class="code" href="namespacebase.html#a2">Int</a>(22*d));
00368   osg::Node* node1 = <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Sphereb0">createOSGSphere</a>(visualAttributes, <a class="code" href="namespacebase.html#a2">Int</a>(16*d));
00369   osg::Node* node2 = <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Sphereb0">createOSGSphere</a>(visualAttributes, <a class="code" href="namespacebase.html#a2">Int</a>(8*d));
00370   osg::Node* node3 = <a class="code" href="classphysics_1_1Sphere.html#physics_1_1Sphereb0">createOSGSphere</a>(visualAttributes, 8);
00371   
00372   osg::LOD* lod = <span class="keyword">new</span> osg::LOD();
00373   lod-&gt;setName(<span class="stringliteral">"Sphere"</span>);
00374   lod-&gt;addChild(node0);
00375   lod-&gt;addChild(node1);
00376   lod-&gt;addChild(node2);
00377   lod-&gt;addChild(node3);
00378 
00379   lod-&gt;setRange(0,0,2.0);
00380   lod-&gt;setRange(1,2.0,16.0);
00381   lod-&gt;setRange(2,16.0,120.0*d);
00382   lod-&gt;setRange(3,120.0*d,consts::Infinity);
00383 
00384   <span class="keywordflow">if</span> (!(visualAttributes &amp; Visual::ShowAxes))
00385     node = lod;
00386   <span class="keywordflow">else</span> {
00387     Group* group = <span class="keyword">new</span> Group();
00388     group-&gt;addChild( lod );
00389     group-&gt;addChild( <a class="code" href="classphysics_1_1Shape.html#physics_1_1Torusf0">createOSGAxes</a>(<a class="code" href="classbase_1_1Vector3.html">base::Dimension3</a>(<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>(),<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>(),<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea5">radius</a>())*2.0) );
00390     node = group;
00391   }
00392 
00393   attributes = visualAttributes;
00394   <span class="keywordflow">return</span> &amp;(*node);
00395 }
00396 
00397 
00398 <a class="code" href="classbase_1_1ref.html">base::ref&lt;CollisionModel&gt;</a> Sphere::getCollisionModel(CollisionModel::CollisionModelType modelType)<span class="keyword"> const</span>
00399 <span class="keyword"></span>{
00400   <span class="keywordflow">if</span> ((collisionModel!=0) &amp;&amp; 
00401       ((this-&gt;modelType==modelType) || (modelType==CollisionModel::AnyModel)))
00402     <span class="keywordflow">return</span> collisionModel;
00403   
00404   collisionModel = Shape::getCollisionModel(modelType);
00405   this-&gt;modelType=modelType;
00406 
00407   <span class="keywordflow">return</span> collisionModel;
00408 }
00409 
00410 
00411 <span class="keywordtype">void</span> Sphere::serialize(<a class="code" href="classbase_1_1Serializer.html">base::Serializer</a>&amp; s)
00412 {
00413   s(_radius);
00414 
00415   <span class="keywordflow">if</span> (s.<a class="code" href="classbase_1_1Serializer.html#base_1_1SimpleXMLSerializera8">isInput</a>()) {
00416     massPropertiesCached = <span class="keyword">false</span>;
00417     node = 0;
00418     collisionModel = ref&lt;CollisionModel&gt;(0);
00419   }
00420 }
00421 
00422 
00423 
00424 <span class="keywordtype">bool</span> Sphere::formatSupported(String format, Real version, ExternalizationType type)<span class="keyword"> const</span>
00425 <span class="keyword"></span>{ 
00426   <span class="keywordflow">return</span> ( (format==<span class="stringliteral">"xml"</span>) &amp;&amp; (version==1.0) ); 
00427 }
00428 
00429 
00430 <span class="keywordtype">void</span> Sphere::externalize(<a class="code" href="classbase_1_1Externalizer.html">base::Externalizer</a>&amp; e, String format, Real version)
00431 {
00432   <span class="keywordflow">if</span> (format == <span class="stringliteral">""</span>) format = <span class="stringliteral">"xml"</span>;
00433                                                                                                                                                                                                     
00434   <span class="keywordflow">if</span> (!<a class="code" href="classphysics_1_1Sphere.html#physics_1_1Spherea20">formatSupported</a>(format,version,e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera6">ioType</a>()))
00435     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"format "</span>)+format+<span class="stringliteral">" v"</span>+base::realToString(version)+<span class="stringliteral">" unsupported"</span>));
00436                                                                                                                                                                                                     
00437   <span class="keywordflow">if</span> (e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera4">isOutput</a>()) {
00438     
00439     DOMElement*  sphereElem = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera18">createElement</a>(<span class="stringliteral">"sphere"</span>);
00440     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera26">setElementAttribute</a>(sphereElem,<span class="stringliteral">"radius"</span>,base::realToString(_radius));
00441     
00442     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera21">appendElement</a>(sphereElem);
00443   }
00444   <span class="keywordflow">else</span> { <span class="comment">// input</span>
00445 
00446     massPropertiesCached = <span class="keyword">false</span>;
00447     node = 0;
00448     collisionModel = ref&lt;CollisionModel&gt;(0);
00449     
00450     DOMNode* context = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera16">context</a>();
00451     
00452     DOMElement* sphereElem = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera36">getFirstElement</a>(context, <span class="stringliteral">"sphere"</span>);
00453         
00454     _radius = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizere12">toReal</a>( e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera42">getDefaultedElementAttribute</a>(sphereElem, <span class="stringliteral">"radius"</span>, <span class="stringliteral">"1"</span>) );
00455 
00456     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera39">removeElement</a>(sphereElem);
00457          
00458   }
00459 }
00460 
00461 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:30 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
