<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: physics/Capsule.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>physics/Capsule.cpp</h1><a href="Capsule_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2004 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Capsule.cpp 1031 2004-02-11 20:46:36Z jungd $</span>
00019 <span class="comment"> </span>
00020 <span class="comment">****************************************************************************/</span>
00021 
00022 <span class="preprocessor">#include &lt;<a class="code" href="Capsule.html">physics/Capsule</a>&gt;</span>
00023 
00024 <span class="preprocessor">#include &lt;<a class="code" href="Externalizer.html">base/Externalizer</a>&gt;</span>
00025 <span class="preprocessor">#include &lt;<a class="code" href="VisualTriangles.html">gfx/VisualTriangles</a>&gt;</span>
00026 <span class="preprocessor">#include &lt;<a class="code" href="Material.html">physics/Material</a>&gt;</span>
00027 <span class="preprocessor">#include &lt;<a class="code" href="OBBCollisionModel.html">physics/OBBCollisionModel</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="GJKCollisionModel.html">physics/GJKCollisionModel</a>&gt;</span>
00029 
00030 <span class="preprocessor">#include &lt;osg/Group&gt;</span>
00031 <span class="preprocessor">#include &lt;osg/Geode&gt;</span>
00032 <span class="preprocessor">#include &lt;osg/LOD&gt;</span>
00033 <span class="preprocessor">#include &lt;osg/ShapeDrawable&gt;</span>
00034 
00035 <span class="keyword">using</span> <a class="code" href="classphysics_1_1Capsule.html">physics::Capsule</a>;
00036 
00037 <span class="keyword">using</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>;
00038 <span class="keyword">using</span> base::dom::DOMNode;
00039 <span class="keyword">using</span> base::dom::DOMElement;
00040 
00041 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Segment3.html">gfx::Segment3</a>;
00042 <span class="keyword">using</span> <a class="code" href="classgfx_1_1VisualTriangles.html">gfx::VisualTriangles</a>;
00043 
00044 <span class="keyword">using</span> <a class="code" href="classphysics_1_1MassProperties.html">physics::MassProperties</a>;
00045 <span class="keyword">using</span> <a class="code" href="classphysics_1_1CollisionModel.html">physics::CollisionModel</a>;
00046 <span class="keyword">using</span> <a class="code" href="classphysics_1_1OBBCollisionModel.html">physics::OBBCollisionModel</a>;
00047 <span class="keyword">using</span> <a class="code" href="classphysics_1_1GJKCollisionModel.html">physics::GJKCollisionModel</a>;
00048 
00049 
00050 <span class="keyword">using</span> osg::Node;
00051 <span class="keyword">using</span> osg::Group;
00052 <span class="keyword">using</span> osg::Geode;
00053 <span class="keyword">using</span> osg::LOD;
00054 <span class="keyword">using</span> osg::Vec3;
00055 <span class="keyword">using</span> osg::Vec2;
00056 
00057 
00058 Capsule::Capsule() 
00059   : _height(1.0), _radius(1.0), massPropertiesCached(false)
00060 {
00061 }
00062 
00063 Capsule::Capsule(Real height, Real radius) 
00064   : _height(height), _radius(radius), massPropertiesCached(false)
00065 {
00066   <span class="keywordflow">if</span> (_radius&lt;0) _radius=consts::epsilon;
00067 }
00068 
00069 Capsule::Capsule(<span class="keyword">const</span> Capsule&amp; c) 
00070   : _height(c._height), _radius(c._radius), massPropertiesCached(false)
00071 {
00072 }
00073 
00074 Capsule::~Capsule()
00075 {
00076 }
00077  
00078 <span class="comment"></span>
00079 <span class="comment">/// \todo this is calculated for a cylinder, correct it for capsule</span>
00080 <span class="comment"></span><span class="keyword">const</span> <a class="code" href="classphysics_1_1MassProperties.html">MassProperties</a>&amp; Capsule::getMassProperties(ref&lt;const Material&gt; material)<span class="keyword"> const </span>
00081 <span class="keyword"></span>{
00082   <span class="keywordflow">if</span> (massPropertiesCached &amp;&amp; (density == material-&gt;density()))
00083     <span class="keywordflow">return</span> massProperties;
00084 
00085   density = material-&gt;density();
00086   <a class="code" href="namespacebase.html#a5">Real</a> volume = consts::Pi*Math::sqr(_radius)*_height;
00087   massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertieso0">mass</a> = volume*density;
00088 
00089   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a> m = massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertieso0">mass</a>;
00090   Matrix3 Ibody;
00091   Ibody.e(1,1) = m*Math::sqr(_radius)/4.0 + m*Math::sqr(_height)/12.0;
00092   Ibody.e(2,2) = Ibody.e(1,1);
00093   Ibody.e(3,3) = m*Math::sqr(_radius)/2.0;
00094 
00095   massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertiesa7">setIbody</a>(Ibody);
00096   massProperties.<a class="code" href="classphysics_1_1MassProperties.html#physics_1_1MassPropertieso1">centerOfMass</a> = <a class="code" href="namespacebase.html#a26">Point3</a>(0.0,0.0,0.0);
00097 
00098   massPropertiesCached = <span class="keyword">true</span>;
00099   <span class="keywordflow">return</span> massProperties;
00100 }
00101 
00102 
00103 
00104 Segment3 Capsule::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> Point3&amp; p)<span class="keyword"> const</span>
00105 <span class="keyword"></span>{
00106   <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00107 }
00108 
00109 
00110 Segment3 Capsule::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Segment3.html">gfx::Segment3</a>&amp; s)<span class="keyword"> const</span>
00111 <span class="keyword"></span>{
00112   <span class="comment">// find the point on the axis segment closest to s</span>
00113   <a class="code" href="namespacebase.html#a26">Point3</a> axisstart(0,0,-<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea5">height</a>()/2.0); axisstart = t.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma34">transform</a>(axisstart);
00114   <a class="code" href="namespacebase.html#a26">Point3</a> axisend(0,0,<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea5">height</a>()/2.0); axisend = t.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma34">transform</a>(axisend);
00115   Segment3 axisseg( axisstart, axisend);
00116   Segment3 toaxis = s.<a class="code" href="classgfx_1_1Segment3.html#gfx_1_1Segment3a21">shortestSegmentBetween</a>(axisseg);
00117 
00118   <span class="comment">// now, shortest segment is identical to that from a sphere centered at</span>
00119   <span class="comment">//  toaxis.e and s</span>
00120   ref&lt;Sphere&gt; sphere( NewObj Sphere(<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea6">radius</a>()) );
00121   Transform center(toaxis.e);
00122   <span class="keywordflow">return</span> sphere-&gt;shortestSegmentBetween(center, s); 
00123 }
00124 
00125 
00126 Segment3 Capsule::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>&amp; tri)<span class="keyword"> const</span>
00127 <span class="keyword"></span>{
00128   <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00129 }
00130 
00131 
00132 Segment3 Capsule::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t, <span class="keyword">const</span> <a class="code" href="classgfx_1_1Quad3.html">gfx::Quad3</a>&amp; q)<span class="keyword"> const</span>
00133 <span class="keyword"></span>{
00134   <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00135 }
00136 
00137 
00138 Segment3 Capsule::shortestSegmentBetween(<span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t1, ref&lt;const Shape&gt; s, <span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t2)<span class="keyword"> const</span>
00139 <span class="keyword"></span>{
00140   <a class="code" href="debugtools.html#a12">Unimplemented</a>;
00141 }
00142 
00143 
00144 <span class="comment"></span>
00145 <span class="comment">/// \todo use Geometry &amp; add normals</span>
00146 <span class="comment"></span>osg::Node* Capsule::createOSGCapsule(Visual::Attributes visualAttributes,
00147                                      Int slices, Int stacks)<span class="keyword"> const</span>
00148 <span class="keyword"></span>{
00149   
00150   <span class="keywordtype">bool</span> onlyVerts = ((visualAttributes &amp; Visual::VerticesOnly) != 0);
00151 
00152   <span class="comment">// oriented along the z-axis </span>
00153   osg::ref_ptr&lt;osg::ShapeDrawable&gt; shapeDrawable = <span class="keyword">new</span> osg::ShapeDrawable(<span class="keyword">new</span> osg::Capsule(osg::Vec3(0.0f,0.0f,0.0f),<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea6">radius</a>(),<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea5">height</a>()));
00154   osg::ref_ptr&lt;osg::TessellationHints&gt; tessHints = <span class="keyword">new</span> osg::TessellationHints();
00155   tessHints-&gt;setTargetNumFaces(slices*stacks);
00156   tessHints-&gt;setTessellationMode(osg::TessellationHints::USE_TARGET_NUM_FACES);
00157   tessHints-&gt;setCreateNormals(!onlyVerts);
00158   tessHints-&gt;setCreateTextureCoords(!onlyVerts);
00159   shapeDrawable-&gt;setTessellationHints(&amp;(*tessHints));
00160 
00161   osg::Geode* geode = <span class="keyword">new</span> osg::Geode();
00162   geode-&gt;addDrawable(&amp;(*shapeDrawable));
00163 <span class="comment">/*</span>
00164 <span class="comment">  osg::TriangleMesh* mesh = new osg::TriangleMesh();</span>
00165 <span class="comment">  array&lt;Vec3&gt;&amp; verts = *new array&lt;Vec3&gt;(0,128);</span>
00166 <span class="comment">  array&lt;Int&gt;&amp; indices = *new array&lt;Int&gt;(0,128);</span>
00167 <span class="comment">  if (((slices%4) != 0)) slices += (4-slices%4); // make multiple of 4</span>
00168 <span class="comment">  const Int n = slices; </span>
00169 <span class="comment">  Real l = height()/2.0;</span>
00170 <span class="comment">  Real r = radius();</span>
00171 <span class="comment"></span>
00172 <span class="comment">  Real a = (consts::Pi*2.0)/Real(n);</span>
00173 <span class="comment">  Real sa = Math::sin(a);</span>
00174 <span class="comment">  Real ca = Math::cos(a);</span>
00175 <span class="comment">  Real tmp;</span>
00176 <span class="comment">  </span>
00177 <span class="comment">  // cylinder body</span>
00178 <span class="comment">  Real ny=1, nz=0;</span>
00179 <span class="comment">  Int v=0;</span>
00180 <span class="comment">  for(Int i=0; i&lt;=n; i++) {</span>
00181 <span class="comment">    verts.push_back(Vec3(ny*r,nz*r,l));</span>
00182 <span class="comment">    if (v&gt;1) {</span>
00183 <span class="comment">      indices.push_back(v-2);</span>
00184 <span class="comment">      indices.push_back(v-1);</span>
00185 <span class="comment">      indices.push_back(v);</span>
00186 <span class="comment">    }</span>
00187 <span class="comment">    ++v;</span>
00188 <span class="comment"></span>
00189 <span class="comment">    verts.push_back(Vec3(ny*r,nz*r,-l));</span>
00190 <span class="comment">    if (v&gt;1) {</span>
00191 <span class="comment">      indices.push_back(v);</span>
00192 <span class="comment">      indices.push_back(v-1);</span>
00193 <span class="comment">      indices.push_back(v-2);</span>
00194 <span class="comment">    }</span>
00195 <span class="comment">    ++v;</span>
00196 <span class="comment"></span>
00197 <span class="comment">    // rotate ny,nz</span>
00198 <span class="comment">    tmp = ca*ny - sa*nz;</span>
00199 <span class="comment">    nz = sa*ny + ca*nz;</span>
00200 <span class="comment">    ny = tmp;</span>
00201 <span class="comment">  }</span>
00202 <span class="comment">  </span>
00203 <span class="comment">  </span>
00204 <span class="comment">  // first cap</span>
00205 <span class="comment">  Real start_nx = 0, start_ny = 1;</span>
00206 <span class="comment">  for(Int j=0; j&lt;(n/4); j++) {</span>
00207 <span class="comment">    // get start_n2 = rotated start_n</span>
00208 <span class="comment">    Real start_nx2 =  ca*start_nx + sa*start_ny;</span>
00209 <span class="comment">    Real start_ny2 = -sa*start_nx + ca*start_ny;</span>
00210 <span class="comment">    // get n=start_n and n2=start_n2</span>
00211 <span class="comment">    Real nx = start_nx; ny = start_ny; nz = 0;</span>
00212 <span class="comment">    Real nx2 = start_nx2, ny2 = start_ny2, nz2 = 0;</span>
00213 <span class="comment"></span>
00214 <span class="comment">    Int iv = v;</span>
00215 <span class="comment">    for (Int i=0; i&lt;=n; i++) {</span>
00216 <span class="comment"></span>
00217 <span class="comment">      verts.push_back(Vec3(ny2*r,nz2*r,l+nx2*r));</span>
00218 <span class="comment">      if ((v-iv)&gt;1) {</span>
00219 <span class="comment">        indices.push_back(v-2);</span>
00220 <span class="comment">        indices.push_back(v-1);</span>
00221 <span class="comment">        indices.push_back(v);</span>
00222 <span class="comment">      }</span>
00223 <span class="comment">      ++v;</span>
00224 <span class="comment"></span>
00225 <span class="comment">      verts.push_back(Vec3(ny*r,nz*r,l+nx*r));</span>
00226 <span class="comment">      if ((v-iv)&gt;1) {</span>
00227 <span class="comment">        indices.push_back(v);</span>
00228 <span class="comment">        indices.push_back(v-1);</span>
00229 <span class="comment">        indices.push_back(v-2);</span>
00230 <span class="comment">      }</span>
00231 <span class="comment">      ++v;</span>
00232 <span class="comment">      </span>
00233 <span class="comment">      // rotate n,n2</span>
00234 <span class="comment">      tmp = ca*ny - sa*nz;</span>
00235 <span class="comment">      nz = sa*ny + ca*nz;</span>
00236 <span class="comment">      ny = tmp;</span>
00237 <span class="comment">      tmp = ca*ny2- sa*nz2;</span>
00238 <span class="comment">      nz2 = sa*ny2 + ca*nz2;</span>
00239 <span class="comment">      ny2 = tmp;</span>
00240 <span class="comment">    }</span>
00241 <span class="comment"></span>
00242 <span class="comment">    start_nx = start_nx2;</span>
00243 <span class="comment">    start_ny = start_ny2;</span>
00244 <span class="comment">    </span>
00245 <span class="comment">  }</span>
00246 <span class="comment">  </span>
00247 <span class="comment">  </span>
00248 <span class="comment">  // second cap</span>
00249 <span class="comment">  start_nx = 0;</span>
00250 <span class="comment">  start_ny = 1;</span>
00251 <span class="comment">  for (Int j=0; j&lt;(n/4); j++) {</span>
00252 <span class="comment">    // get start_n2 = rotated start_n</span>
00253 <span class="comment">    Real start_nx2 = ca*start_nx - sa*start_ny;</span>
00254 <span class="comment">    Real start_ny2 = sa*start_nx + ca*start_ny;</span>
00255 <span class="comment">    // get n=start_n and n2=start_n2</span>
00256 <span class="comment">    Real nx = start_nx; ny = start_ny; nz = 0;</span>
00257 <span class="comment">    Real nx2 = start_nx2, ny2 = start_ny2, nz2 = 0;</span>
00258 <span class="comment"></span>
00259 <span class="comment">    Int iv = v;</span>
00260 <span class="comment">    for (Int i=0; i&lt;=n; i++) {</span>
00261 <span class="comment"></span>
00262 <span class="comment">      verts.push_back(Vec3(ny*r,nz*r,-l+nx*r));</span>
00263 <span class="comment">      if ((v-iv)&gt;1) {</span>
00264 <span class="comment">        indices.push_back(v-2);</span>
00265 <span class="comment">        indices.push_back(v-1);</span>
00266 <span class="comment">        indices.push_back(v);</span>
00267 <span class="comment">      }</span>
00268 <span class="comment">      ++v;</span>
00269 <span class="comment"></span>
00270 <span class="comment">      verts.push_back(Vec3(ny2*r,nz2*r,-l+nx2*r));</span>
00271 <span class="comment">      if ((v-iv)&gt;1) {</span>
00272 <span class="comment">        indices.push_back(v);</span>
00273 <span class="comment">        indices.push_back(v-1);</span>
00274 <span class="comment">        indices.push_back(v-2);</span>
00275 <span class="comment">      }</span>
00276 <span class="comment">      ++v;</span>
00277 <span class="comment">      </span>
00278 <span class="comment">      // rotate n,n2</span>
00279 <span class="comment">      tmp = ca*ny - sa*nz;</span>
00280 <span class="comment">      nz = sa*ny + ca*nz;</span>
00281 <span class="comment">      ny = tmp;</span>
00282 <span class="comment">      tmp = ca*ny2- sa*nz2;</span>
00283 <span class="comment">      nz2 = sa*ny2 + ca*nz2;</span>
00284 <span class="comment">      ny2 = tmp;</span>
00285 <span class="comment">    }</span>
00286 <span class="comment"></span>
00287 <span class="comment">    start_nx = start_nx2;</span>
00288 <span class="comment">    start_ny = start_ny2;</span>
00289 <span class="comment">  }</span>
00290 <span class="comment">  </span>
00291 <span class="comment">  </span>
00292 <span class="comment">  </span>
00293 <span class="comment">  </span>
00294 <span class="comment">  // convert to OSG arrays</span>
00295 <span class="comment">  osg::Vec3Array* va = new osg::Vec3Array(verts.size());</span>
00296 <span class="comment">  for(Int i=0; i&lt;verts.size(); i++)</span>
00297 <span class="comment">    (*va)[i] = verts[i];</span>
00298 <span class="comment">  mesh-&gt;setVertices(va);</span>
00299 <span class="comment"></span>
00300 <span class="comment">  osg::IntArray* ia = new osg::IntArray(indices.size());</span>
00301 <span class="comment">  for(Int i=0; i&lt;indices.size(); i++) {</span>
00302 <span class="comment">    (*ia)[i] = indices[i];</span>
00303 <span class="comment">  }</span>
00304 <span class="comment">  mesh-&gt;setIndices(ia);</span>
00305 <span class="comment"></span>
00306 <span class="comment">  osg::Geode* geode = new osg::Geode();</span>
00307 <span class="comment">  geode-&gt;setName("Capsule");</span>
00308 <span class="comment">  geode-&gt;addDrawable(new osg::ShapeDrawable(mesh));</span>
00309 <span class="comment">  */</span> 
00310   <span class="keywordflow">return</span> geode;
00311 }
00312 
00313 
00314 
00315 osg::Node* Capsule::createOSGVisual(Visual::Attributes visualAttributes)<span class="keyword"> const</span>
00316 <span class="keyword"></span>{
00317   <span class="keywordflow">if</span> ((node!=0) &amp;&amp; (attributes==visualAttributes))
00318     <span class="keywordflow">return</span> &amp;(*node);
00319 
00320   <a class="code" href="namespacebase.html#a5">Real</a> r = Math::maximum(0.5,<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea6">radius</a>());
00321   <a class="code" href="namespacebase.html#a5">Real</a> h = Math::maximum(1.0,<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea5">height</a>());
00322 
00323 <span class="comment">//  osg::Node* node0 = createOSGCapsule(visualAttributes, Int(52*r), (h&lt;40)?Int(12*h):2000);</span>
00324 <span class="comment">//  osg::Node* node1 = createOSGCapsule(visualAttributes, Int(40*r), (h&lt;40)?Int(8*h):1300);</span>
00325 <span class="comment">//  osg::Node* node2 = createOSGCapsule(visualAttributes, Int(20*r), (h&lt;40)?Int(4*h):700);</span>
00326 <span class="comment">//  osg::Node* node3 = createOSGCapsule(visualAttributes, 8, 1);</span>
00327 
00328 <span class="comment">//replace above after normals added (i.e. switched from mesh to geometry)</span>
00329   osg::Node* node0 = <a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsuleb0">createOSGCapsule</a>(visualAttributes, <a class="code" href="namespacebase.html#a2">Int</a>(104*r), (h&lt;40)?<a class="code" href="namespacebase.html#a2">Int</a>(12*h):2000);
00330   osg::Node* node1 = <a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsuleb0">createOSGCapsule</a>(visualAttributes, <a class="code" href="namespacebase.html#a2">Int</a>(80*r), (h&lt;40)?<a class="code" href="namespacebase.html#a2">Int</a>(8*h):1300);
00331   osg::Node* node2 = <a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsuleb0">createOSGCapsule</a>(visualAttributes, <a class="code" href="namespacebase.html#a2">Int</a>(40*r), (h&lt;40)?<a class="code" href="namespacebase.html#a2">Int</a>(4*h):700);
00332   osg::Node* node3 = <a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsuleb0">createOSGCapsule</a>(visualAttributes, 16, 1);
00333 
00334   
00335   osg::LOD* lod = <span class="keyword">new</span> osg::LOD();
00336   lod-&gt;setName(<span class="stringliteral">"Capsule"</span>);
00337   lod-&gt;addChild(node0);
00338   lod-&gt;addChild(node1);
00339   lod-&gt;addChild(node2);
00340   lod-&gt;addChild(node3);
00341 
00342   lod-&gt;setRange(0,0,2.0);
00343   lod-&gt;setRange(1,2.0,16.0);
00344   lod-&gt;setRange(2,16.0,120.0*Math::maximum(r,h));
00345   lod-&gt;setRange(3,120.0*Math::maximum(r,h),consts::Infinity);
00346 
00347   <span class="keywordflow">if</span> (!(visualAttributes &amp; Visual::ShowAxes))
00348     node = lod;
00349   <span class="keywordflow">else</span> {
00350     Group* group = <span class="keyword">new</span> Group();
00351     group-&gt;addChild( lod );
00352     group-&gt;addChild( <a class="code" href="classphysics_1_1Shape.html#physics_1_1Torusf0">createOSGAxes</a>(<a class="code" href="classbase_1_1Vector3.html">base::Dimension3</a>(2.0*<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea6">radius</a>(),2.0*<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea6">radius</a>(),<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea5">height</a>())) );
00353     node = group;
00354   }
00355 
00356   attributes = visualAttributes;
00357   <span class="keywordflow">return</span> &amp;(*node);
00358 }
00359 
00360 
00361 
00362 <a class="code" href="classbase_1_1ref.html">base::ref&lt;CollisionModel&gt;</a> Capsule::getCollisionModel(CollisionModel::CollisionModelType modelType)<span class="keyword"> const</span>
00363 <span class="keyword"></span>{
00364   <span class="keywordflow">if</span> ((collisionModel!=0) &amp;&amp; 
00365       ((this-&gt;modelType==modelType) || (modelType==CollisionModel::AnyModel)))
00366     <span class="keywordflow">return</span> collisionModel;
00367   
00368   collisionModel = Shape::getCollisionModel(modelType);
00369   this-&gt;modelType=modelType;
00370 
00371   <span class="keywordflow">return</span> collisionModel;
00372 }
00373 
00374 
00375 <span class="keywordtype">void</span> Capsule::serialize(<a class="code" href="classbase_1_1Serializer.html">base::Serializer</a>&amp; s)
00376 {
00377   s(_height)(_radius);
00378 
00379   <span class="keywordflow">if</span> (s.<a class="code" href="classbase_1_1Serializer.html#base_1_1SimpleXMLSerializera8">isInput</a>()) {
00380     massPropertiesCached = <span class="keyword">false</span>;
00381     node = 0;
00382     collisionModel = ref&lt;CollisionModel&gt;(0);
00383   }
00384 }
00385 
00386 
00387 
00388 <span class="keywordtype">bool</span> Capsule::formatSupported(String format, Real version, ExternalizationType type)<span class="keyword"> const</span>
00389 <span class="keyword"></span>{ 
00390   <span class="keywordflow">return</span> ( (format==<span class="stringliteral">"xml"</span>) &amp;&amp; (version==1.0) ); 
00391 }
00392 
00393 
00394 <span class="keywordtype">void</span> Capsule::externalize(<a class="code" href="classbase_1_1Externalizer.html">base::Externalizer</a>&amp; e, String format, Real version)
00395 {
00396   <span class="keywordflow">if</span> (format == <span class="stringliteral">""</span>) format = <span class="stringliteral">"xml"</span>;
00397                                                                                                                                                                                                     
00398   <span class="keywordflow">if</span> (!<a class="code" href="classphysics_1_1Capsule.html#physics_1_1Capsulea21">formatSupported</a>(format,version,e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera6">ioType</a>()))
00399     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"format "</span>)+format+<span class="stringliteral">" v"</span>+base::realToString(version)+<span class="stringliteral">" unsupported"</span>));
00400                                                                                                                                                                                                     
00401   <span class="keywordflow">if</span> (e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera4">isOutput</a>()) {
00402     
00403     DOMElement*  capsuleElem = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera18">createElement</a>(<span class="stringliteral">"capsule"</span>);
00404     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera26">setElementAttribute</a>(capsuleElem,<span class="stringliteral">"height"</span>,base::realToString(_height));
00405     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera26">setElementAttribute</a>(capsuleElem,<span class="stringliteral">"radius"</span>,base::realToString(_radius));
00406     
00407     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera21">appendElement</a>(capsuleElem);
00408   }
00409   <span class="keywordflow">else</span> { <span class="comment">// input</span>
00410     
00411     massPropertiesCached = <span class="keyword">false</span>;
00412     node = 0;
00413     collisionModel = ref&lt;CollisionModel&gt;(0);
00414 
00415     DOMNode* context = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera16">context</a>();
00416     
00417     DOMElement* capsuleElem = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera36">getFirstElement</a>(context, <span class="stringliteral">"capsule"</span>);
00418         
00419     _height = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizere12">toReal</a>( e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera42">getDefaultedElementAttribute</a>(capsuleElem, <span class="stringliteral">"height"</span>, <span class="stringliteral">"1"</span>) );
00420     _radius = e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizere12">toReal</a>( e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera42">getDefaultedElementAttribute</a>(capsuleElem, <span class="stringliteral">"radius"</span>, <span class="stringliteral">"1"</span>) );
00421         
00422     e.<a class="code" href="classbase_1_1Externalizer.html#base_1_1Externalizera39">removeElement</a>(capsuleElem);
00423     
00424   }
00425 }
00426 
00427 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:21 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
