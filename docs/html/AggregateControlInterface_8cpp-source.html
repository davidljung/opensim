<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: robot/AggregateControlInterface.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>robot/AggregateControlInterface.cpp</h1><a href="AggregateControlInterface_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2003 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: AggregateControlInterface.cpp 1039 2004-02-11 20:50:52Z jungd $</span>
00019 <span class="comment">  $Revision: 1.1 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:50:52 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="AggregateControlInterface.html">robot/AggregateControlInterface</a>&gt;</span>
00026 
00027 <span class="keyword">using</span> <a class="code" href="classrobot_1_1AggregateControlInterface.html">robot::AggregateControlInterface</a>;
00028 
00029 
00030 
00031 AggregateControlInterface::AggregateControlInterface(<span class="keyword">const</span> String&amp; name, <span class="keyword">const</span> String&amp; type,
00032                                                      array&lt;ref&lt;ControlInterface&gt; &gt; interfaces)
00033  : ControlInterface(name,type), interfaces(interfaces)
00034 {
00035   <span class="keywordflow">if</span> (interfaces.size() &lt; 1)
00036     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"must supply at least one ControlInterface"</span>));
00037   
00038   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>.resize(interfaces.size()+1);
00039   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>.resize(interfaces.size()+1);
00040 }
00041                             
00042                             
00043 AggregateControlInterface::AggregateControlInterface(<span class="keyword">const</span> String&amp; name, <span class="keyword">const</span> String&amp; type,
00044                                                      ref&lt;ControlInterface&gt; interface1, 
00045                                                      ref&lt;ControlInterface&gt; interface2)
00046   : ControlInterface(name,type)
00047 {
00048   <a class="code" href="base.html#a19">Assert</a>(interface1);
00049   <a class="code" href="base.html#a19">Assert</a>(interface2);
00050   
00051   interfaces.resize(2);
00052   interfaces[0] = interface1;
00053   interfaces[1] = interface2;
00054   
00055   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>.resize(3);
00056   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>.resize(3);
00057 }
00058 
00059 
00060 AggregateControlInterface::AggregateControlInterface(<span class="keyword">const</span> AggregateControlInterface&amp; aci)
00061   : ControlInterface(aci), interfaces(aci.interfaces)
00062 {
00063   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>.resize(interfaces.size()+1);
00064   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>.resize(interfaces.size()+1);
00065 }
00066 
00067 
00068 
00069 <span class="keyword">inline</span> <span class="keywordtype">void</span> AggregateControlInterface::inputIndex(Int aindex, Int&amp; interfaceIndex, Int&amp; index)<span class="keyword"> const</span>
00070 <span class="keyword"></span>{
00071   interfaceIndex=1;
00072   <span class="keywordflow">while</span> (<a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>[interfaceIndex] &lt; aindex) interfaceIndex++;
00073   interfaceIndex--;
00074   index = aindex - <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>[interfaceIndex];
00075 }
00076 
00077 
00078 <span class="keyword">inline</span> <span class="keywordtype">void</span> AggregateControlInterface::outputIndex(Int aindex, Int&amp; interfaceIndex, Int&amp; index)<span class="keyword"> const</span>
00079 <span class="keyword"></span>{
00080   interfaceIndex=1;
00081   <span class="keywordflow">while</span> (<a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>[interfaceIndex] &lt; aindex) interfaceIndex++;
00082   interfaceIndex--;
00083   index = aindex - <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>[interfaceIndex];
00084 }
00085 
00086 
00087 
00088 <a class="code" href="namespacebase.html#a4">String</a> AggregateControlInterface::inputName(Int i)<span class="keyword"> const</span>
00089 <span class="keyword"></span>{
00090   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb0">recomputeInputSize</a>();
00091   <a class="code" href="base.html#a19">Assert</a>( i &lt; numInputs);
00092   <a class="code" href="namespacebase.html#a2">Int</a> interfaceIndex, index;
00093   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb2">inputIndex</a>(i, interfaceIndex, index);
00094   <span class="keywordflow">return</span> interfaces[interfaceIndex]-&gt;inputName(index);
00095 }
00096 
00097 
00098 <a class="code" href="namespacebase.html#a5">Real</a> AggregateControlInterface::getInput(Int i)<span class="keyword"> const</span>
00099 <span class="keyword"></span>{
00100   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb0">recomputeInputSize</a>();
00101   <a class="code" href="base.html#a19">Assert</a>( i &lt; numInputs);
00102   <a class="code" href="namespacebase.html#a2">Int</a> interfaceIndex, index;
00103   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb2">inputIndex</a>(i, interfaceIndex, index);
00104   <span class="keywordflow">return</span> interfaces[interfaceIndex]-&gt;getInput(index);
00105 }
00106 
00107 
00108 <span class="keyword">const</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>&amp; AggregateControlInterface::getInputs()<span class="keyword"> const </span>
00109 <span class="keyword"></span>{
00110   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb0">recomputeInputSize</a>();
00111   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep3">lastInputs</a>.resize(numInputs);
00112   
00113   <a class="code" href="namespacebase.html#a2">Int</a> interfaceIndex=0;
00114   <a class="code" href="namespacebase.html#a2">Int</a> interfaceOffset=0;
00115   ref&lt;ControlInterface&gt; interface(interfaces[0]);
00116   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep1">numInputs</a>; i++) {
00117     <span class="keywordflow">if</span> (i == <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>[interfaceIndex+1]) {
00118       interfaceIndex++;
00119       interface = interfaces[interfaceIndex];
00120       interfaceOffset = inputOffsets[interfaceIndex];
00121     }
00122     <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep3">lastInputs</a>[i] = interface-&gt;getInput( i - interfaceOffset);
00123   }
00124   <span class="keywordflow">return</span> <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep3">lastInputs</a>;
00125 }
00126 
00127 
00128 <a class="code" href="namespacebase.html#a4">String</a> AggregateControlInterface::outputName(Int i)<span class="keyword"> const</span>
00129 <span class="keyword"></span>{
00130   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb1">recomputeOutputSize</a>();
00131   <a class="code" href="base.html#a19">Assert</a>( i &lt; numOutputs);
00132   <a class="code" href="namespacebase.html#a2">Int</a> interfaceIndex, index;
00133   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb3">outputIndex</a>(i, interfaceIndex, index);
00134   <span class="keywordflow">return</span> interfaces[interfaceIndex]-&gt;outputName(index);
00135 }
00136 
00137 
00138 <span class="keywordtype">void</span> AggregateControlInterface::setOutput(Int i, Real value)
00139 {
00140   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb1">recomputeOutputSize</a>();
00141   <a class="code" href="base.html#a19">Assert</a>( i &lt; numOutputs);
00142   <a class="code" href="namespacebase.html#a2">Int</a> interfaceIndex, index;
00143   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb3">outputIndex</a>(i, interfaceIndex, index);
00144   interfaces[interfaceIndex]-&gt;setOutput(index, value );
00145 }
00146 
00147 
00148 <span class="keywordtype">void</span> AggregateControlInterface::setOutputs(<span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; values) 
00149 {
00150   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfaceb1">recomputeOutputSize</a>();
00151   <a class="code" href="base.html#a19">Assert</a>(values.size() == <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep2">numOutputs</a>);
00152   
00153   <a class="code" href="namespacebase.html#a2">Int</a> interfaceIndex=0;
00154   <a class="code" href="namespacebase.html#a2">Int</a> interfaceOffset=0;
00155   ref&lt;ControlInterface&gt; interface(interfaces[0]);
00156   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep2">numOutputs</a>; i++) {
00157     <span class="keywordflow">if</span> (i == <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>[interfaceIndex+1]) {
00158       interfaceIndex++;
00159       interface = interfaces[interfaceIndex];
00160       interfaceOffset = outputOffsets[interfaceIndex];
00161     }
00162     interface-&gt;setOutput( i - interfaceOffset, values[i]);
00163   }
00164 }
00165 
00166 
00167 <span class="keywordtype">void</span> AggregateControlInterface::recomputeInputSize()<span class="keyword"> const</span>
00168 <span class="keyword"></span>{
00169   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep1">numInputs</a>=0;
00170   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;interfaces.size(); i++) {
00171     <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>[i] = <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep1">numInputs</a>;
00172     numInputs += interfaces[i]-&gt;inputSize();
00173   }
00174   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep4">inputOffsets</a>[interfaces.size()] = <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep1">numInputs</a>;
00175 }
00176 
00177 
00178 <span class="keywordtype">void</span> AggregateControlInterface::recomputeOutputSize()<span class="keyword"> const</span>
00179 <span class="keyword"></span>{
00180   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep2">numOutputs</a>=0;
00181   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;interfaces.size(); i++) {
00182     <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>[i] = <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep2">numOutputs</a>;
00183     numOutputs += interfaces[i]-&gt;outputSize();
00184   }
00185   <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep5">outputOffsets</a>[interfaces.size()] = <a class="code" href="classrobot_1_1AggregateControlInterface.html#robot_1_1AggregateControlInterfacep2">numOutputs</a>;
00186 }
00187 
00188 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:31 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
