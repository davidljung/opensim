<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/MemoryTracer Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/MemoryTracer</h1><a href="MemoryTracer.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: MemoryTracer 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.5 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment">  </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#ifndef _BASE_MEMORYTRACER_</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#define _BASE_MEMORYTRACER_</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="base.html">base/base</a>&gt;</span>
00029 <span class="preprocessor">#include &lt;string&gt;</span>
00030 
00031 
00032 <span class="keyword">namespace </span><a class="code" href="base_2Jamfile_8ft.html#a0">base</a> {
00033 
00034 
00035 
00036 <span class="preprocessor">#ifdef DEBUG</span>
00037 <span class="preprocessor"></span>
00038 <span class="comment">// if this is defined, memory is traced, otherwise the global new/delete operators are</span>
00039 <span class="comment">//  not overloaded</span>
00040 <span class="comment">//#define _TRACEMEMORY_</span>
00041 
00042 <span class="comment">// if this is defined and tracing is being used, the new and delete operators will output to stderr</span>
00043 <span class="comment">//#define TRACEOUTPUT</span>
00044 
00045 <span class="comment">// if this is defined and TRACEOUTPUT is defined, then new/delete will only output named allocations</span>
00046 <span class="preprocessor">#define _NAMEDOUTPUTONLY_</span>
00047 <span class="preprocessor"></span>
00048 
00049 <span class="comment">// if this is defined, extra integrity checks will be performed for memory overwrite</span>
00050 <span class="comment">// (these are very slow).</span>
00051 <span class="preprocessor">#define _FULLINTEGRITYCHECK_ 1</span>
00052 <span class="preprocessor"></span>
00053 <span class="comment">// if 1, a full memory check is performed on every call to new or delete</span>
00054 <span class="comment">// if 0, a check is never performed (except by excplict call to checkAllMemory())</span>
00055 <span class="comment">// if n, a full memory check is performed on every n'th call to new or delete</span>
00056 <span class="preprocessor">#define _FULLCHECKFREQUENTY_ 100</span>
00057 <span class="preprocessor"></span>
00058 
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>
00061 
00062 
00063 
<a name="l00064"></a><a class="code" href="classbase_1_1MemoryTracer.html">00064</a>   <span class="keyword">class </span><a class="code" href="classbase_1_1MemoryTracer.html">MemoryTracer</a>
00065   {
00066   <span class="keyword">public</span>:
00067     <span class="keyword">static</span> <span class="keywordtype">void</span>* <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere0">allocate</a>(<span class="keywordtype">int</span> size, <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">bool</span> isArray=<span class="keyword">false</span>) <span class="keywordflow">throw</span>(std::bad_alloc);
00068     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere1">release</a>(<span class="keywordtype">void</span>* address, <span class="keywordtype">bool</span> isArray=<span class="keyword">false</span>, <span class="keywordtype">int</span> size = -1) <span class="keywordflow">throw</span>(std::bad_alloc);
00069     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere2">validate</a>(<span class="keywordtype">void</span> *address, <span class="keywordtype">int</span> size, <span class="keyword">const</span> std::string&amp; name) <span class="keywordflow">throw</span>(std::bad_alloc);
00070     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere3">invalidate</a>(<span class="keywordtype">void</span>* address, <span class="keywordtype">int</span> size) <span class="keywordflow">throw</span>(std::bad_alloc);
00071 
00072     <span class="keyword">static</span> <span class="keywordtype">void</span>* <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere4">checkAddrRange</a>(<span class="keywordtype">void</span>* address, <span class="keywordtype">long</span> typesize) <span class="keywordflow">throw</span>(std::bad_alloc);
00073     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere5">checkAddr</a>(<span class="keywordtype">void</span>* address, <span class="keywordtype">void</span>* reportAddr = 0, <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere6">checkAllMemory</a> = <span class="keyword">true</span>) <span class="keywordflow">throw</span>(std::bad_alloc);
00074     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere6">checkAllMemory</a>() <span class="keywordflow">throw</span>(std::bad_alloc);
00075 
00076     <span class="keyword">static</span> <span class="keywordtype">char</span>* <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere7">getName</a>(<span class="keywordtype">void</span>* addr);
00077     <span class="keyword">static</span> <span class="keywordtype">long</span>  <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere8">getOffset</a>(<span class="keywordtype">void</span>* addr);
00078 
00079     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere9">cleanup</a>();
00080     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere10">menu</a>() <span class="keywordflow">throw</span>(std::bad_alloc);
00081     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere11">dump</a>() ;
00082     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere12">dumpNamed</a>();
00083     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere13">dumpDeallocated</a>();
00084     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere14">handleError</a>() <span class="keywordflow">throw</span>(std::bad_alloc);
00085 
00086   <span class="keyword">protected</span>:
00087     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf0">Logerr</a>(<span class="keywordtype">char</span>* errstr);
00088     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf1">entrylock</a>();
00089     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf2">exitunlock</a>();
00090     <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf3">causefault</a>();
<a name="l00091"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf4">00091</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf4">fill</a>() 
00092     {
00093       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert0">Filling</a>; i++) 
00094         prefill[i]  = postfill[i] = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert1">Filler</a>;
00095     }
00096 
<a name="l00097"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf5">00097</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf5">isOK</a>() 
00098     {
00099       <span class="keywordflow">if</span> (<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert8">initialized</a> != (<a class="code" href="namespacebase.html#a0">Byte</a>)<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert2">Magic</a>) { 
00100         <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert8">initialized</a> = (<a class="code" href="namespacebase.html#a0">Byte</a>)<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert2">Magic</a>;
00101         <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracerf4">fill</a>();
00102         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00103       }
00104 <span class="preprocessor">#ifdef _FULLINTEGRITYCHECK_</span>
00105 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert0">Filling</a>; i++) 
00106         <span class="keywordflow">if</span> ((prefill[i] != <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert1">Filler</a>) || (postfill[i] != <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert1">Filler</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;
00109     }
00110     
<a name="l00111"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert0">00111</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacebase.html#a0">Byte</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert0">Filling</a> = 8;    <span class="comment">// no of extra bytes to add before &amp; after allocated memory </span>
<a name="l00112"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert1">00112</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacebase.html#a0">Byte</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert1">Filler</a> = 0xea;  <span class="comment">// byte placed in filling space for integrity check </span>
<a name="l00113"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert2">00113</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert2">Magic</a> = 13456;   <span class="comment">// must be &lt; 16384 </span>
<a name="l00114"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert3">00114</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert3">External</a> = 32768;<span class="comment">// mask for marking mem as external </span>
00115     
<a name="l00116"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert4">00116</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert4">IsArray</a>;
<a name="l00117"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert5">00117</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert5">IsNotArray</a>;
00118     
<a name="l00119"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">00119</a>     <span class="keyword">struct </span><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a> {
<a name="l00120"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya0">00120</a>       <span class="keywordtype">bool</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya0">isExternal</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">magic</a> &amp; External); }
<a name="l00121"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya1">00121</a>       <span class="keywordtype">void</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya1">setExternal</a>() { <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">magic</a> = (External | Magic); }
<a name="l00122"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya2">00122</a>       <span class="keywordtype">void</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya2">clearExternal</a>() { <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">magic</a> = Magic; }
<a name="l00123"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya3">00123</a>       <span class="keywordtype">void</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya3">setMagic</a>() { <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">magic</a> = Magic; }
<a name="l00124"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya4">00124</a>       <span class="keywordtype">bool</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya4">isMagic</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ((<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">magic</a>&amp;Magic) == Magic); }
<a name="l00125"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya5">00125</a>       <span class="keywordtype">bool</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya5">isNotMagic</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya4">isMagic</a>(); }
00126       
<a name="l00127"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya6">00127</a>       <span class="keywordtype">void</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya6">fill</a>() 
00128       {
00129         <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;Filling; i++) 
00130           <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo0">prefill</a>[i]  = <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo8">postfill</a>[i] = Filler;
00131       }
00132 
<a name="l00133"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya7">00133</a>       <span class="keywordtype">bool</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya7">isOK</a>()<span class="keyword"> const </span>
00134 <span class="keyword">      </span>{
00135 <span class="preprocessor">#ifdef _FULLINTEGRITYCHECK_</span>
00136 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;Filling; i++) 
00137           <span class="keywordflow">if</span> ((<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo0">prefill</a>[i] != Filler) || (<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo8">postfill</a>[i] != Filler)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00138       <span class="keywordflow">if</span> ((<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo3">arrayFlag</a> != MemoryTracer::IsArray) &amp;&amp; (<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo3">arrayFlag</a> != MemoryTracer::IsNotArray)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00139 <span class="preprocessor">#endif</span>
00140 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (size&lt;=0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00141         <span class="keywordflow">if</span> (<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya5">isNotMagic</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00142         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00143       }
00144 
<a name="l00145"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya8">00145</a>       <span class="keywordtype">bool</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya8">isArray</a>() { <span class="keywordflow">return</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo3">arrayFlag</a> == MemoryTracer::IsArray; }
<a name="l00146"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya9">00146</a>       <span class="keywordtype">void</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntrya9">setIsArray</a>(<span class="keywordtype">bool</span> isAnArray) { <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo3">arrayFlag</a> = isAnArray?MemoryTracer::IsArray:MemoryTracer::IsNotArray; }
00147       
<a name="l00148"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo0">00148</a>       <a class="code" href="namespacebase.html#a0">Byte</a> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo0">prefill</a>[Filling]; <span class="comment">// Filler for check integrity of list</span>
<a name="l00149"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo1">00149</a>       <span class="keywordtype">int</span> size;
<a name="l00150"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo2">00150</a>       <a class="code" href="namespacebase.html#a0">Byte</a>* address;
<a name="l00151"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo3">00151</a>       <span class="keywordtype">int</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo3">arrayFlag</a>;
<a name="l00152"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo4">00152</a>       <span class="keywordtype">char</span>* name;
<a name="l00153"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">00153</a>       <span class="keywordtype">int</span> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo5">magic</a>;
00154 
<a name="l00155"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo6">00155</a>       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo6">prev</a>;
<a name="l00156"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo7">00156</a>       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo7">next</a>;
00157 
<a name="l00158"></a><a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo8">00158</a>       <a class="code" href="namespacebase.html#a0">Byte</a> <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html#base_1_1MemoryTracer_1_1AllocEntryo8">postfill</a>[Filling]; <span class="comment">// Filler for check integrity of list</span>
00159     };
00160 
00161     
<a name="l00162"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html">00162</a>     <span class="keyword">class </span><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html">AllocList</a>
00163     {
00164     <span class="keyword">public</span>:
00165       <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista0">push_front</a>(<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* e);
00166       <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista1">push_back</a>(<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* e);
00167       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista2">pop_back</a>();
00168       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista3">pop_front</a>();
00169       <span class="keywordtype">void</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista4">remove</a>(<a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* e);
00170 
<a name="l00171"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista5">00171</a>       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista5">front</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp0">head</a>; }
<a name="l00172"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista6">00172</a>       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista6">back</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp1">tail</a>; }
<a name="l00173"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista7">00173</a>       <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista7">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp2">len</a>; }
00174 
00175       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocLista8">find</a>(<span class="keywordtype">void</span>* address, <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* from = 0) <span class="keyword">const</span>;
00176 
00177     <span class="keyword">protected</span>:
00178       <span class="comment">// NB: Because new/delete may be called before the global construction of </span>
00179       <span class="comment">//  static AllocList members of MemoryTracer, we rely on the following</span>
00180       <span class="comment">//  fields to have been initialized to 0 by the compiler!</span>
<a name="l00181"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp0">00181</a>       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp0">head</a>; <span class="comment">// front</span>
<a name="l00182"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp1">00182</a>       <a class="code" href="structbase_1_1MemoryTracer_1_1AllocEntry.html">AllocEntry</a>* <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp1">tail</a>; <span class="comment">// back</span>
<a name="l00183"></a><a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp2">00183</a>       <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html#base_1_1MemoryTracer_1_1AllocListp2">len</a>;
00184     };
00185 
<a name="l00186"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert6">00186</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert6">DList_Max</a> = 1000;
00187 
<a name="l00188"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert7">00188</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a0">Byte</a> prefill[<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert0">Filling</a>]; <span class="comment">// Filler for integrity check</span>
00189 
<a name="l00190"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert8">00190</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a0">Byte</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert8">initialized</a>;
<a name="l00191"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert9">00191</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert9">cleanedUp</a>;
<a name="l00192"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert10">00192</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert10">entry</a>;
<a name="l00193"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert11">00193</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert11">fullCheckCounter</a>;
<a name="l00194"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert12">00194</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a3">LInt</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert12">allocCount</a>;
<a name="l00195"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert13">00195</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a3">LInt</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert13">deallocCount</a>;
<a name="l00196"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert14">00196</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a3">LInt</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert14">checkCount</a>;
00197 
<a name="l00198"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert15">00198</a>     <span class="keyword">static</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html">AllocList</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert15">mlist</a>; <span class="comment">// the allocated memory list</span>
<a name="l00199"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert16">00199</a>     <span class="keyword">static</span> <a class="code" href="classbase_1_1MemoryTracer_1_1AllocList.html">AllocList</a> <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert16">dlist</a>; <span class="comment">// list of memory allocated and then deallocated (so we can catch double delete's)</span>
00200 
<a name="l00201"></a><a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert17">00201</a>     <span class="keyword">static</span> <a class="code" href="namespacebase.html#a0">Byte</a> postfill[<a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracert0">Filling</a>]; <span class="comment">// Filler for integrity check</span>
00202   };
00203 
00204 
00205   <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a132">stressTestAllocator</a>();
00206 
00207 
00208 } <span class="comment">// base</span>
00209 
00210 
00211 
00212 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00213 <span class="preprocessor"></span><span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a3">operator new</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc);
00214 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a4">operator new[]</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc);
00215 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a3">operator new</a>(size_t size, <span class="keyword">const</span> std::string&amp; name) <span class="keywordflow">throw</span> (std::bad_alloc);
00216 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a4">operator new[]</a>(size_t size, <span class="keyword">const</span> std::string&amp; name) <span class="keywordflow">throw</span> (std::bad_alloc);
00217 <span class="keywordtype">void</span> operator delete(<span class="keywordtype">void</span>* p) <span class="keywordflow">throw</span>();
00218 <span class="keywordtype">void</span> operator delete[](<span class="keywordtype">void</span>* p) <span class="keywordflow">throw</span>();
00219 
00220 <span class="comment">//#define NewObj new(std::string(__FILE__)+":"+base::intToString(__LINE__))</span>
00221 <span class="comment">//#define NewNamedObj(name) new(std::string(__FILE__)+":"+base::intToString(__LINE__)+":"+name)</span>
00222 <span class="preprocessor">#define NewObj new</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define NewNamedObj(name) new</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#define DeleteObj delete</span>
00225 <span class="preprocessor"></span>
00226 <span class="preprocessor">#else</span>
00227 <span class="preprocessor"></span>
<a name="l00228"></a><a class="code" href="MemoryTracer.html#a3">00228</a> <span class="keyword">inline</span> <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a3">operator new</a>(size_t size, <span class="keyword">const</span> std::string&amp; name) <span class="keywordflow">throw</span> (std::bad_alloc)
00229 { <a class="code" href="MemoryTracer.html#a3">return ::operator new</a>(size); }
<a name="l00230"></a><a class="code" href="MemoryTracer.html#a4">00230</a> <span class="keyword">inline</span> <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a4">operator new[]</a>(size_t size, <span class="keyword">const</span> std::string&amp; name) <span class="keywordflow">throw</span> (std::bad_alloc)
00231 { <a class="code" href="MemoryTracer.html#a4">return ::operator new[]</a>(size); }
00232 
<a name="l00233"></a><a class="code" href="MemoryTracer.html#a0">00233</a> <span class="preprocessor">#define NewObj new</span>
<a name="l00234"></a><a class="code" href="MemoryTracer.html#a1">00234</a> <span class="preprocessor"></span><span class="preprocessor">#define NewNamedObj(name) new</span>
<a name="l00235"></a><a class="code" href="MemoryTracer.html#a2">00235</a> <span class="preprocessor"></span><span class="preprocessor">#define DeleteObj delete</span>
00236 <span class="preprocessor"></span>
00237 <span class="preprocessor">#endif</span>
00238 <span class="preprocessor"></span>
00239 
00240 
00241 <span class="preprocessor">#endif</span>
00242 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:08 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
