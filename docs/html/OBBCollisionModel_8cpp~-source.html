<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>opensim/physics/OBBCollisionModel.cpp~ Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>opensim/physics/OBBCollisionModel.cpp~</h1><a href="OBBCollisionModel_8cpp~.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/****************************************************************************</font>
00002 <font class="comment">  Copyright (C)1996 David Jung &lt;djung@pobox.com&gt;</font>
00003 <font class="comment"></font>
00004 <font class="comment">  This program/file is free software; you can redistribute it and/or modify</font>
00005 <font class="comment">  it under the terms of the GNU General Public License as published by</font>
00006 <font class="comment">  the Free Software Foundation; either version 2 of the License, or</font>
00007 <font class="comment">  (at your option) any later version.</font>
00008 <font class="comment">  </font>
00009 <font class="comment">  This program is distributed in the hope that it will be useful,</font>
00010 <font class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00011 <font class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
00012 <font class="comment">  GNU General Public License for more details. (http://www.gnu.org)</font>
00013 <font class="comment">  </font>
00014 <font class="comment">  You should have received a copy of the GNU General Public License</font>
00015 <font class="comment">  along with this program; if not, write to the Free Software</font>
00016 <font class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</font>
00017 <font class="comment">  </font>
00018 <font class="comment">  $Id: OBBCollisionModel.cpp,v 1.1 2002/06/25 15:31:09 jungd Exp $</font>
00019 <font class="comment">  $Revision: 1.1 $</font>
00020 <font class="comment">  $Date: 2002/06/25 15:31:09 $</font>
00021 <font class="comment">  $Author: jungd $</font>
00022 <font class="comment"> </font>
00023 <font class="comment">****************************************************************************/</font>
00024 
00025 <font class="preprocessor">#include &lt;<a class="code" href="OBBCollisionModel.html">physics/OBBCollisionModel</a>&gt;</font>
00026 
00027 <font class="preprocessor">#include &lt;<a class="code" href="Box.html">physics/Box</a>&gt;</font>
00028 <font class="preprocessor">#include &lt;<a class="code" href="TriangleContainer.html">gfx/TriangleContainer</a>&gt;</font>
00029 <font class="preprocessor">#include &lt;<a class="code" href="TriangleIterator.html">gfx/TriangleIterator</a>&gt;</font>
00030 <font class="preprocessor">#include &lt;<a class="code" href="Triangle3.html">gfx/Triangle3</a>&gt;</font>
00031 <font class="preprocessor">#include &lt;<a class="code" href="Color4.html">gfx/Color4</a>&gt;</font>
00032 
00033 <font class="preprocessor">#include &lt;osg/Node&gt;</font>
00034 <font class="preprocessor">#include &lt;osg/Group&gt;</font>
00035 <font class="preprocessor">#include &lt;<a class="code" href="Transform.html">osg/Transform</a>&gt;</font>
00036 <font class="preprocessor">#include &lt;osg/StateSet&gt;</font>
00037 <font class="preprocessor">#include &lt;<a class="code" href="Material.html">osg/Material</a>&gt;</font>
00038 <font class="preprocessor">#include &lt;osg/Vec4&gt;</font>
00039 <font class="preprocessor">#include &lt;osg/PolygonMode&gt;</font>
00040 
00041 
00042 
00043 <font class="keyword">using</font> <a class="code" href="classphysics_1_1OBBCollisionModel.html">physics::OBBCollisionModel</a>;
00044 <font class="keyword">using</font> <a class="code" href="classphysics_1_1Box.html">physics::Box</a>;
00045 
00046 <font class="keyword">using</font> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>;
00047 <font class="keyword">using</font> <a class="code" href="classgfx_1_1Color4.html">gfx::Color4</a>;
00048 <font class="keyword">using</font> <a class="code" href="classgfx_1_1TriangleContainer.html">gfx::TriangleContainer</a>;
00049 <font class="keyword">using</font> <a class="code" href="classgfx_1_1TriangleIterator.html">gfx::TriangleIterator</a>;
00050 
00051 <font class="keyword">using</font> <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a>;
00052 <font class="keyword">using</font> base::transpose;
00053 <font class="keyword">using</font> base::cross;
00054 <font class="keyword">using</font> <a class="code" href="classbase_1_1array.html">base::array</a>;
00055 
00056 <font class="keyword">using</font> osg::Vec4;
00057 <font class="keyword">using</font> osg::StateSet;
00058 
00059 
00060 OBBCollisionModel::OBBCollisionModel(<font class="keyword">const</font> <a class="code" href="classgfx_1_1TriangleContainer.html">gfx::TriangleContainer</a>&amp; triangles)
00061   : b(*new base::array&lt;OBB&gt;()), tris(*new base::array&lt;Triangle3&gt;())
00062 {
00063   <font class="comment">// Copy all the triangles into an array (tris)</font>
00064   Int id=0;
00065   
00066   TriangleContainer::const_iterator t = triangles.begin();
00067   TriangleContainer::const_iterator end = triangles.end();
00068   <font class="keywordflow">while</font> (t != end) {
00069     tris.<a class="code" href="classbase_1_1array.html#a13">at</a>(id++) = (*t);
00070     ++t;
00071   }
00072   tris.<a class="code" href="classbase_1_1array.html#a31">trim</a>();
00073 
00074   <font class="keywordflow">if</font> (!tris.<a class="code" href="classbase_1_1array.html#a17">empty</a>()) {
00075     <a class="code" href="classphysics_1_1OBBCollisionModel.html#b0">buildHierarchy</a>(); <font class="comment">// Build the model</font>
00076   }
00077 
00078 }
00079 
00080 OBBCollisionModel::OBBCollisionModel(<font class="keyword">const</font> OBBCollisionModel&amp; cm)
00081   : b(*new base::array&lt;OBB&gt;(cm.b)),
00082     tris(*new base::array&lt;Triangle3&gt;(cm.tris))
00083 {
00084 }
00085 
00086 OBBCollisionModel::~OBBCollisionModel()<font class="keyword"></font>
00087 <font class="keyword"></font>{
00088   <font class="keyword">delete</font> &amp;tris;
00089   <font class="keyword">delete</font> &amp;b;
00090 }
00091 
00092 
00093 <font class="keywordtype">void</font> OBBCollisionModel::buildHierarchy()<font class="keyword"></font>
00094 <font class="keyword"></font>{
00095   array&lt;Moment&gt; moment(tris.<a class="code" href="classbase_1_1array.html#a14">size</a>());
00096   array&lt;OBB&gt;&amp; boxes(b);
00097   Int OBBsInited = 1; 
00098   boxes.resize(tris.<a class="code" href="classbase_1_1array.html#a14">size</a>()*2);
00099   
00100   <font class="comment">// Determine initial orientation, mean point, and splitting axis.</font>
00101   Moment  M;
00102   Matrix3 C;
00103   
00104   Moment::computeMoment(moment, tris, 0, tris.<a class="code" href="classbase_1_1array.html#a14">size</a>());
00105 
00106   M.clear();
00107   <font class="keywordflow">for</font>(Int i=0; i&lt;tris.<a class="code" href="classbase_1_1array.html#a14">size</a>(); i++) {
00108     M.accumulate(moment[i]);
00109   }
00110 
00111   b[0].pT = M.meanFromAccum();
00112   C = M.covariance();
00113   
00114   <a class="code" href="classphysics_1_1OBBCollisionModel.html#e0">eigenAndSort1</a>(b[0].pR, C);
00115   
00116   <font class="comment">// create the index list</font>
00117   Int* t = <font class="keyword">new</font> Int[tris.<a class="code" href="classbase_1_1array.html#a14">size</a>()];
00118   <font class="keywordflow">for</font>(Int i=0; i&lt;tris.<a class="code" href="classbase_1_1array.html#a14">size</a>(); i++) t[i]=i;
00119   
00120   <font class="comment">// do the build</font>
00121   OBBsInited = b[0].splitRecurse(tris,moment,boxes,OBBsInited,t,0,tris.<a class="code" href="classbase_1_1array.html#a14">size</a>());
00122   
00123   <font class="keyword">delete</font>[] t;
00124 }
00125 
00126 
00127 Int OBBCollisionModel::eigenAndSort1(Matrix3&amp; evecs, <font class="keyword">const</font> Matrix3&amp; cov, Int maxIterations)<font class="keyword"></font>
00128 <font class="keyword"></font>{
00129   Vector3 evals;
00130   
00131   Int n = cov.eigenJacobi(evecs, evals, maxIterations);
00132 
00133   <font class="comment">// not a full sort -- just makes column 1 the largest</font>
00134   <font class="keywordflow">if</font> (evals.z &gt; evals.x) {
00135     <font class="keywordflow">if</font> (evals.z &gt; evals.y) {
00136       <font class="comment">// 3 is largest, swap with column 1</font>
00137       evecs.swapColumns(3,1);
00138     }
00139     <font class="keywordflow">else</font> {
00140       <font class="comment">// 2 is largest, swap with column 1</font>
00141       evecs.swapColumns(2,1);
00142     }
00143   }
00144   <font class="keywordflow">else</font> {
00145     <font class="keywordflow">if</font> (evals.x &gt; evals.y) {
00146       <font class="comment">// 1 is largest, do nothing</font>
00147     }
00148     <font class="keywordflow">else</font> {
00149       <font class="comment">// 2 is largest</font>
00150       evecs.swapColumns(1,2);
00151     }
00152   }
00153   
00154   <font class="comment">// we are returning the number of iterations eigenJacobi took.</font>
00155   <font class="comment">// too many iterations means our chosen orientation is bad.</font>
00156   <font class="keywordflow">return</font> n; 
00157 }
00158 
00159 
00160 
00161 
00162 
00163 
00164 
00165 
00166 
00167 <font class="comment">// OBB implementation</font>
00168 
00169 <font class="keywordtype">void</font> OBBCollisionModel::OBB::reaccumMoments(Moment&amp; A, <a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; moment,
00170                                             Int t[], Int f, Int n)<font class="keyword"></font>
00171 <font class="keyword"></font>{
00172   A.clear();
00173   <font class="keywordflow">for</font>(Int i=0;i&lt;n;i++) 
00174     A.accumulate(moment[t[f+i]]);
00175 }
00176 
00177 
00178 Int OBBCollisionModel::OBB::splitRecurse(<a class="code" href="classbase_1_1array.html">base::array&lt;gfx::Triangle3&gt;</a>&amp; tri, 
00179                                          <a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; moment, 
00180                                          <a class="code" href="classbase_1_1array.html">base::array&lt;OBB&gt;</a>&amp; boxes,
00181                                          Int OBBsInited, Int t[], Int f, Int n)<font class="keyword"></font>
00182 <font class="keyword"></font>{
00183   <font class="comment">// The orientation for the parent box is already assigned to this-&gt;pR.</font>
00184   <font class="comment">// The axis along which to split will be column 0 of this-&gt;pR.</font>
00185   <font class="comment">// The mean point is passed in on this-&gt;pT.</font>
00186   
00187   <font class="comment">// When this routine completes, the position and orientation in model</font>
00188   <font class="comment">// space will be established, as well as its dimensions.  Child boxes</font>
00189   <font class="comment">// will be constructed and placed in the parent's CS.</font>
00190   
00191   <font class="keywordflow">if</font> (n == 1)
00192     <font class="keywordflow">return</font> splitRecurse(tri,moment,boxes,OBBsInited,t,f);
00193   
00194   
00195   <font class="comment">// walk along the tris for the box, and do the following:</font>
00196   <font class="comment">//   1. collect the max and min of the vertices along the axes of &lt;or&gt;.</font>
00197   <font class="comment">//   2. decide which group the triangle goes in, performing appropriate swap.</font>
00198   <font class="comment">//   3. accumulate the mean point and covariance data for that triangle.</font>
00199   
00200   Moment M1, M2;
00201   Matrix3 C;
00202   Vector3 c;
00203   Vector3 minval, maxval;
00204   
00205   Int in;
00206   Int i;
00207   Real axdmp;
00208   Int n1 = 0;  <font class="comment">// The number of tris in group 1.  </font>
00209   <font class="comment">// Group 2 will have n - n1 tris.</font>
00210         
00211   <font class="comment">// project approximate mean point onto splitting axis, and get coord.</font>
00212   axdmp = (pR.e(1,1) * pT.x + pR.e(2,1) * pT.y + pR.e(3,1) * pT.z);
00213   
00214   M1.clear();
00215   M2.clear();
00216 
00217   Matrix3 pRT = transpose(pR);
00218   
00219   c = pRT * tri[t[f]].p1();
00220   
00221   minval = c;
00222   maxval = c;
00223 
00224   <font class="keywordflow">for</font>(i=0; i&lt;n; i++) {
00225     in = t[f+i];
00226     Triangle3&amp; ptr(tri[in]);
00227     
00228     c = pRT*ptr.p1();
00229     minmax(minval, maxval, c);
00230     
00231     c = pRT*ptr.p2();
00232     minmax(minval, maxval, c);
00233     
00234     c = pRT*ptr.p3();
00235     minmax(minval, maxval, c);
00236     
00237     <font class="comment">// grab the mean point of the in'th triangle, project</font>
00238     <font class="comment">// it onto the splitting axis (1st column of pR) and</font>
00239     <font class="comment">// see where it lies with respect to axdmp.</font>
00240     c = moment[in].meanFromMoment();
00241     
00242     <font class="keywordflow">if</font> ( (((pR.e(1,1)*c.x + pR.e(2,1)*c.y + pR.e(3,1)*c.z) &lt; axdmp)
00243           &amp;&amp; (n!=2)) || ((n==2) &amp;&amp; (i==0)) ) {
00244       <font class="comment">// accumulate first and second order moments for group 1</font>
00245       M1.accumulate(moment[in]);
00246       
00247       <font class="comment">// put it in group 1 by swapping t[i] with t[n1]</font>
00248       Int temp = t[f+i];
00249       t[f+i] = t[f+n1];
00250       t[f+n1] = temp;
00251       n1++;
00252     }
00253     <font class="keywordflow">else</font> {
00254       <font class="comment">// accumulate first and second order moments for group 2</font>
00255       M2.accumulate(moment[in]);
00256       
00257       <font class="comment">// leave it in group 2</font>
00258       <font class="comment">// do nothing...it happens by default</font>
00259     }
00260   }
00261   
00262   <font class="comment">// done using this.pT as a mean point.</font>
00263   
00264   <font class="comment">// error check!</font>
00265   <font class="keywordflow">if</font> ((n1 == 0) || (n1 == n)) {
00266     <font class="comment">// our partitioning has failed: all the triangles fell into just</font>
00267     <font class="comment">// one of the groups.  So, we arbitrarily partition them into</font>
00268     <font class="comment">// equal parts, and proceed.</font>
00269     <font class="comment">//Debugln("Warning: Triangle partitioning failed. Partitioning equally.");    </font>
00270     n1 = n/2;
00271     
00272     <font class="comment">// now recompute accumulated stuff</font>
00273     reaccumMoments(M1, moment, t, f, n1);
00274     reaccumMoments(M2, moment, t, f + n1, n - n1);
00275   }
00276   
00277   <font class="comment">// With the max and min data, determine the center point and dimensions</font>
00278   <font class="comment">// of the parent box.</font>
00279   
00280   c = (minval+maxval)/2.0;
00281   
00282   pT = pR*c; <font class="comment">// equiv of above?? !!!</font>
00283   d = (maxval-minval)/2.0;
00284   
00285   <font class="comment">// allocate new boxes</font>
00286   P = &amp;boxes[OBBsInited++];
00287   N = &amp;boxes[OBBsInited++];
00288         
00289   <font class="comment">// Compute the orienations for the child boxes (eigenvectors of</font>
00290   <font class="comment">// covariance matrix).  Select the direction of maximum spread to be</font>
00291   <font class="comment">// the split axis for each child.</font>
00292   
00293   Matrix3 tR;
00294   
00295   <font class="comment">// do the P child</font>
00296   <font class="keywordflow">if</font> (n1 &gt; 1) {
00297     P-&gt;pT = M1.meanFromAccum();
00298     C = M1.covariance();
00299     
00300     <font class="keywordflow">if</font> (OBBCollisionModel::eigenAndSort1(tR, C, 30) &gt;= 30) {
00301       <font class="comment">// unable to find an orientation.  We'll just pick identity.</font>
00302       tR.setIdentity();
00303     }
00304     
00305     P-&gt;pR = tR;
00306     OBBsInited = P-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f, n1);
00307   }
00308   <font class="keywordflow">else</font> {
00309     OBBsInited = P-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f);
00310   }
00311   C = P-&gt;pR; P-&gt;pR = transpose(pR)*C;  <font class="comment">// and F1 </font>
00312   c = P-&gt;pT - pT; P-&gt;pT = transpose(pR)*c;
00313   
00314   <font class="comment">// do the N child</font>
00315   <font class="keywordflow">if</font> ((n-n1) &gt; 1) {
00316     N-&gt;pT = M2.meanFromAccum();
00317     C = M2.covariance();
00318     
00319     <font class="keywordflow">if</font> (OBBCollisionModel::eigenAndSort1(tR, C) &gt; 30) {
00320       <font class="comment">// unable to find an orientation.  We'll just pick identity.</font>
00321       tR.setIdentity();
00322     }
00323     
00324     N-&gt;pR = tR;
00325     OBBsInited = N-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f + n1, n - n1);
00326   }
00327   <font class="keywordflow">else</font> {
00328     OBBsInited = N-&gt;splitRecurse(tri, moment, boxes, OBBsInited, t, f+n1);
00329   }
00330   C = N-&gt;pR; N-&gt;pR = transpose(pR)*C;
00331   c = N-&gt;pT-pT; N-&gt;pT = transpose(pR)*c;
00332   
00333   <font class="keywordflow">return</font> OBBsInited;
00334 }
00335 
00336 
00337 <font class="comment">// specialized for leaf nodes</font>
00338 Int OBBCollisionModel::OBB::splitRecurse(<a class="code" href="classbase_1_1array.html">base::array&lt;gfx::Triangle3&gt;</a>&amp; tri, 
00339                                          <a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; moment, 
00340                                          <a class="code" href="classbase_1_1array.html">base::array&lt;OBB&gt;</a>&amp; boxes,
00341                                          Int OBBsInited, Int t[], Int f)<font class="keyword"></font>
00342 <font class="keyword"></font>{
00343   <font class="comment">// For a single triangle, orientation is easily determined.</font>
00344   <font class="comment">// The major axis is parallel to the longest edge.</font>
00345   <font class="comment">// The minor axis is normal to the triangle.</font>
00346   <font class="comment">// The in-between axis is determine by these two.</font>
00347   
00348   <font class="comment">// this.pR, this.d, and this.pT are set herein.</font>
00349   
00350   P = N = 0;
00351   Triangle3&amp; ptr(tri[t[f]]);
00352   
00353   <font class="comment">// Find the major axis: parallel to the longest edge.</font>
00354   Vector3 u12, u23, u31;
00355   
00356   <font class="comment">// First compute the squared-lengths of each edge</font>
00357   u12 = ptr.p1()-ptr.p2();
00358   Real d12 = u12.norm();
00359   u23 = ptr.p2()-ptr.p3();  
00360   Real d23 = u23.norm();
00361   u31 = ptr.p3()-ptr.p1();  
00362   Real d31 = u31.norm();
00363   
00364   <font class="comment">// Find the edge of longest squared-length, normalize it to</font>
00365   <font class="comment">// unit length, and put result into a0.</font>
00366   Vector3 a0;
00367   <font class="keywordflow">if</font> (d12 &gt; d23) {
00368     <font class="keywordflow">if</font> (d12 &gt; d31) 
00369       a0 = u12 / <a class="code" href="namespace__base.html#a60">base::sqrt</a>(d12);
00370     <font class="keywordflow">else</font> 
00371       a0 = u31 / <a class="code" href="namespace__base.html#a60">base::sqrt</a>(d31);
00372   }
00373   <font class="keywordflow">else</font> {
00374     <font class="keywordflow">if</font> (d23 &gt; d31) 
00375       a0 = u23 / <a class="code" href="namespace__base.html#a60">base::sqrt</a>(d23);
00376     <font class="keywordflow">else</font> 
00377       a0 = u31 / <a class="code" href="namespace__base.html#a60">base::sqrt</a>(d31);
00378   }
00379   
00380   <font class="comment">// Now compute unit normal to triangle, and put into a2.</font>
00381   Vector3 a2;
00382   a2 = cross(u12,u23);
00383   a2.normalize();
00384   
00385   <font class="comment">// a1 is a2 cross a0.</font>
00386   Vector3 a1;
00387   a1 = cross(a2,a0);
00388   
00389   <font class="comment">// Now make the columns of this.pR the vectors a0, a1, and a2.</font>
00390   pR.e(1,1) = a0.x;  pR.e(1,2) = a1.x;  pR.e(1,3) = a2.x;
00391   pR.e(2,1) = a0.y;  pR.e(2,2) = a1.y;  pR.e(2,3) = a2.y;
00392   pR.e(3,1) = a0.z;  pR.e(3,2) = a1.z;  pR.e(3,3) = a2.z;
00393   
00394   <font class="comment">// Now compute the maximum and minimum extents of each vertex </font>
00395   <font class="comment">// along each of the box axes.  From this we will compute the </font>
00396   <font class="comment">// box center and box dimensions.</font>
00397   Vector3 minval, maxval;
00398   Vector3 c;
00399   
00400   c = transpose(pR)*ptr.p1();
00401   minval=c; maxval=c;
00402   
00403   c = transpose(pR)*ptr.p2();
00404   minmax(minval, maxval, c);
00405   
00406   c = transpose(pR)*ptr.p3();
00407   minmax(minval, maxval, c);
00408   
00409   <font class="comment">// With the max and min data, determine the center point and dimensions</font>
00410   <font class="comment">// of the box</font>
00411   c = (minval+maxval)/2.0;
00412   
00413   pT = pR*c; <font class="comment">// !!! check equiv of above        </font>
00414   d = (maxval-minval)/2.0;
00415   
00416   <font class="comment">// Assign the one triangle to this box</font>
00417   tr = ptr;
00418   
00419   <font class="keywordflow">return</font> OBBsInited;
00420 }
00421 
00422 
00423 <font class="keywordtype">void</font> OBBCollisionModel::OBB::minmax(gfx::Vector3&amp; min, gfx::Vector3&amp; max, 
00424                                     <font class="keyword">const</font> gfx::Vector3&amp; v)<font class="keyword"></font>
00425 <font class="keyword"></font>{
00426   <font class="keywordflow">if</font> (v.x &lt; min.x) 
00427     min.x = v.x;
00428   <font class="keywordflow">else</font>
00429     <font class="keywordflow">if</font> (v.x &gt; max.x)
00430       max.x = v.x;
00431   <font class="keywordflow">if</font> (v.y &lt; min.y) 
00432     min.y = v.y;
00433   <font class="keywordflow">else</font>
00434     <font class="keywordflow">if</font> (v.y &gt; max.y)
00435       max.y = v.y;
00436   <font class="keywordflow">if</font> (v.z &lt; min.z) 
00437     min.z = v.z;
00438   <font class="keywordflow">else</font>
00439     <font class="keywordflow">if</font> (v.z &gt; max.z)
00440       max.z = v.z;
00441 }
00442 
00443 
00444 
00445 <font class="comment">// Moment implementation</font>
00446 
00447 <font class="keywordtype">void</font> OBBCollisionModel::Moment::clear()<font class="keyword"></font>
00448 <font class="keyword"></font>{
00449   A = 0;
00450   m.setZero();
00451   s.setZero();
00452 }
00453 
00454 
00455 <font class="keywordtype">void</font> OBBCollisionModel::Moment::accumulate(<font class="keyword">const</font> Moment&amp; b)<font class="keyword"></font>
00456 <font class="keyword"></font>{
00457   m += b.m*b.A;
00458   s += b.s;
00459   A += b.A;
00460 }
00461 
00462 
00463 <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a> OBBCollisionModel::Moment::covariance()<font class="keyword"> const </font>
00464 <font class="keyword"></font>{
00465   <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a> C = s;
00466   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(1,1) -= m.x*m.x/A;
00467   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(1,2) -= m.x*m.y/A;
00468   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(1,3) -= m.x*m.z/A;
00469   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(2,1) -= m.y*m.x/A;
00470   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(2,2) -= m.y*m.y/A;
00471   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(2,3) -= m.y*m.z/A;
00472   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(3,1) -= m.z*m.x/A;
00473   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(3,2) -= m.z*m.y/A;
00474   C.<a class="code" href="classbase_1_1Matrix3.html#a8">e</a>(3,3) -= m.z*m.z/A;
00475   <font class="keywordflow">return</font> C;
00476 }
00477 
00478 
00479 <font class="keywordtype">void</font> OBBCollisionModel::Moment::computeMoment(Moment&amp; M, <font class="keyword">const</font> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; p,
00480                                               <font class="keyword">const</font> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; q, <font class="keyword">const</font> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>&amp; r)<font class="keyword"></font>
00481 <font class="keyword"></font>{
00482   Vector3 u,v,w;
00483   
00484   <font class="comment">// compute the area of the triangle</font>
00485   u = q-p;
00486   v = r-p;
00487   w = cross(u,v);
00488   M.A = 0.5*w.length();
00489   
00490   <font class="keywordflow">if</font> (M.A == 0.0) {
00491     <font class="comment">// This triangle has zero area.  The second order components</font>
00492     <font class="comment">// would be eliminated with the usual formula, so, for the </font>
00493     <font class="comment">// sake of robustness we use an alternative form.  These are the </font>
00494     <font class="comment">// centroid and second-order components of the triangle's vertices.</font>
00495     
00496     <font class="comment">// centroid</font>
00497     M.m = (p+q+r)/3.0;
00498     
00499     <font class="comment">// second-order components</font>
00500     M.s.e(1,1) = (p.x*p.x + q.x*q.x + r.x*r.x);
00501     M.s.e(1,2) = (p.x*p.y + q.x*q.y + r.x*r.y);
00502     M.s.e(1,3) = (p.x*p.z + q.x*q.z + r.x*r.z);
00503     M.s.e(2,2) = (p.y*p.y + q.y*q.y + r.y*r.y);
00504     M.s.e(2,3) = (p.y*p.z + q.y*q.z + r.y*r.z);
00505     M.s.e(3,3) = (p.z*p.z + q.z*q.z + r.z*r.z);      
00506     M.s.e(3,2) = M.s.e(2,3);
00507     M.s.e(2,1) = M.s.e(1,2);
00508     M.s.e(3,1) = M.s.e(1,3);
00509     
00510     <font class="keywordflow">return</font>;
00511   }
00512   
00513   <font class="comment">// get the centroid</font>
00514   M.m = (p+q+r)/3.0;
00515   
00516   <font class="comment">// get the second order components -- note the weighting by the area</font>
00517   M.s.e(1,1) = M.A*(9.0*M.m.x*M.m.x+p.x*p.x+q.x*q.x+r.x*r.x)/12.0;
00518   M.s.e(1,2) = M.A*(9.0*M.m.x*M.m.y+p.x*p.y+q.x*q.y+r.x*r.y)/12.0;
00519   M.s.e(1,3) = M.A*(9.0*M.m.x*M.m.z+p.x*p.z+q.x*q.z+r.x*r.z)/12.0;
00520   M.s.e(2,2) = M.A*(9.0*M.m.y*M.m.y+p.y*p.y+q.y*q.y+r.y*r.y)/12.0;
00521   M.s.e(2,3) = M.A*(9.0*M.m.y*M.m.z+p.y*p.z+q.y*q.z+r.y*r.z)/12.0;
00522   M.s.e(3,3) = M.A*(9.0*M.m.z*M.m.z+p.z*p.z+q.z*q.z+r.z*r.z)/12.0;
00523   M.s.e(3,2) = M.s.e(2,3);
00524   M.s.e(2,1) = M.s.e(1,2);
00525   M.s.e(3,1) = M.s.e(1,3);
00526 }
00527 
00528 
00529 <font class="keywordtype">void</font> OBBCollisionModel::Moment::computeMoment(<a class="code" href="classbase_1_1array.html">base::array&lt;Moment&gt;</a>&amp; M,
00530                                               <a class="code" href="classbase_1_1array.html">base::array&lt;gfx::Triangle3&gt;</a>&amp; tris,
00531                                               Int firstTri, Int numTris)<font class="keyword"></font>
00532 <font class="keyword"></font>{
00533   <font class="comment">// check implementation. (tri *tris, int num_tris)</font>
00534   
00535   <font class="comment">// first collect all the moments, and obtain the area of the </font>
00536   <font class="comment">// smallest nonzero area triangle.</font>
00537   Real Amin = 0.0;
00538   <font class="keywordtype">bool</font> zero=<font class="keyword">false</font>;
00539 
00540   Triangle3 tri;
00541   Moment m;
00542   <font class="keywordflow">for</font>(Int i=firstTri; i&lt;firstTri+numTris; i++) {
00543     Moment&amp; m(M[i]);
00544     tri = tris[i];
00545     computeMoment(m, tri.p1(), tri.p2(), tri.p3());
00546 
00547     <font class="keywordflow">if</font> (m.A == 0.0)
00548       zero=<font class="keyword">true</font>;
00549     <font class="keywordflow">else</font> {
00550       <font class="keywordflow">if</font> (Amin == 0.0) 
00551         Amin = m.A;
00552       <font class="keywordflow">else</font> 
00553         <font class="keywordflow">if</font> (m.A &lt; Amin)
00554           Amin = m.A;
00555     }
00556     
00557   }
00558   
00559   <font class="keywordflow">if</font> (zero) {
00560     <a class="code" href="base.html#a3">Logln</a>(<font class="stringliteral">"Warning: Some triangles have zero area."</font>);
00561 
00562     <font class="comment">// if there are any zero area triangles, go back and set their area</font>
00563     <font class="comment">// if ALL the triangles have zero area, then set the area thingy</font>
00564     <font class="comment">// to some arbitrary value.</font>
00565     <font class="keywordflow">if</font> (Amin == 0.0) Amin = 1.0;
00566     
00567     <font class="keywordflow">for</font>(Int i=firstTri; i&lt;firstTri+numTris; i++) {
00568       Moment&amp; m(M[i]);
00569       <font class="keywordflow">if</font> ( m.A == 0.0) 
00570         m.A = Amin;
00571     }
00572   }
00573 }
00574 
00575 
00576 
00577 osg::Node* OBBCollisionModel::createOSGVisual(Visual::Attributes visualAttributes)<font class="keyword"> const</font>
00578 <font class="keyword"></font>{
00579   <font class="keywordflow">if</font> (!(visualAttributes &amp; ShowCollisionModel)
00580       || tris.<a class="code" href="classbase_1_1array.html#a17">empty</a>() ) 
00581     <font class="keywordflow">return</font> <font class="keyword">new</font> osg::Node();
00582   
00583   osg::Node* node = <a class="code" href="classphysics_1_1OBBCollisionModel.html#b1">createOBBVisualRecurse</a>(b[0], 0);
00584   node-&gt;setName(<font class="stringliteral">"debug"</font>);
00585 
00586   <font class="comment">// Set state to be transparent, random colour</font>
00587   StateSet* state = <font class="keyword">new</font> osg::StateSet();
00588   osg::Material* mat = <font class="keyword">new</font> osg::Material();
00589   Vec4 col( base::random(), <a class="code" href="namespace__base.html#a64">base::random</a>(), <a class="code" href="namespace__base.html#a64">base::random</a>(), 1.0);
00590   mat-&gt;setEmission( osg::Material::FRONT_AND_BACK, Vec4(0,0,0,0) );
00591   mat-&gt;setAmbient( osg::Material::FRONT_AND_BACK, col );
00592   mat-&gt;setDiffuse( osg::Material::FRONT_AND_BACK, col );
00593   mat-&gt;setSpecular( osg::Material::FRONT_AND_BACK, Vec4(1,1,1,0) );
00594   mat-&gt;setShininess( osg::Material::FRONT_AND_BACK, 0.3);
00595   state-&gt;setAttribute( mat );
00596   state-&gt;setMode(GL_CULL_FACE,osg::StateAttribute::OFF);
00597 
00598   osg::PolygonMode* polyMode = <font class="keyword">new</font> osg::PolygonMode;
00599   polyMode-&gt;setMode( osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE );
00600   state-&gt;setAttributeAndModes(polyMode,osg::StateAttribute::ON);
00601 
00602   node-&gt;setStateSet(state);
00603   
00604   <font class="keywordflow">return</font> node;
00605 }
00606 
00607 osg::Node* OBBCollisionModel::createOBBVisualRecurse(OBB&amp; obb, Int level)<font class="keyword"> const</font>
00608 <font class="keyword"></font>{
00609   <font class="keyword">const</font> Real epsOffset = 0.01;
00610 
00611   osg::Transform* tn = <font class="keyword">new</font> osg::Transform();
00612   tn-&gt;setName(<font class="stringliteral">"OBB"</font>);
00613   <font class="comment">//  tn-&gt;setType(osg::Transform::STATIC); // is there an equiv??? !!!</font>
00614   Matrix4 m(obb.pR);
00615   m.setTranslationComponent(obb.pT);
00616   tn-&gt;setMatrix(m);
00617   
00618   <font class="keywordflow">if</font> (!onlyOneLevel || (onlyLevel==level)) {
00619     ref&lt;Box&gt; box(NewObj Box(2*obb.d.x+epsOffset,2*obb.d.y+epsOffset,2*obb.d.z+epsOffset));
00620     <a class="code" href="base~.html#a8">Debugln</a>(<font class="stringliteral">"box leaf "</font> &lt;&lt; level);
00621     StateSet* state = <font class="keyword">new</font> osg::StateSet();
00622     osg::Material* mat = <font class="keyword">new</font> osg::Material();
00623     Vec4 col( base::random(), <a class="code" href="namespace__base.html#a64">base::random</a>(), <a class="code" href="namespace__base.html#a64">base::random</a>(), 1.0);
00624     mat-&gt;setAmbient( osg::Material::FRONT_AND_BACK, col );
00625     mat-&gt;setDiffuse( osg::Material::FRONT_AND_BACK, col );
00626     state-&gt;setAttribute( mat );
00627 
00628     osg::PolygonMode* polyMode = <font class="keyword">new</font> osg::PolygonMode;
00629     polyMode-&gt;setMode( osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE );
00630     state-&gt;setAttributeAndModes(polyMode,osg::StateAttribute::ON);
00631 
00632     osg::Node* boxNode = box-&gt;createOSGVisual();
00633     boxNode-&gt;setStateSet(state);
00634     tn-&gt;addChild(boxNode);
00635   }
00636   
00637   <font class="keywordflow">if</font> (level &lt; maxLevels) {
00638     <font class="keywordflow">if</font> (obb.N != 0) {
00639       tn-&gt;addChild( <a class="code" href="classphysics_1_1OBBCollisionModel.html#b1">createOBBVisualRecurse</a>(*obb.N, level+1) );
00640     }
00641     <font class="keywordflow">if</font> (obb.P != 0) {
00642       tn-&gt;addChild( <a class="code" href="classphysics_1_1OBBCollisionModel.html#b1">createOBBVisualRecurse</a>(*obb.P, level+1) );
00643     }
00644   }
00645   
00646   <font class="keywordflow">return</font> tn;
00647 }
</pre></div><hr><address><small>Generated at Wed Aug 7 10:30:31 2002 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
