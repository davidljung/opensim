<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: robot/control/ControllableAdaptor.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>robot/control/ControllableAdaptor.cpp</h1><a href="ControllableAdaptor_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: ControllableAdaptor.cpp 1037 2004-02-11 20:50:18Z jungd $</span>
00019 <span class="comment">  $Revision: 1.6 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:50:18 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="ControllableAdaptor.html">robot/control/ControllableAdaptor</a>&gt;</span>
00026 
00027 <span class="keyword">using</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html">robot::control::ControllableAdaptor</a>;
00028 <span class="keyword">using</span> <a class="code" href="classrobot_1_1ControlInterface.html">robot::ControlInterface</a>;
00029 
00030 
00031 ControllableAdaptor::ControllableAdaptor(AdaptorType type, ref&lt;Controllable&gt; controllable, 
00032                                          <span class="keyword">const</span> String&amp; interfaceName, <span class="keyword">const</span> String&amp; adaptedInterfaceName,
00033                                          <span class="keyword">const</span> String&amp; adaptedInterfaceType)
00034   : type(type), rangesSet(false), stridesSet(false), controllable(controllable), 
00035     newInterfaceName(adaptedInterfaceName), newInterfaceType(adaptedInterfaceType)
00036 {
00037   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a> = controllable-&gt;getControlInterface(interfaceName);
00038   <span class="keywordflow">if</span> (<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp12">newInterfaceName</a>==<span class="stringliteral">""</span>) <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp12">newInterfaceName</a>=<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;getName();
00039   <span class="keywordflow">if</span> (<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp13">newInterfaceType</a>==<span class="stringliteral">""</span>) <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp13">newInterfaceType</a>=<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;getType();
00040   <span class="comment">// create an instance of the ControlInterface.  By storing the ref and passing a ref to ourself</span>
00041   <span class="comment">//  we create a cyclic reference - which we break in onUnreference() when appropriate</span>
00042   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a> = ref&lt;AdaptorControlInterface&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorn0">AdaptorControlInterface</a>(ref&lt;ControllableAdaptor&gt;(<span class="keyword">this</span>)));
00043   <a class="code" href="classbase_1_1Referenced.html#base_1_1Worlda12">enableOnUnreferenceCall</a>(<span class="keyword">true</span>);
00044 
00045   <span class="keywordflow">if</span> (type == <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw0">PassThrough</a>) {
00046     <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;inputs.resize(<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;inputSize());
00047     <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;outputsSize = <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;outputSize();
00048   }
00049 }
00050 
00051 
00052 ControllableAdaptor::ControllableAdaptor(<span class="keyword">const</span> ControllableAdaptor&amp; c)
00053   : type(c.type), rangesSet(c.rangesSet), 
00054     inputStart(c.inputStart), outputStart(c.outputStart),
00055     inputEnd(c.inputEnd), outputEnd(c.outputEnd),
00056     stridesSet(c.stridesSet), inputStride(c.inputStride), outputStride(c.outputStride),
00057     controllable(c.controllable), adaptedInterface(c.adaptedInterface), adaptorInterface(c.adaptorInterface),
00058     newInterfaceName(c.newInterfaceName)
00059 {
00060   <span class="comment">// NB: this shares the adaptorInterface, so if this class is ever modified to be mutable after</span>
00061   <span class="comment">//  construction, the adaptorInterface will been a NewObj</span>
00062 }
00063 
00064 
00065 <span class="keywordtype">void</span> ControllableAdaptor::onUnreference()<span class="keyword"> const</span>
00066 <span class="keyword"></span>{
00067   <span class="keywordflow">if</span> ((<a class="code" href="classbase_1_1Referenced.html#base_1_1Worlda11">referenceCount</a>()==1) &amp;&amp; (<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;referenceCount()==1)) {
00068     <span class="comment">// if the only references are to each other, then break the cyclic link</span>
00069     <a class="code" href="namespacebase.html#a162">Release</a>(adaptorInterface);
00070   }
00071 }
00072 
00073 
00074 
00075 
00076 <span class="keywordtype">void</span> ControllableAdaptor::setRanges(Int inputStart, Int outputStart, SInt inputEnd, SInt outputEnd)
00077 {
00078   <span class="keywordflow">if</span> ((inputStart &gt;= <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;inputSize()) || (outputStart &gt;= <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;outputSize()))
00079     <span class="keywordflow">throw</span> std::out_of_range(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"inputStart or outputStart out of range"</span>));
00080 
00081   this-&gt;inputStart = inputStart;
00082   this-&gt;outputStart = outputStart;
00083   this-&gt;inputEnd = inputEnd;
00084   this-&gt;outputEnd = outputEnd;
00085   <span class="keywordflow">if</span> (inputEnd == <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw5robot_1_1control_1_1ControllableAdaptorw3">End</a>)
00086     this-&gt;inputEnd = <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;inputSize()-1;
00087   <span class="keywordflow">if</span> (outputEnd == <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw5robot_1_1control_1_1ControllableAdaptorw3">End</a>)
00088     this-&gt;outputEnd = <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;inputSize()-1;
00089   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp1">rangesSet</a> = <span class="keyword">true</span>;
00090   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;inputs.resize(this-&gt;inputEnd-inputStart+1);
00091   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;outputsSize = this-&gt;outputEnd-outputStart+1;
00092 }
00093 
00094 <span class="keywordtype">void</span> ControllableAdaptor::setStrides(Int inputStart, Int outputStart, Int inputStride, Int outputStride)
00095 {
00096   this-&gt;inputStart = inputStart;
00097   this-&gt;outputStart = outputStart;
00098   this-&gt;inputStride = inputStride;
00099   this-&gt;outputStride = outputStride;
00100   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp6">stridesSet</a> = <span class="keyword">true</span>;
00101   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;inputs.resize( (<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;inputSize()-inputStart)/inputStride );
00102   <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp11">adaptorInterface</a>-&gt;outputsSize = (<a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;outputSize()-outputStart)/outputStride;
00103 }
00104 
00105 
00106 
00107 
00108 <span class="keywordtype">void</span> ControllableAdaptor::setControlInterface(ref&lt;ControlInterface&gt; controlInterface)
00109 {
00110   <span class="comment">// ignore (constructor uses interfaceName of Controllable)</span>
00111 }
00112 
00113 <span class="keywordtype">bool</span> ControllableAdaptor::iterate(<span class="keyword">const</span> <a class="code" href="classbase_1_1Time.html">base::Time</a>&amp; time)
00114 {
00115   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00116 }
00117 
00118 
00119 ref&lt;ControlInterface&gt; ControllableAdaptor::getControlInterface(String interfaceName) <span class="keywordflow">throw</span>(std::invalid_argument)
00120 {
00121   <span class="keywordflow">if</span> ( ((type==<a class="code" href="namespacebase.html#a30">Range</a>)&amp;&amp;!rangesSet) || ((type==Stride)&amp;&amp;!stridesSet))
00122     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"unknown interface "</span>)+interfaceName+<span class="stringliteral">" (adaptor parameters not set)"</span>));
00123 
00124   <span class="keywordflow">if</span> ((interfaceName != <span class="stringliteral">""</span>) &amp;&amp; (interfaceName != adaptorInterface-&gt;getName()))
00125     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"unknown interface "</span>)+interfaceName));
00126 
00127   <span class="keywordflow">return</span> adaptorInterface;
00128 }
00129 
00130 
00131 
00132 <span class="keyword">inline</span> <a class="code" href="namespacebase.html#a2">Int</a> ControllableAdaptor::adaptInputIndex(Int i)<span class="keyword"> const</span>
00133 <span class="keyword"></span>{
00134   <a class="code" href="namespacebase.html#a2">Int</a> ai;
00135   <span class="keywordflow">switch</span> (type) {
00136   <span class="keywordflow">case</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw0">PassThrough</a>: ai=i; <span class="keywordflow">break</span>;
00137   <span class="keywordflow">case</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw1">Range</a>: ai = i + inputStart; <span class="keywordflow">break</span>;
00138   <span class="keywordflow">case</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw2">Stride</a>: ai = inputStart + i*inputStride; <span class="keywordflow">break</span>;
00139   <span class="keywordflow">default</span>:
00140     <span class="keywordflow">throw</span> std::runtime_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"AdaptorType not handled"</span>));    
00141   }
00142 
00143   <span class="keywordflow">if</span> (ai &gt;= <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;inputSize()) <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorb0">indexOutOfRange</a>();
00144   <span class="keywordflow">return</span> ai;
00145 }
00146 
00147 <span class="keyword">inline</span> <a class="code" href="namespacebase.html#a2">Int</a> ControllableAdaptor::adaptOutputIndex(Int i)<span class="keyword"> const</span>
00148 <span class="keyword"></span>{
00149   <a class="code" href="namespacebase.html#a2">Int</a> ai = 0;
00150   <span class="keywordflow">switch</span> (type) {
00151   <span class="keywordflow">case</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw0">PassThrough</a>: ai=i; <span class="keywordflow">break</span>;
00152   <span class="keywordflow">case</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw1">Range</a>: ai = i + outputStart; <span class="keywordflow">break</span>;
00153   <span class="keywordflow">case</span> <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorw4robot_1_1control_1_1ControllableAdaptorw2">Stride</a>: ai = outputStart + i*outputStride; <span class="keywordflow">break</span>;
00154   <span class="keywordflow">default</span>:
00155     <span class="keywordflow">throw</span> std::runtime_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"AdaptorType not handled"</span>));    
00156   }
00157 
00158   <span class="keywordflow">if</span> (ai &gt;= <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>-&gt;outputSize()) <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorb0">indexOutOfRange</a>();
00159   <span class="keywordflow">return</span> ai;
00160 }
00161 
00162 
00163 
00164 
00165 <span class="comment">// class AdaptorControlInterface</span>
00166 
00167 <a class="code" href="namespacebase.html#a2">base::Int</a> ControllableAdaptor::AdaptorControlInterface::inputSize()<span class="keyword"> const</span>
00168 <span class="keyword"></span>{
00169   <span class="keywordflow">return</span> inputs.size();
00170 }
00171 
00172 <a class="code" href="namespacebase.html#a4">base::String</a> ControllableAdaptor::AdaptorControlInterface::inputName(Int i)<span class="keyword"> const</span>
00173 <span class="keyword"></span>{
00174   <span class="keywordflow">return</span> c-&gt;adaptedInterface-&gt;inputName(c-&gt;adaptInputIndex(i));
00175 }
00176 
00177 <span class="keyword">inline</span> <a class="code" href="namespacebase.html#a5">base::Real</a> ControllableAdaptor::AdaptorControlInterface::getInput(Int i)<span class="keyword"> const</span>
00178 <span class="keyword"></span>{
00179   <span class="keywordflow">return</span> c-&gt;adaptedInterface-&gt;getInput(c-&gt;adaptInputIndex(i));
00180 }
00181 
00182 <span class="keyword">const</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>&amp; ControllableAdaptor::AdaptorControlInterface::getInputs()<span class="keyword"> const</span>
00183 <span class="keyword"></span>{
00184   ref&lt;ControlInterface&gt; <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>(c-&gt;adaptedInterface);
00185   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;inputs.size(); i++)
00186     inputs[i] = adaptedInterface-&gt;getInput(c-&gt;adaptInputIndex(i));
00187 
00188   <span class="keywordflow">return</span> inputs;
00189 }
00190 
00191 <a class="code" href="namespacebase.html#a2">base::Int</a> ControllableAdaptor::AdaptorControlInterface::outputSize()<span class="keyword"> const</span>
00192 <span class="keyword"></span>{
00193   <span class="keywordflow">return</span> outputsSize;
00194 }
00195 
00196 <a class="code" href="namespacebase.html#a4">base::String</a> ControllableAdaptor::AdaptorControlInterface::outputName(Int i)<span class="keyword"> const</span>
00197 <span class="keyword"></span>{
00198   <span class="keywordflow">return</span> c-&gt;adaptedInterface-&gt;outputName(c-&gt;adaptOutputIndex(i));
00199 }
00200 
00201 <span class="keyword">inline</span> <span class="keywordtype">void</span> ControllableAdaptor::AdaptorControlInterface::setOutput(Int i, Real value) 
00202 {
00203   c-&gt;adaptedInterface-&gt;setOutput(c-&gt;adaptOutputIndex(i),value);
00204 }
00205 
00206 <span class="keywordtype">void</span> ControllableAdaptor::AdaptorControlInterface::setOutputs(<span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; values)
00207 {
00208   ref&lt;ControlInterface&gt; <a class="code" href="classrobot_1_1control_1_1ControllableAdaptor.html#robot_1_1control_1_1ControllableAdaptorp10">adaptedInterface</a>(c-&gt;adaptedInterface);
00209   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;values.size(); i++)
00210     adaptedInterface-&gt;setOutput(c-&gt;adaptOutputIndex(i), values[i]);
00211 }
00212 
00213  
00214 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:31 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
