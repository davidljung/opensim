<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/MD5.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/MD5.cpp</h1><a href="MD5_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// MD5.CC - source code for the C++/object oriented translation and </span>
00002 <span class="comment">//          modification of MD5.</span>
00003 
00004 <span class="comment">// Translation and modification (c) 1995 by Mordechai T. Abzug </span>
00005 
00006 <span class="comment">// This translation/ modification is provided "as is," without express or </span>
00007 <span class="comment">// implied warranty of any kind.</span>
00008 
00009 <span class="comment">// The translator/ modifier does not claim (1) that MD5 will do what you think </span>
00010 <span class="comment">// it does; (2) that this translation/ modification is accurate; or (3) that </span>
00011 <span class="comment">// this software is "merchantible."  (Language for this disclaimer partially </span>
00012 <span class="comment">// copied from the disclaimer below).</span>
00013 
00014 <span class="comment">/* based on:</span>
00015 <span class="comment"></span>
00016 <span class="comment">   MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm</span>
00017 <span class="comment">   MDDRIVER.C - test driver for MD2, MD4 and MD5</span>
00018 <span class="comment"></span>
00019 <span class="comment"></span>
00020 <span class="comment">   Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All</span>
00021 <span class="comment">rights reserved.</span>
00022 <span class="comment"></span>
00023 <span class="comment">License to copy and use this software is granted provided that it</span>
00024 <span class="comment">is identified as the "RSA Data Security, Inc. MD5 Message-Digest</span>
00025 <span class="comment">Algorithm" in all material mentioning or referencing this software</span>
00026 <span class="comment">or this function.</span>
00027 <span class="comment"></span>
00028 <span class="comment">License is also granted to make and use derivative works provided</span>
00029 <span class="comment">that such works are identified as "derived from the RSA Data</span>
00030 <span class="comment">Security, Inc. MD5 Message-Digest Algorithm" in all material</span>
00031 <span class="comment">mentioning or referencing the derived work.</span>
00032 <span class="comment"></span>
00033 <span class="comment">RSA Data Security, Inc. makes no representations concerning either</span>
00034 <span class="comment">the merchantability of this software or the suitability of this</span>
00035 <span class="comment">software for any particular purpose. It is provided "as is"</span>
00036 <span class="comment">without express or implied warranty of any kind.</span>
00037 <span class="comment"></span>
00038 <span class="comment">These notices must be retained in any copies of any part of this</span>
00039 <span class="comment">documentation and/or software.</span>
00040 <span class="comment"></span>
00041 <span class="comment"> */</span>
00042 
00043 
00044 
00045 
00046 
00047 
00048 <span class="preprocessor">#include &lt;<a class="code" href="MD5.html">base/MD5</a>&gt;</span>
00049 
00050 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00051 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00052 <span class="preprocessor">#include &lt;iostream&gt;</span>
00053 
00054 
00055 <span class="keyword">using</span> <a class="code" href="classbase_1_1MD5.html">base::MD5</a>;
00056 
00057 
00058 <span class="comment">// MD5 simple initialization method</span>
00059 
00060 MD5::MD5(){
00061 
00062   init();
00063 
00064 }
00065 
00066 
00067 
00068 
00069 <span class="comment">// MD5 block update operation. Continues an MD5 message-digest</span>
00070 <span class="comment">// operation, processing another message block, and updating the</span>
00071 <span class="comment">// context.</span>
00072 
00073 <span class="keywordtype">void</span> MD5::update (uint1 *input, uint4 input_length) {
00074 
00075   uint4 input_index, buffer_index;
00076   uint4 buffer_space;                <span class="comment">// how much space is left in buffer</span>
00077 
00078   <span class="keywordflow">if</span> (finalized){  <span class="comment">// so we can't update!</span>
00079     std::cerr &lt;&lt; <span class="stringliteral">"MD5::update:  Can't update a finalized digest!"</span> &lt;&lt; std::endl;
00080     <span class="keywordflow">return</span>;
00081   }
00082 
00083   <span class="comment">// Compute number of bytes mod 64</span>
00084   buffer_index = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((count[0] &gt;&gt; 3) &amp; 0x3F);
00085 
00086   <span class="comment">// Update number of bits</span>
00087   <span class="keywordflow">if</span> (  (count[0] += ((uint4) input_length &lt;&lt; 3))&lt;((uint4) input_length &lt;&lt; 3) )
00088     count[1]++;
00089 
00090   count[1] += ((uint4)input_length &gt;&gt; 29);
00091 
00092 
00093   buffer_space = 64 - buffer_index;  <span class="comment">// how much space is left in buffer</span>
00094 
00095   <span class="comment">// Transform as many times as possible.</span>
00096   <span class="keywordflow">if</span> (input_length &gt;= buffer_space) { <span class="comment">// ie. we have enough to fill the buffer</span>
00097     <span class="comment">// fill the rest of the buffer and transform</span>
00098     memcpy (buffer + buffer_index, input, buffer_space);
00099     transform (buffer);
00100 
00101     <span class="comment">// now, transform each 64-byte piece of the input, bypassing the buffer</span>
00102     <span class="keywordflow">for</span> (input_index = buffer_space; input_index + 63 &lt; input_length; 
00103          input_index += 64)
00104       transform (input+input_index);
00105 
00106     buffer_index = 0;  <span class="comment">// so we can buffer remaining</span>
00107   }
00108   <span class="keywordflow">else</span>
00109     input_index=0;     <span class="comment">// so we can buffer the whole input</span>
00110 
00111 
00112   <span class="comment">// and here we do the buffering:</span>
00113   memcpy(buffer+buffer_index, input+input_index, input_length-input_index);
00114 }
00115 
00116 
00117 
00118 <span class="comment">// MD5 update for files.</span>
00119 <span class="comment">// Like above, except that it works on files (and uses above as a primitive.)</span>
00120 
00121 <span class="keywordtype">void</span> MD5::update(FILE *file){
00122 
00123   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[1024];
00124   <span class="keywordtype">int</span> len;
00125 
00126   <span class="keywordflow">while</span> ( (len=fread(buffer, 1, 1024, file)) )
00127     <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a>(buffer, len);
00128 
00129   fclose (file);
00130 
00131 }
00132 
00133 
00134 
00135 
00136 
00137 
00138 <span class="comment">// MD5 update for istreams.</span>
00139 <span class="comment">// Like update for files; see above.</span>
00140 
00141 <span class="keywordtype">void</span> MD5::update(std::istream&amp; stream){
00142 
00143   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[1024];
00144   <span class="keywordtype">int</span> len;
00145 
00146   <span class="keywordflow">while</span> (stream.good()){
00147     stream.read((<span class="keywordtype">char</span>*)(&amp;buffer[0]), 1024); <span class="comment">// note that return value of read is unusable.</span>
00148     len=stream.gcount();
00149     <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a>(buffer, len);
00150   }
00151 
00152 }
00153 
00154 
00155 
00156 
00157 
00158 
00159 <span class="comment">// MD5 update for ifstreams.</span>
00160 <span class="comment">// Like update for files; see above.</span>
00161 
00162 <span class="keywordtype">void</span> MD5::update(std::ifstream&amp; stream){
00163 
00164   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[1024];
00165   <span class="keywordtype">int</span> len;
00166 
00167   <span class="keywordflow">while</span> (stream.good()){
00168     stream.read((<span class="keywordtype">char</span>*)(&amp;buffer[0]), 1024); <span class="comment">// note that return value of read is unusable.</span>
00169     len=stream.gcount();
00170     <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a>(buffer, len);
00171   }
00172 
00173 }
00174 
00175 
00176 
00177 
00178 
00179 
00180 <span class="comment">// MD5 finalization. Ends an MD5 message-digest operation, writing the</span>
00181 <span class="comment">// the message digest and zeroizing the context.</span>
00182 
00183 
00184 <span class="keywordtype">void</span> MD5::finalize (){
00185 
00186   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bits[8];
00187   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, padLen;
00188   <span class="keyword">static</span> uint1 PADDING[64]={
00189     0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00190     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00191     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
00192     };
00193 
00194   <span class="keywordflow">if</span> (finalized){
00195     std::cerr &lt;&lt; <span class="stringliteral">"MD5::finalize:  Already finalized this digest!"</span> &lt;&lt; std::endl;
00196     <span class="keywordflow">return</span>;
00197   }
00198 
00199   <span class="comment">// Save number of bits</span>
00200   encode (bits, count, 8);
00201 
00202   <span class="comment">// Pad out to 56 mod 64.</span>
00203   index = (uint4) ((count[0] &gt;&gt; 3) &amp; 0x3f);
00204   padLen = (index &lt; 56) ? (56 - index) : (120 - index);
00205   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a> (PADDING, padLen);
00206 
00207   <span class="comment">// Append length (before padding)</span>
00208   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a> (bits, 8);
00209 
00210   <span class="comment">// Store state in digest</span>
00211   encode (digest, state, 16);
00212 
00213   <span class="comment">// Zeroize sensitive information</span>
00214   memset (buffer, 0, <span class="keyword">sizeof</span>(*buffer));
00215 
00216   finalized=1;
00217 
00218 }
00219 
00220 
00221 
00222 
00223 MD5::MD5(FILE *file){
00224 
00225   init();  <span class="comment">// must be called be all constructors</span>
00226   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a>(file);
00227   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a5">finalize</a> ();
00228 }
00229 
00230 
00231 
00232 
00233 MD5::MD5(std::istream&amp; stream){
00234 
00235   init();  <span class="comment">// must called by all constructors</span>
00236   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a> (stream);
00237   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a5">finalize</a>();
00238 }
00239 
00240 
00241 
00242 MD5::MD5(std::ifstream&amp; stream){
00243 
00244   init();  <span class="comment">// must called by all constructors</span>
00245   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a1">update</a> (stream);
00246   <a class="code" href="classbase_1_1MD5.html#base_1_1MD5a5">finalize</a>();
00247 }
00248 
00249 
00250 
00251 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *MD5::raw_digest(){
00252 
00253   uint1 *s = <span class="keyword">new</span> uint1[16];
00254 
00255   <span class="keywordflow">if</span> (!finalized){
00256     std::cerr &lt;&lt; <span class="stringliteral">"MD5::raw_digest:  Can't get digest if you haven't "</span>&lt;&lt;
00257       <span class="stringliteral">"finalized the digest!"</span> &lt;&lt;std::endl;
00258     <span class="keywordflow">return</span> ( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) <span class="stringliteral">""</span>);
00259   }
00260 
00261   memcpy(s, digest, 16);
00262   <span class="keywordflow">return</span> s;
00263 }
00264 
00265 
00266 
00267 <span class="keywordtype">char</span> *MD5::hex_digest(){
00268 
00269   <span class="keywordtype">int</span> i;
00270   <span class="keywordtype">char</span> *s= <span class="keyword">new</span> <span class="keywordtype">char</span>[33];
00271 
00272   <span class="keywordflow">if</span> (!finalized){
00273     std::cerr &lt;&lt; <span class="stringliteral">"MD5::hex_digest:  Can't get digest if you haven't "</span>&lt;&lt;
00274       <span class="stringliteral">"finalized the digest!"</span> &lt;&lt;std::endl;
00275     <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00276   }
00277 
00278   <span class="keywordflow">for</span> (i=0; i&lt;16; i++)
00279     sprintf(s+i*2, <span class="stringliteral">"%02x"</span>, digest[i]);
00280 
00281   s[32]=<span class="charliteral">'\0'</span>;
00282 
00283   <span class="keywordflow">return</span> s;
00284 }
00285 
00286 
00287 
00288 
00289 
<a name="l00290"></a><a class="code" href="MD5_8cpp.html#a16">00290</a> std::ostream&amp; <a class="code" href="namespacebase.html#a66">operator&lt;&lt;</a>(std::ostream &amp;stream, MD5 context){
00291 
00292   stream &lt;&lt; context.hex_digest();
00293   <span class="keywordflow">return</span> stream;
00294 }
00295 
00296 
00297 
00298 
00299 <span class="comment">// PRIVATE METHODS:</span>
00300 
00301 
00302 
00303 <span class="keywordtype">void</span> MD5::init(){
00304   finalized=0;  <span class="comment">// we just started!</span>
00305 
00306   <span class="comment">// Nothing counted, so count=0</span>
00307   count[0] = 0;
00308   count[1] = 0;
00309 
00310   <span class="comment">// Load magic initialization constants.</span>
00311   state[0] = 0x67452301;
00312   state[1] = 0xefcdab89;
00313   state[2] = 0x98badcfe;
00314   state[3] = 0x10325476;
00315 }
00316 
00317 
00318 
00319 <span class="comment">// Constants for MD5Transform routine.</span>
00320 <span class="comment">// Although we could use C++ style constants, defines are actually better,</span>
00321 <span class="comment">// since they let us easily evade scope clashes.</span>
00322 
<a name="l00323"></a><a class="code" href="MD5_8cpp.html#a0">00323</a> <span class="preprocessor">#define S11 7</span>
<a name="l00324"></a><a class="code" href="MD5_8cpp.html#a1">00324</a> <span class="preprocessor"></span><span class="preprocessor">#define S12 12</span>
<a name="l00325"></a><a class="code" href="MD5_8cpp.html#a2">00325</a> <span class="preprocessor"></span><span class="preprocessor">#define S13 17</span>
<a name="l00326"></a><a class="code" href="MD5_8cpp.html#a3">00326</a> <span class="preprocessor"></span><span class="preprocessor">#define S14 22</span>
<a name="l00327"></a><a class="code" href="MD5_8cpp.html#a4">00327</a> <span class="preprocessor"></span><span class="preprocessor">#define S21 5</span>
<a name="l00328"></a><a class="code" href="MD5_8cpp.html#a5">00328</a> <span class="preprocessor"></span><span class="preprocessor">#define S22 9</span>
<a name="l00329"></a><a class="code" href="MD5_8cpp.html#a6">00329</a> <span class="preprocessor"></span><span class="preprocessor">#define S23 14</span>
<a name="l00330"></a><a class="code" href="MD5_8cpp.html#a7">00330</a> <span class="preprocessor"></span><span class="preprocessor">#define S24 20</span>
<a name="l00331"></a><a class="code" href="MD5_8cpp.html#a8">00331</a> <span class="preprocessor"></span><span class="preprocessor">#define S31 4</span>
<a name="l00332"></a><a class="code" href="MD5_8cpp.html#a9">00332</a> <span class="preprocessor"></span><span class="preprocessor">#define S32 11</span>
<a name="l00333"></a><a class="code" href="MD5_8cpp.html#a10">00333</a> <span class="preprocessor"></span><span class="preprocessor">#define S33 16</span>
<a name="l00334"></a><a class="code" href="MD5_8cpp.html#a11">00334</a> <span class="preprocessor"></span><span class="preprocessor">#define S34 23</span>
<a name="l00335"></a><a class="code" href="MD5_8cpp.html#a12">00335</a> <span class="preprocessor"></span><span class="preprocessor">#define S41 6</span>
<a name="l00336"></a><a class="code" href="MD5_8cpp.html#a13">00336</a> <span class="preprocessor"></span><span class="preprocessor">#define S42 10</span>
<a name="l00337"></a><a class="code" href="MD5_8cpp.html#a14">00337</a> <span class="preprocessor"></span><span class="preprocessor">#define S43 15</span>
<a name="l00338"></a><a class="code" href="MD5_8cpp.html#a15">00338</a> <span class="preprocessor"></span><span class="preprocessor">#define S44 21</span>
00339 <span class="preprocessor"></span>
00340 
00341 
00342 
00343 <span class="comment">// MD5 basic transformation. Transforms state based on block.</span>
00344 <span class="keywordtype">void</span> MD5::transform (uint1 block[64]){
00345 
00346   uint4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
00347 
00348   decode (x, block, 64);
00349 
00350   assert(!finalized);  <span class="comment">// not just a user error, since the method is private</span>
00351 
00352   <span class="comment">/* Round 1 */</span>
00353   FF (a, b, c, d, x[ 0], <a class="code" href="MD5_8cpp.html#a0">S11</a>, 0xd76aa478); <span class="comment">/* 1 */</span>
00354   FF (d, a, b, c, x[ 1], <a class="code" href="MD5_8cpp.html#a1">S12</a>, 0xe8c7b756); <span class="comment">/* 2 */</span>
00355   FF (c, d, a, b, x[ 2], <a class="code" href="MD5_8cpp.html#a2">S13</a>, 0x242070db); <span class="comment">/* 3 */</span>
00356   FF (b, c, d, a, x[ 3], <a class="code" href="MD5_8cpp.html#a3">S14</a>, 0xc1bdceee); <span class="comment">/* 4 */</span>
00357   FF (a, b, c, d, x[ 4], <a class="code" href="MD5_8cpp.html#a0">S11</a>, 0xf57c0faf); <span class="comment">/* 5 */</span>
00358   FF (d, a, b, c, x[ 5], <a class="code" href="MD5_8cpp.html#a1">S12</a>, 0x4787c62a); <span class="comment">/* 6 */</span>
00359   FF (c, d, a, b, x[ 6], <a class="code" href="MD5_8cpp.html#a2">S13</a>, 0xa8304613); <span class="comment">/* 7 */</span>
00360   FF (b, c, d, a, x[ 7], <a class="code" href="MD5_8cpp.html#a3">S14</a>, 0xfd469501); <span class="comment">/* 8 */</span>
00361   FF (a, b, c, d, x[ 8], <a class="code" href="MD5_8cpp.html#a0">S11</a>, 0x698098d8); <span class="comment">/* 9 */</span>
00362   FF (d, a, b, c, x[ 9], <a class="code" href="MD5_8cpp.html#a1">S12</a>, 0x8b44f7af); <span class="comment">/* 10 */</span>
00363   FF (c, d, a, b, x[10], <a class="code" href="MD5_8cpp.html#a2">S13</a>, 0xffff5bb1); <span class="comment">/* 11 */</span>
00364   FF (b, c, d, a, x[11], <a class="code" href="MD5_8cpp.html#a3">S14</a>, 0x895cd7be); <span class="comment">/* 12 */</span>
00365   FF (a, b, c, d, x[12], <a class="code" href="MD5_8cpp.html#a0">S11</a>, 0x6b901122); <span class="comment">/* 13 */</span>
00366   FF (d, a, b, c, x[13], <a class="code" href="MD5_8cpp.html#a1">S12</a>, 0xfd987193); <span class="comment">/* 14 */</span>
00367   FF (c, d, a, b, x[14], <a class="code" href="MD5_8cpp.html#a2">S13</a>, 0xa679438e); <span class="comment">/* 15 */</span>
00368   FF (b, c, d, a, x[15], <a class="code" href="MD5_8cpp.html#a3">S14</a>, 0x49b40821); <span class="comment">/* 16 */</span>
00369 
00370  <span class="comment">/* Round 2 */</span>
00371   GG (a, b, c, d, x[ 1], <a class="code" href="MD5_8cpp.html#a4">S21</a>, 0xf61e2562); <span class="comment">/* 17 */</span>
00372   GG (d, a, b, c, x[ 6], <a class="code" href="MD5_8cpp.html#a5">S22</a>, 0xc040b340); <span class="comment">/* 18 */</span>
00373   GG (c, d, a, b, x[11], <a class="code" href="MD5_8cpp.html#a6">S23</a>, 0x265e5a51); <span class="comment">/* 19 */</span>
00374   GG (b, c, d, a, x[ 0], <a class="code" href="MD5_8cpp.html#a7">S24</a>, 0xe9b6c7aa); <span class="comment">/* 20 */</span>
00375   GG (a, b, c, d, x[ 5], <a class="code" href="MD5_8cpp.html#a4">S21</a>, 0xd62f105d); <span class="comment">/* 21 */</span>
00376   GG (d, a, b, c, x[10], <a class="code" href="MD5_8cpp.html#a5">S22</a>,  0x2441453); <span class="comment">/* 22 */</span>
00377   GG (c, d, a, b, x[15], <a class="code" href="MD5_8cpp.html#a6">S23</a>, 0xd8a1e681); <span class="comment">/* 23 */</span>
00378   GG (b, c, d, a, x[ 4], <a class="code" href="MD5_8cpp.html#a7">S24</a>, 0xe7d3fbc8); <span class="comment">/* 24 */</span>
00379   GG (a, b, c, d, x[ 9], <a class="code" href="MD5_8cpp.html#a4">S21</a>, 0x21e1cde6); <span class="comment">/* 25 */</span>
00380   GG (d, a, b, c, x[14], <a class="code" href="MD5_8cpp.html#a5">S22</a>, 0xc33707d6); <span class="comment">/* 26 */</span>
00381   GG (c, d, a, b, x[ 3], <a class="code" href="MD5_8cpp.html#a6">S23</a>, 0xf4d50d87); <span class="comment">/* 27 */</span>
00382   GG (b, c, d, a, x[ 8], <a class="code" href="MD5_8cpp.html#a7">S24</a>, 0x455a14ed); <span class="comment">/* 28 */</span>
00383   GG (a, b, c, d, x[13], <a class="code" href="MD5_8cpp.html#a4">S21</a>, 0xa9e3e905); <span class="comment">/* 29 */</span>
00384   GG (d, a, b, c, x[ 2], <a class="code" href="MD5_8cpp.html#a5">S22</a>, 0xfcefa3f8); <span class="comment">/* 30 */</span>
00385   GG (c, d, a, b, x[ 7], <a class="code" href="MD5_8cpp.html#a6">S23</a>, 0x676f02d9); <span class="comment">/* 31 */</span>
00386   GG (b, c, d, a, x[12], <a class="code" href="MD5_8cpp.html#a7">S24</a>, 0x8d2a4c8a); <span class="comment">/* 32 */</span>
00387 
00388   <span class="comment">/* Round 3 */</span>
00389   HH (a, b, c, d, x[ 5], <a class="code" href="MD5_8cpp.html#a8">S31</a>, 0xfffa3942); <span class="comment">/* 33 */</span>
00390   HH (d, a, b, c, x[ 8], <a class="code" href="MD5_8cpp.html#a9">S32</a>, 0x8771f681); <span class="comment">/* 34 */</span>
00391   HH (c, d, a, b, x[11], <a class="code" href="MD5_8cpp.html#a10">S33</a>, 0x6d9d6122); <span class="comment">/* 35 */</span>
00392   HH (b, c, d, a, x[14], <a class="code" href="MD5_8cpp.html#a11">S34</a>, 0xfde5380c); <span class="comment">/* 36 */</span>
00393   HH (a, b, c, d, x[ 1], <a class="code" href="MD5_8cpp.html#a8">S31</a>, 0xa4beea44); <span class="comment">/* 37 */</span>
00394   HH (d, a, b, c, x[ 4], <a class="code" href="MD5_8cpp.html#a9">S32</a>, 0x4bdecfa9); <span class="comment">/* 38 */</span>
00395   HH (c, d, a, b, x[ 7], <a class="code" href="MD5_8cpp.html#a10">S33</a>, 0xf6bb4b60); <span class="comment">/* 39 */</span>
00396   HH (b, c, d, a, x[10], <a class="code" href="MD5_8cpp.html#a11">S34</a>, 0xbebfbc70); <span class="comment">/* 40 */</span>
00397   HH (a, b, c, d, x[13], <a class="code" href="MD5_8cpp.html#a8">S31</a>, 0x289b7ec6); <span class="comment">/* 41 */</span>
00398   HH (d, a, b, c, x[ 0], <a class="code" href="MD5_8cpp.html#a9">S32</a>, 0xeaa127fa); <span class="comment">/* 42 */</span>
00399   HH (c, d, a, b, x[ 3], <a class="code" href="MD5_8cpp.html#a10">S33</a>, 0xd4ef3085); <span class="comment">/* 43 */</span>
00400   HH (b, c, d, a, x[ 6], <a class="code" href="MD5_8cpp.html#a11">S34</a>,  0x4881d05); <span class="comment">/* 44 */</span>
00401   HH (a, b, c, d, x[ 9], <a class="code" href="MD5_8cpp.html#a8">S31</a>, 0xd9d4d039); <span class="comment">/* 45 */</span>
00402   HH (d, a, b, c, x[12], <a class="code" href="MD5_8cpp.html#a9">S32</a>, 0xe6db99e5); <span class="comment">/* 46 */</span>
00403   HH (c, d, a, b, x[15], <a class="code" href="MD5_8cpp.html#a10">S33</a>, 0x1fa27cf8); <span class="comment">/* 47 */</span>
00404   HH (b, c, d, a, x[ 2], <a class="code" href="MD5_8cpp.html#a11">S34</a>, 0xc4ac5665); <span class="comment">/* 48 */</span>
00405 
00406   <span class="comment">/* Round 4 */</span>
00407   II (a, b, c, d, x[ 0], <a class="code" href="MD5_8cpp.html#a12">S41</a>, 0xf4292244); <span class="comment">/* 49 */</span>
00408   II (d, a, b, c, x[ 7], <a class="code" href="MD5_8cpp.html#a13">S42</a>, 0x432aff97); <span class="comment">/* 50 */</span>
00409   II (c, d, a, b, x[14], <a class="code" href="MD5_8cpp.html#a14">S43</a>, 0xab9423a7); <span class="comment">/* 51 */</span>
00410   II (b, c, d, a, x[ 5], <a class="code" href="MD5_8cpp.html#a15">S44</a>, 0xfc93a039); <span class="comment">/* 52 */</span>
00411   II (a, b, c, d, x[12], <a class="code" href="MD5_8cpp.html#a12">S41</a>, 0x655b59c3); <span class="comment">/* 53 */</span>
00412   II (d, a, b, c, x[ 3], <a class="code" href="MD5_8cpp.html#a13">S42</a>, 0x8f0ccc92); <span class="comment">/* 54 */</span>
00413   II (c, d, a, b, x[10], <a class="code" href="MD5_8cpp.html#a14">S43</a>, 0xffeff47d); <span class="comment">/* 55 */</span>
00414   II (b, c, d, a, x[ 1], <a class="code" href="MD5_8cpp.html#a15">S44</a>, 0x85845dd1); <span class="comment">/* 56 */</span>
00415   II (a, b, c, d, x[ 8], <a class="code" href="MD5_8cpp.html#a12">S41</a>, 0x6fa87e4f); <span class="comment">/* 57 */</span>
00416   II (d, a, b, c, x[15], <a class="code" href="MD5_8cpp.html#a13">S42</a>, 0xfe2ce6e0); <span class="comment">/* 58 */</span>
00417   II (c, d, a, b, x[ 6], <a class="code" href="MD5_8cpp.html#a14">S43</a>, 0xa3014314); <span class="comment">/* 59 */</span>
00418   II (b, c, d, a, x[13], <a class="code" href="MD5_8cpp.html#a15">S44</a>, 0x4e0811a1); <span class="comment">/* 60 */</span>
00419   II (a, b, c, d, x[ 4], <a class="code" href="MD5_8cpp.html#a12">S41</a>, 0xf7537e82); <span class="comment">/* 61 */</span>
00420   II (d, a, b, c, x[11], <a class="code" href="MD5_8cpp.html#a13">S42</a>, 0xbd3af235); <span class="comment">/* 62 */</span>
00421   II (c, d, a, b, x[ 2], <a class="code" href="MD5_8cpp.html#a14">S43</a>, 0x2ad7d2bb); <span class="comment">/* 63 */</span>
00422   II (b, c, d, a, x[ 9], <a class="code" href="MD5_8cpp.html#a15">S44</a>, 0xeb86d391); <span class="comment">/* 64 */</span>
00423 
00424   state[0] += a;
00425   state[1] += b;
00426   state[2] += c;
00427   state[3] += d;
00428 
00429   <span class="comment">// Zeroize sensitive information.</span>
00430   memset ( (uint1 *) x, 0, <span class="keyword">sizeof</span>(x));
00431 
00432 }
00433 
00434 
00435 
00436 <span class="comment">// Encodes input (UINT4) into output (unsigned char). Assumes len is</span>
00437 <span class="comment">// a multiple of 4.</span>
00438 <span class="keywordtype">void</span> MD5::encode (uint1 *output, uint4 *input, uint4 len) {
00439 
00440   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
00441 
00442   <span class="keywordflow">for</span> (i = 0, j = 0; j &lt; len; i++, j += 4) {
00443     output[j]   = (uint1)  (input[i] &amp; 0xff);
00444     output[j+1] = (uint1) ((input[i] &gt;&gt; 8) &amp; 0xff);
00445     output[j+2] = (uint1) ((input[i] &gt;&gt; 16) &amp; 0xff);
00446     output[j+3] = (uint1) ((input[i] &gt;&gt; 24) &amp; 0xff);
00447   }
00448 }
00449 
00450 
00451 
00452 
00453 <span class="comment">// Decodes input (unsigned char) into output (UINT4). Assumes len is</span>
00454 <span class="comment">// a multiple of 4.</span>
00455 <span class="keywordtype">void</span> MD5::decode (uint4 *output, uint1 *input, uint4 len){
00456 
00457   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
00458 
00459   <span class="keywordflow">for</span> (i = 0, j = 0; j &lt; len; i++, j += 4)
00460     output[i] = ((uint4)input[j]) | (((uint4)input[j+1]) &lt;&lt; 8) |
00461       (((uint4)input[j+2]) &lt;&lt; 16) | (((uint4)input[j+3]) &lt;&lt; 24);
00462 }
00463 
00464 
00465 
00466 
00467 
00468 <span class="comment">// Note: Replace "for loop" with standard memcpy if possible.</span>
00469 <span class="keywordtype">void</span> MD5::memcpy (uint1 *output, uint1 *input, uint4 len){
00470 
00471   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00472 
00473   <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
00474     output[i] = input[i];
00475 }
00476 
00477 
00478 
00479 <span class="comment">// Note: Replace "for loop" with standard memset if possible.</span>
00480 <span class="keywordtype">void</span> MD5::memset (uint1 *output, uint1 value, uint4 len){
00481 
00482   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00483 
00484   <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
00485     output[i] = value;
00486 }
00487 
00488 
00489 
00490 <span class="comment">// ROTATE_LEFT rotates x left n bits.</span>
00491 
00492 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MD5::rotate_left  (uint4 x, uint4 n){
00493   <span class="keywordflow">return</span> (x &lt;&lt; n) | (x &gt;&gt; (32-n))  ;
00494 }
00495 
00496 
00497 
00498 
00499 <span class="comment">// F, G, H and I are basic MD5 functions.</span>
00500 
00501 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MD5::F            (uint4 x, uint4 y, uint4 z){
00502   <span class="keywordflow">return</span> (x &amp; y) | (~x &amp; z);
00503 }
00504 
00505 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MD5::G            (uint4 x, uint4 y, uint4 z){
00506   <span class="keywordflow">return</span> (x &amp; z) | (y &amp; ~z);
00507 }
00508 
00509 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MD5::H            (uint4 x, uint4 y, uint4 z){
00510   <span class="keywordflow">return</span> x ^ y ^ z;
00511 }
00512 
00513 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MD5::I            (uint4 x, uint4 y, uint4 z){
00514   <span class="keywordflow">return</span> y ^ (x | ~z);
00515 }
00516 
00517 
00518 
00519 <span class="comment">// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.</span>
00520 <span class="comment">// Rotation is separate from addition to prevent recomputation.</span>
00521 
00522 
00523 <span class="keyword">inline</span> <span class="keywordtype">void</span> MD5::FF(uint4&amp; a, uint4 b, uint4 c, uint4 d, uint4 x, 
00524                     uint4  s, uint4 ac){
00525  a += F(b, c, d) + x + ac;
00526  a = rotate_left (a, s) +b;
00527 }
00528 
00529 <span class="keyword">inline</span> <span class="keywordtype">void</span> MD5::GG(uint4&amp; a, uint4 b, uint4 c, uint4 d, uint4 x, 
00530                     uint4 s, uint4 ac){
00531  a += G(b, c, d) + x + ac;
00532  a = rotate_left (a, s) +b;
00533 }
00534 
00535 <span class="keyword">inline</span> <span class="keywordtype">void</span> MD5::HH(uint4&amp; a, uint4 b, uint4 c, uint4 d, uint4 x, 
00536                     uint4 s, uint4 ac){
00537  a += H(b, c, d) + x + ac;
00538  a = rotate_left (a, s) +b;
00539 }
00540 
00541 <span class="keyword">inline</span> <span class="keywordtype">void</span> MD5::II(uint4&amp; a, uint4 b, uint4 c, uint4 d, uint4 x, 
00542                              uint4 s, uint4 ac){
00543  a += I(b, c, d) + x + ac;
00544  a = rotate_left (a, s) +b;
00545 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:08 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
