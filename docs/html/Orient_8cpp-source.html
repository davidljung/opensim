<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/Orient.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/Orient.cpp</h1><a href="Orient_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Orient.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.21 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="Orient.html">base/Orient</a>&gt;</span>
00026 
00027 <span class="keyword">using</span> <a class="code" href="classbase_1_1Orient.html">base::Orient</a>;
00028 
00029 <span class="preprocessor">#include &lt;<a class="code" href="Math.html">base/Math</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;<a class="code" href="Serializer.html">base/Serializer</a>&gt;</span>
00031 
00032 
00033 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a0">base::Byte</a>;
00034 <span class="keyword">using</span> <a class="code" href="classbase_1_1Math.html">base::Math</a>;
00035 <span class="keyword">using</span> <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a>;
00036 <span class="keyword">using</span> <a class="code" href="classbase_1_1Matrix4.html">base::Matrix4</a>;
00037 <span class="keyword">using</span> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>;
00038 <span class="keyword">using</span> <a class="code" href="classbase_1_1Vector4.html">base::Point4</a>;
00039 <span class="keyword">using</span> <a class="code" href="classbase_1_1Quat4.html">base::Quat4</a>;
00040 <span class="keyword">using</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>;
00041 <span class="keyword">using</span> <a class="code" href="classbase_1_1matrix.html">base::Matrix</a>;
00042 
00043 <a class="code" href="namespacebase.html#a0">Byte</a> Orient::EulSafe[4] = { 0,1,2,0 };
00044 <a class="code" href="namespacebase.html#a0">Byte</a> Orient::EulNext[4] = { 1,2,0,1 };
00045 
00046 <span class="keyword">const</span> Orient::Representation Orient::EulerXYZs = eulerRep(X,Even, NonRepeating,Static);
00047 <span class="keyword">const</span> Orient::Representation Orient::EulerXYXs = eulerRep(X,Even,    Repeating,Static);
00048 <span class="keyword">const</span> Orient::Representation Orient::EulerXZYs = eulerRep(X,Odd , NonRepeating,Static);
00049 <span class="keyword">const</span> Orient::Representation Orient::EulerXZXs = eulerRep(X,Odd ,    Repeating,Static);
00050 <span class="keyword">const</span> Orient::Representation Orient::EulerYZXs = eulerRep(Y,Even, NonRepeating,Static);
00051 <span class="keyword">const</span> Orient::Representation Orient::EulerYZYs = eulerRep(Y,Even,    Repeating,Static);
00052 <span class="keyword">const</span> Orient::Representation Orient::EulerYXZs = eulerRep(Y,Odd , NonRepeating,Static);
00053 <span class="keyword">const</span> Orient::Representation Orient::EulerYXYs = eulerRep(Y,Odd ,    Repeating,Static);
00054 <span class="keyword">const</span> Orient::Representation Orient::EulerZXYs = eulerRep(Z,Even, NonRepeating,Static);
00055 <span class="keyword">const</span> Orient::Representation Orient::EulerZXZs = eulerRep(Z,Even,    Repeating,Static);
00056 <span class="keyword">const</span> Orient::Representation Orient::EulerZYXs = eulerRep(Z,Odd , NonRepeating,Static);
00057 <span class="keyword">const</span> Orient::Representation Orient::EulerZYZs = eulerRep(Z,Odd ,    Repeating,Static);
00058 
00059 <span class="keyword">const</span> Orient::Representation Orient::EulerZYXr = eulerRep(X,Even, NonRepeating,Rotating);
00060 <span class="keyword">const</span> Orient::Representation Orient::EulerXYXr = eulerRep(X,Even,    Repeating,Rotating);
00061 <span class="keyword">const</span> Orient::Representation Orient::EulerYZXr = eulerRep(X,Odd , NonRepeating,Rotating);
00062 <span class="keyword">const</span> Orient::Representation Orient::EulerXZXr = eulerRep(X,Odd ,    Repeating,Rotating);
00063 <span class="keyword">const</span> Orient::Representation Orient::EulerXZYr = eulerRep(Y,Even, NonRepeating,Rotating);
00064 <span class="keyword">const</span> Orient::Representation Orient::EulerYZYr = eulerRep(Y,Even,    Repeating,Rotating);
00065 <span class="keyword">const</span> Orient::Representation Orient::EulerZXYr = eulerRep(Y,Odd , NonRepeating,Rotating);
00066 <span class="keyword">const</span> Orient::Representation Orient::EulerYXYr = eulerRep(Y,Odd ,    Repeating,Rotating);
00067 <span class="keyword">const</span> Orient::Representation Orient::EulerYXZr = eulerRep(Z,Even, NonRepeating,Rotating);
00068 <span class="keyword">const</span> Orient::Representation Orient::EulerZXZr = eulerRep(Z,Even,    Repeating,Rotating);
00069 <span class="keyword">const</span> Orient::Representation Orient::EulerXYZr = eulerRep(Z,Odd , NonRepeating,Rotating);
00070 <span class="keyword">const</span> Orient::Representation Orient::EulerZYZr = eulerRep(Z,Odd ,    Repeating,Rotating);
00071 
00072 <span class="keyword">const</span> Orient::Representation Orient::EulerRPY  = eulerRep(X,Even, NonRepeating,Static); <span class="comment">// XYZs</span>
00073 
00074 
00075 
00076 
00077 
00078 Orient::Orient() 
00079   : rep(EulerRPY), v(<a class="code" href="namespacebase.html#a201">zeroVector</a>(3)) 
00080 {
00081 }
00082 
00083 
00084 Orient::Orient(Representation representation)
00085   : rep(representation), v(<a class="code" href="namespacebase.html#a201">zeroVector</a>(3))
00086 {
00087   <a class="code" href="base.html#a19">Assert</a>(rep &lt; RepEnd);
00088   <span class="keywordflow">if</span> (rep == Mat) {
00089     m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00090     *m = <a class="code" href="namespacebase.html#a101">identityMatrix</a>(3,3);
00091   }
00092   <span class="keywordflow">else</span> {
00093     <span class="keywordflow">if</span> (rep == Quat) {
00094       Quat4 q;
00095       v.resize(4); 
00096       v[0]=q.v.x; v[1]=q.v.y; v[2]=q.v.z; v[3]=q.w;
00097     }
00098   }
00099 }
00100 
00101 
00102 Orient::Orient(<span class="keyword">const</span> Quat4&amp; q)
00103  : rep(Quat), v(4) 
00104 {
00105   v[0]=q.v.x; v[1]=q.v.y; v[2]=q.v.z; v[3]=q.w; 
00106 }
00107 
00108   
00109 Orient::Orient(Real roll, Real pitch, Real yaw) 
00110  : rep(EulerRPY), v(3)
00111 {
00112   v[0]=roll; v[1]=pitch; v[2]=yaw; 
00113 }
00114 
00115 
00116   
00117 Orient::Orient(<span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; v, Representation representation)
00118   : rep(representation)
00119 {
00120   <a class="code" href="base.html#a19">Assert</a>(rep &lt; RepEnd);
00121   <a class="code" href="base.html#a21">Assertm</a>( (rep==Quat)?(v.size()==4):<span class="keyword">true</span>, <span class="stringliteral">"Quaternion has 4 components"</span>);
00122   <span class="keywordflow">if</span> (rep==Mat) {
00123     <a class="code" href="base.html#a21">Assertm</a>( v.size() == 9, <span class="stringliteral">"Rotation matrix has 9 components"</span>);
00124     m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00125     (*m)(0,0) = v[0]; (*m)(0,1) = v[1]; (*m)(0,2) = v[2];
00126     (*m)(1,0) = v[3]; (*m)(1,1) = v[4]; (*m)(1,2) = v[5];
00127     (*m)(2,0) = v[6]; (*m)(2,1) = v[7]; (*m)(2,2) = v[8];
00128   }
00129   <span class="keywordflow">else</span> {
00130     <span class="keywordflow">if</span> (rep!=Quat) {
00131       <a class="code" href="base.html#a21">Assertm</a>( v.size()==3, <span class="stringliteral">"vector should have 3 components"</span>);
00132       this-&gt;v.reset(v);
00133     }
00134     <span class="keywordflow">else</span> { <span class="comment">// normalize Quat</span>
00135       Quat4 q(v[0],v[1],v[2],v[3]);
00136       q.normalize();
00137       this-&gt;v.resize(4);
00138       this-&gt;v[0]=q.v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>; this-&gt;v[1]=q.v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>; this-&gt;v[2]=q.v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>; this-&gt;v[3]=q.w;
00139     }
00140   }
00141 }
00142 
00143 
00144 Orient::Orient(<span class="keyword">const</span> Matrix3&amp; m3)
00145  : rep(Mat), m(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1matrix.html">Matrix</a>(3,3)) 
00146 {
00147   (*m)(0,0) = m3(1,1);
00148   (*m)(0,1) = m3(1,2);
00149   (*m)(0,2) = m3(1,3);
00150   (*m)(1,0) = m3(2,1);
00151   (*m)(1,1) = m3(2,2);
00152   (*m)(1,2) = m3(2,3);
00153   (*m)(2,0) = m3(3,1);
00154   (*m)(2,1) = m3(3,2);
00155   (*m)(2,2) = m3(3,3);
00156 }
00157 
00158 
00159 Orient::Orient(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; m)
00160   : rep(Mat), m(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1matrix.html">Matrix</a>(3,3)) 
00161 {
00162   <a class="code" href="base.html#a19">Assert</a>(m.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>()==3);
00163   <a class="code" href="base.html#a19">Assert</a>(m.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>()==3);
00164   *(this-&gt;m) = m;
00165 }
00166 
00167 
00168 Orient::Orient(<span class="keyword">const</span> Orient&amp; copy)
00169  : rep(copy.rep) 
00170 {
00171   <span class="keywordflow">if</span> (rep!=Mat) {
00172     v.resize(copy.v.size());
00173     v = copy.v;
00174   }
00175   <span class="keywordflow">else</span> {
00176     m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(*copy.m));
00177     *m = *copy.m;
00178   }
00179 }
00180 
00181 
00182 Orient::~Orient() 
00183 {
00184   <span class="keywordflow">if</span> (rep==Mat)
00185     <span class="keyword">delete</span> &amp;(*m);
00186 }
00187 
00188   
00189 Orient&amp; Orient::operator=(<span class="keyword">const</span> Matrix3&amp; mt)
00190 {
00191   <span class="keywordflow">if</span> (rep != Mat)
00192     m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00193   rep = Mat;
00194   (*m)(0,0) = mt(1,1); (*m)(0,1) = mt(1,2);  (*m)(0,2) = mt(1,3); 
00195   (*m)(1,0) = mt(2,1); (*m)(1,1) = mt(2,2);  (*m)(1,2) = mt(2,3);
00196   (*m)(2,0) = mt(3,1); (*m)(2,1) = mt(3,2);  (*m)(2,2) = mt(3,3);
00197   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00198 }
00199   
00200 
00201 
00202 
00203 <a class="code" href="namespacebase.html#a4">base::String</a> Orient::representationString(Representation rep)
00204 {
00205   <span class="keywordflow">if</span> (rep == Quat) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Quat"</span>);
00206   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == Mat) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Matrix"</span>);
00207   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == Rodriguez) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Rodriguez"</span>);
00208   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXYZs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXYZs"</span>);
00209   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXYXs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXYXs"</span>);
00210   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXZYs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXZYs"</span>);
00211   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXZXs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXZXs"</span>);
00212   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYZXs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYZXs"</span>);
00213   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYZYs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYZYs"</span>);
00214   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYXZs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYXZs"</span>);
00215   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYXYs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYXYs"</span>);
00216   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZXYs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZXYs"</span>);
00217   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZXZs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZXZs"</span>);
00218   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZYXs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZYXs"</span>);
00219   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZYZs) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZYZs"</span>);
00220   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZYXr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZYXr"</span>);
00221   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXYXr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXYXr"</span>);
00222   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYZXr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYZXr"</span>);
00223   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXZXr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXZXr"</span>);
00224   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXZYr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXZYr"</span>);
00225   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYZYr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYZYr"</span>);
00226   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZXYr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZXYr"</span>);
00227   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYXYr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYXYr"</span>);
00228   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerYXZr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerYXZr"</span>);
00229   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZXZr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZXZr"</span>);
00230   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerXYZr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerXYZr"</span>);
00231   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == EulerZYZr) <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"EulerZYZr"</span>);
00232   <span class="keywordflow">else</span> <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"unknown representation"</span>));
00233 }
00234 
00235 
00236   
00237 
00238 
00239 <a class="code" href="classbase_1_1matrix.html">Matrix</a> Orient::getRotationMatrix()<span class="keyword"> const</span>
00240 <span class="keyword"></span>{
00241   Orient r(*<span class="keyword">this</span>); r.changeRep(Mat);
00242   <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a18">Matrix</a>(*r.m);
00243 }
00244 
00245 
00246 Matrix3 Orient::getRotationMatrix3()<span class="keyword"> const</span>
00247 <span class="keyword"></span>{
00248   Orient r(*<span class="keyword">this</span>); r.changeRep(Mat);
00249   <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; m(*r.m);
00250   Matrix3 m3(m(0,0), m(0,1), m(0,2),
00251              m(1,0), m(1,1), m(1,2),
00252              m(2,0), m(2,1), m(2,2));
00253   <span class="keywordflow">return</span> m3;
00254 }
00255 
00256 Quat4 Orient::getQuat4()<span class="keyword"> const </span>
00257 <span class="keyword"></span>{
00258   <span class="keywordflow">if</span> (rep == Quat)
00259     <span class="keywordflow">return</span> Quat4(v[0],v[1],v[2],v[3]);
00260   <span class="keywordflow">else</span> {
00261     Orient r(*<span class="keyword">this</span>);
00262     r.changeRep(Quat);
00263     <span class="keywordflow">return</span> Quat4(r.v[0],r.v[1],r.v[2],r.v[3]);
00264   }
00265 }
00266 
00267 <a class="code" href="classdemeter_1_1Vector.html">Vector</a> Orient::getVector(Representation representation)<span class="keyword"> const </span>
00268 <span class="keyword"></span>{
00269   Orient c;
00270   <span class="keyword">const</span> Orient* r(<span class="keyword">this</span>);
00271   <span class="keywordflow">if</span> (rep != representation) {
00272     c = *<span class="keyword">this</span>;
00273     c.changeRep(representation);
00274     r = &amp;c;
00275   }
00276 
00277   <span class="keywordflow">if</span> (representation!=Mat) {
00278     <span class="keywordflow">return</span> r-&gt;v;
00279   }
00280   <span class="keywordflow">else</span> {
00281     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v(9);
00282     <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; m(*(r-&gt;m));
00283     v[0] = m(0,0); v[1] = m(0,1); v[2] = m(0,2);
00284     v[3] = m(1,0); v[4] = m(1,1); v[5] = m(1,2);
00285     v[6] = m(2,0); v[7] = m(2,1); v[8] = m(2,2);
00286     <span class="keywordflow">return</span> v;
00287    }
00288 }
00289 
00290 
00291 Vector3 Orient::getVector3(Representation representation)<span class="keyword"> const </span>
00292 <span class="keyword"></span>{
00293   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> v( getVector(representation) );
00294   <span class="keywordflow">return</span> Vector3(v[0],v[1],v[2]);
00295 }
00296 
00297 
00298 
00299 Orient&amp; Orient::operator=(<span class="keyword">const</span> Orient&amp; copy) <span class="keywordflow">throw</span>()
00300 { 
00301   <span class="keywordflow">if</span> (&amp;copy != <span class="keyword">this</span>) {
00302     <a class="code" href="base.html#a19">Assert</a>(copy.rep &lt; RepEnd);
00303     <span class="keywordflow">if</span> (rep!=Mat) {
00304       <span class="keywordflow">if</span> (copy.rep!=Mat) {
00305         rep=copy.rep;
00306         v.reset(copy.v);
00307       }
00308       <span class="keywordflow">else</span> {
00309         rep=copy.rep;
00310         m = MatrixRef(NewObj <a class="code" href="classbase_1_1matrix.html">Matrix</a>(*copy.m));
00311       }
00312     }
00313     <span class="keywordflow">else</span> {
00314       <span class="keywordflow">if</span> (copy.rep!=Mat) {
00315         <span class="keyword">delete</span> &amp;(*m);
00316         rep=copy.rep;
00317         v.reset(copy.v);
00318       }
00319       <span class="keywordflow">else</span> {
00320         *m = *copy.m;
00321       }
00322     }
00323   }
00324   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00325 }
00326 
00327 
00328 <span class="keywordtype">void</span> Orient::setIdentity(Orient::Representation representation)
00329 {
00330   <a class="code" href="base.html#a19">Assert</a>(representation &lt; RepEnd)
00331   <span class="keywordflow">if</span> (representation == Quat) {
00332     <span class="keywordflow">if</span> (rep == Mat)
00333       <span class="keyword">delete</span> &amp;(*m);
00334     rep = Quat;
00335     Quat4 q; <span class="comment">// zero Quat</span>
00336     v.resize(4); 
00337     v[0]=q.v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>; v[1]=q.v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>; v[2]=q.v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>; v[3]=q.w;
00338   }
00339   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (representation == Mat) {
00340     <span class="keywordflow">if</span> (rep != Mat)
00341       m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00342     rep = Mat;
00343     (*m)(0,0) = 1; (*m)(0,1) = 0;  (*m)(0,2) = 0; <span class="comment">// identity</span>
00344     (*m)(1,0) = 0; (*m)(1,1) = 1;  (*m)(1,2) = 0;
00345     (*m)(2,0) = 0; (*m)(2,1) = 0;  (*m)(2,2) = 1;
00346   }
00347   <span class="keywordflow">else</span> {
00348     rep = representation;
00349     v.resize(3);
00350     v[0]=v[1]=v[2]=0;      
00351   }
00352     
00353 }
00354 
00355 
00356 <span class="keywordtype">void</span> Orient::setFromRotationComponent(<span class="keyword">const</span> Matrix4&amp; mt)
00357 {
00358   <span class="keywordflow">if</span> (rep != Mat) {
00359     m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00360     rep = Mat;
00361   }
00362   (*m)(0,0) = mt(1,1); (*m)(0,1) = mt(1,2);  (*m)(0,2) = mt(1,3); 
00363   (*m)(1,0) = mt(2,1); (*m)(1,1) = mt(2,2);  (*m)(1,2) = mt(2,3);
00364   (*m)(2,0) = mt(3,1); (*m)(2,1) = mt(3,2);  (*m)(2,2) = mt(3,3);
00365 }  
00366  
00367 <span class="comment"></span>
00368 <span class="comment">/// \todo consider trucky cases, like the fact that quats can have two representation for a single orientation (perhaps even covert all the reps to quats for comparison?)</span>
00369 <span class="comment">///       same with matrices etc</span>
00370 <span class="comment"></span><span class="keywordtype">bool</span> Orient::operator==(<span class="keyword">const</span> Orient&amp; o) <span class="keyword">const</span> <span class="keywordflow">throw</span>()
00371 {
00372   <span class="keywordflow">if</span> (&amp;o == <span class="keyword">this</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00373   
00374   <a class="code" href="base.html#a19">Assert</a>(o.rep &lt; RepEnd);
00375   
00376   <span class="keywordflow">if</span> (rep == o.rep) { <span class="comment">// fast path</span>
00377     <span class="keywordflow">if</span> (rep!=Mat) {
00378       <span class="keywordflow">if</span> (v.size() == o.v.size())
00379         <span class="keywordflow">return</span> v == o.v;
00380       <span class="keywordflow">else</span>
00381         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00382     }
00383     <span class="keywordflow">return</span> *m == *o.m;
00384   }
00385 
00386   <span class="comment">// try converting each to the other first</span>
00387   Orient tthis(*<span class="keyword">this</span>);
00388   <span class="keywordflow">try</span> {
00389     tthis.changeRep(o.rep);
00390     <span class="keywordflow">if</span> (o.rep!=Mat) 
00391       <span class="keywordflow">return</span> tthis.v == o.v;
00392     <span class="keywordflow">return</span> *tthis.m == *o.m;
00393   } <span class="keywordflow">catch</span> (std::exception&amp;) {}
00394   Orient to(o);
00395   <span class="keywordflow">try</span> {
00396     to.changeRep(rep);
00397     <span class="keywordflow">if</span> (rep!=Mat)
00398       <span class="keywordflow">return</span> v == to.v;
00399     <span class="keywordflow">return</span> *m == *to.m;
00400   } <span class="keywordflow">catch</span> (std::exception&amp;) {
00401     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00402   }
00403 }
00404 
00405 <span class="comment"></span>
00406 <span class="comment">/// \todo consider tricky cases, like the fact that quats can have two representation for a single orientation (perhaps even covert all the reps to quats for comparison?)</span>
00407 <span class="comment">///       same with matrices etc</span>
00408 <span class="comment"></span><span class="keywordtype">bool</span> Orient::equals(<span class="keyword">const</span> Orient&amp; o, Real epsilon) <span class="keyword">const</span> <span class="keywordflow">throw</span>()
00409 {
00410   <span class="keywordflow">if</span> (&amp;o == <span class="keyword">this</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00411   
00412   <a class="code" href="base.html#a19">Assert</a>(o.rep &lt; RepEnd);
00413   
00414   <span class="keywordflow">if</span> (rep == o.rep) { <span class="comment">// fast path</span>
00415     <span class="keywordflow">if</span> (rep!=Mat) {
00416       <span class="keywordflow">if</span> (v.size() == o.v.size())
00417         <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a61">base::equals</a>(v, o.v, epsilon);
00418       <span class="keywordflow">else</span>
00419         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00420     }
00421     <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a61">base::equals</a>(*m, *o.m, epsilon);
00422   }  
00423 
00424   <span class="comment">// try converting each to the other first</span>
00425   Orient tthis(*<span class="keyword">this</span>);
00426   <span class="keywordflow">try</span> {
00427     tthis.changeRep(o.rep);
00428     <span class="keywordflow">if</span> (o.rep!=Mat)
00429       <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a61">base::equals</a>(tthis.v, o.v, epsilon);
00430     <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a61">base::equals</a>(*(tthis.m), *o.m, epsilon);
00431   } <span class="keywordflow">catch</span> (std::exception&amp;) {}
00432   Orient to(o);
00433   <span class="keywordflow">try</span> {
00434     to.changeRep(rep);
00435     <span class="keywordflow">if</span> (rep!=Mat)
00436       <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a61">base::equals</a>(v, to.v, epsilon);
00437     <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a61">base::equals</a>(*m, *to.m, epsilon);
00438   } <span class="keywordflow">catch</span> (std::exception&amp;) {
00439     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00440   }
00441   
00442 }
00443 
00444 
00445 
00446 <span class="keywordtype">void</span> Orient::changeRep(Representation newRep)<span class="keyword"> const</span>
00447 <span class="keyword"></span>{
00448   <a class="code" href="base.html#a19">Assert</a>(rep &lt; RepEnd);
00449   <a class="code" href="base.html#a19">Assert</a>(newRep &lt; RepEnd);
00450   
00451   <span class="keywordflow">if</span> (rep == newRep) <span class="keywordflow">return</span>; <span class="comment">// no conversion necessary</span>
00452   
00453 
00454   <span class="comment">// convert from EulerIJKf  </span>
00455   <span class="keywordflow">if</span> (isEuler()) {
00456     
00457     <span class="keywordflow">if</span> (newRep == Quat) { <span class="comment">// to Quat</span>
00458       
00459       Quat4 qu;
00460       <a class="code" href="namespacebase.html#a5">Real</a> a[3], ti, tj, th, ci, cj, ch, si, sj, sh, cc, cs, sc, ss;
00461       Axis i,j,k,h;
00462       Parity n;
00463       Repetition s;
00464       Frame <a class="code" href="Makefile_8in.html#a5">f</a>;
00465       getRep(rep,i,j,k,h,n,s,f);
00466       <span class="keywordflow">if</span> (<a class="code" href="Makefile_8in.html#a5">f</a>==Rotating) {<a class="code" href="namespacebase.html#a5">Real</a> t = v[<a class="code" href="Globals_8h.html#a16">X</a>]; v[<a class="code" href="Globals_8h.html#a16">X</a>] = v[Z]; v[Z] = t;}
00467       <span class="keywordflow">if</span> (n==Odd) v[Y] = -v[Y];
00468       ti = v[<a class="code" href="Globals_8h.html#a16">X</a>]*0.5; tj = v[Y]*0.5; th = v[Z]*0.5;
00469       ci = Math::cos(ti);  cj = Math::cos(tj);  ch = Math::cos(th);
00470       si = Math::sin(ti);  sj = Math::sin(tj);  sh = Math::sin(th);
00471       cc = ci*ch; cs = ci*sh; sc = si*ch; ss = si*sh;
00472       <span class="keywordflow">if</span> (s==Repeating) {
00473           a[i] = cj*(cs + sc);  <span class="comment">// Could speed up with </span>
00474           a[j] = sj*(cc + ss);  <span class="comment">// trig identities. </span>
00475           a[k] = sj*(cs - sc);
00476           qu.w = cj*(cc - ss);
00477       } <span class="keywordflow">else</span> {
00478           a[i] = cj*sc - sj*cs;
00479           a[j] = cj*ss + sj*cc;
00480           a[k] = cj*cs - sj*sc;
00481           qu.w = cj*cc + sj*ss;
00482       }
00483       <span class="keywordflow">if</span> (n==Odd) a[j] = -a[j];
00484       qu.v.x = a[<a class="code" href="Globals_8h.html#a16">X</a>]; qu.v.y = a[Y]; qu.v.z = a[Z];
00485       v.resize(4);
00486       v[<a class="code" href="Globals_8h.html#a16">X</a>]=qu.v.x; v[Y]=qu.v.y; v[Z]=qu.v.z; v[W]=qu.w;
00487       rep=Quat;
00488       <span class="keywordflow">return</span>;
00489       
00490     }
00491     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newRep == Mat) { <span class="comment">// to Mat</span>
00492 
00493       m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00494       <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; <a class="code" href="general_8h.html#a54">M</a>(*this-&gt;m);
00495       
00496       <a class="code" href="namespacebase.html#a5">Real</a> ti, tj, th, ci, cj, ch, si, sj, sh, cc, cs, sc, ss;
00497       Axis i,j,k,h;
00498       Parity n;
00499       Repetition s;
00500       Frame <a class="code" href="Makefile_8in.html#a5">f</a>;
00501       getRep(rep,i,j,k,h,n,s,f);
00502       <span class="keywordflow">if</span> (<a class="code" href="Makefile_8in.html#a5">f</a>==Rotating) {<a class="code" href="namespacebase.html#a5">Real</a> t = v[<a class="code" href="Globals_8h.html#a16">X</a>]; v[<a class="code" href="Globals_8h.html#a16">X</a>] = v[Z]; v[Z] = t;}
00503       <span class="keywordflow">if</span> (n==Odd) { v[<a class="code" href="Globals_8h.html#a16">X</a>] = -v[<a class="code" href="Globals_8h.html#a16">X</a>]; v[Y] = -v[Y]; v[Z] = -v[Z];}
00504       ti = v[<a class="code" href="Globals_8h.html#a16">X</a>]; tj = v[Y]; th = v[Z];
00505       ci = Math::cos(ti); cj = Math::cos(tj); ch = Math::cos(th);
00506       si = Math::sin(ti); sj = Math::sin(tj); sh = Math::sin(th);
00507       cc = ci*ch; cs = ci*sh; sc = si*ch; ss = si*sh;
00508       <span class="keywordflow">if</span> (s==Repeating) {
00509           <a class="code" href="general_8h.html#a54">M</a>(i,i) = cj;     <a class="code" href="general_8h.html#a54">M</a>(i,j) =  sj*si;    <a class="code" href="general_8h.html#a54">M</a>(i,k) =  sj*ci;
00510           <a class="code" href="general_8h.html#a54">M</a>(j,i) = sj*sh;  <a class="code" href="general_8h.html#a54">M</a>(j,j) = -cj*ss+cc; <a class="code" href="general_8h.html#a54">M</a>(j,k) = -cj*cs-sc;
00511           <a class="code" href="general_8h.html#a54">M</a>(k,i) = -sj*ch; <a class="code" href="general_8h.html#a54">M</a>(k,j) =  cj*sc+cs; <a class="code" href="general_8h.html#a54">M</a>(k,k) =  cj*cc-ss;
00512       } <span class="keywordflow">else</span> {
00513           <a class="code" href="general_8h.html#a54">M</a>(i,i) = cj*ch; <a class="code" href="general_8h.html#a54">M</a>(i,j) = sj*sc-cs; <a class="code" href="general_8h.html#a54">M</a>(i,k) = sj*cc+ss;
00514           <a class="code" href="general_8h.html#a54">M</a>(j,i) = cj*sh; <a class="code" href="general_8h.html#a54">M</a>(j,j) = sj*ss+cc; <a class="code" href="general_8h.html#a54">M</a>(j,k) = sj*cs-sc;
00515           <a class="code" href="general_8h.html#a54">M</a>(k,i) = -sj;   <a class="code" href="general_8h.html#a54">M</a>(k,j) = cj*si;    <a class="code" href="general_8h.html#a54">M</a>(k,k) = cj*ci;
00516       }
00517       
00518       rep=Mat;
00519       <span class="keywordflow">return</span>;
00520     }
00521     <span class="keywordflow">else</span> {
00522       <span class="comment">// try to convert whatever to a Quat first</span>
00523       changeRep(Quat);
00524       changeRep(newRep);
00525       <span class="keywordflow">return</span>;
00526     }
00527     
00528   }
00529   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == Quat) { <span class="comment">// convert from Quat</span>
00530     
00531     <span class="keywordflow">if</span> (isEuler(newRep)) { <span class="comment">// to EulerIJKf</span>
00532       
00533       changeRep(Mat); <span class="comment">// via Mat</span>
00534       changeRep(newRep);
00535       <span class="keywordflow">return</span>;
00536       
00537     }
00538     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newRep == Mat) { <span class="comment">// to Mat</span>
00539       
00540       <a class="code" href="namespacebase.html#a5">Real</a> nq = v[0]*v[0]+v[1]*v[1]+v[2]*v[2]+v[3]*v[3];<span class="comment"></span>
00541 <span class="comment">      //!!! NB: the Graphics Gems impl. is identical except for not taking the srqt of nq opn the next line(!?)</span>
00542 <span class="comment"></span>      <a class="code" href="namespacebase.html#a5">Real</a> s = (nq&gt; <a class="code" href="namespacebase.html#a5">Real</a>(0))? (<a class="code" href="namespacebase.html#a5">Real</a>(2)/<a class="code" href="namespacebase.html#a63">base::sqrt</a>(nq)):<a class="code" href="namespacebase.html#a5">Real</a>(0); 
00543       
00544       <a class="code" href="namespacebase.html#a5">Real</a> xs = v[0]*s, ys = v[1]*s, zs = v[2]*s;
00545       <a class="code" href="namespacebase.html#a5">Real</a> wx = v[3]*xs,wy = v[3]*ys,wz = v[3]*zs;
00546       <a class="code" href="namespacebase.html#a5">Real</a> xx = v[0]*xs,xy = v[0]*ys,xz = v[0]*zs;
00547       <a class="code" href="namespacebase.html#a5">Real</a> yy = v[1]*ys,yz = v[1]*zs,zz = v[2]*zs;
00548 
00549       m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00550       
00551       (*m)(0,0) = <a class="code" href="namespacebase.html#a5">Real</a>(1) - (yy+zz);
00552       (*m)(1,0) = xy+wz;
00553       (*m)(2,0) = xz-wy;
00554       (*m)(0,1) = xy - wz;
00555       (*m)(1,1) = <a class="code" href="namespacebase.html#a5">Real</a>(1) - (xx+zz);
00556       (*m)(2,1) = yz+wx;
00557       (*m)(0,2) = xz+wy;
00558       (*m)(1,2) = yz-wx;
00559       (*m)(2,2) = <a class="code" href="namespacebase.html#a5">Real</a>(1) - (xx+yy);
00560       rep = Mat;
00561       <span class="keywordflow">return</span>;
00562     }
00563     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newRep == Quat) 
00564     {
00565       <span class="keywordflow">return</span>; <span class="comment">// nothing to do</span>
00566     }
00567     
00568   }
00569   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == Mat) { <span class="comment">// convert from Mat</span>
00570 
00571     <span class="keywordflow">if</span> (isEuler(newRep)) { <span class="comment">// to EulerIJKf</span>
00572 
00573       <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; <a class="code" href="general_8h.html#a54">M</a>(*this-&gt;m);
00574       v.resize(3);
00575       Axis i,j,k,h;
00576       Parity n;
00577       Repetition s;
00578       Frame <a class="code" href="Makefile_8in.html#a5">f</a>;
00579       getRep(newRep,i,j,k,h,n,s,f);
00580       <span class="keywordflow">if</span> (s==Repeating) {
00581           <a class="code" href="namespacebase.html#a5">Real</a> sy = Math::sqrt(<a class="code" href="general_8h.html#a54">M</a>(i,j)*<a class="code" href="general_8h.html#a54">M</a>(i,j) + <a class="code" href="general_8h.html#a54">M</a>(i,k)*<a class="code" href="general_8h.html#a54">M</a>(i,k));
00582           <span class="keywordflow">if</span> (sy &gt; 16*consts::minReal) {
00583               v[<a class="code" href="Globals_8h.html#a16">X</a>] = Math::atan2(<a class="code" href="general_8h.html#a54">M</a>(i,j), <a class="code" href="general_8h.html#a54">M</a>(i,k));
00584               v[Y] = Math::atan2(sy, <a class="code" href="general_8h.html#a54">M</a>(i,i));
00585               v[Z] = Math::atan2(<a class="code" href="general_8h.html#a54">M</a>(j,i), -<a class="code" href="general_8h.html#a54">M</a>(k,i));
00586           } <span class="keywordflow">else</span> {
00587               v[<a class="code" href="Globals_8h.html#a16">X</a>] = Math::atan2(-<a class="code" href="general_8h.html#a54">M</a>(j,k), <a class="code" href="general_8h.html#a54">M</a>(j,j));
00588               v[Y] = Math::atan2(sy, <a class="code" href="general_8h.html#a54">M</a>(i,i));
00589               v[Z] = 0;
00590           }
00591       } <span class="keywordflow">else</span> {
00592           <a class="code" href="namespacebase.html#a5">Real</a> cy = Math::sqrt(<a class="code" href="general_8h.html#a54">M</a>(i,i)*<a class="code" href="general_8h.html#a54">M</a>(i,i) + <a class="code" href="general_8h.html#a54">M</a>(j,i)*<a class="code" href="general_8h.html#a54">M</a>(j,i));
00593           <span class="keywordflow">if</span> (cy &gt; 16*consts::minReal) {
00594               v[<a class="code" href="Globals_8h.html#a16">X</a>] = Math::atan2(<a class="code" href="general_8h.html#a54">M</a>(k,j), <a class="code" href="general_8h.html#a54">M</a>(k,k));
00595               v[Y] = Math::atan2(-<a class="code" href="general_8h.html#a54">M</a>(k,i), cy);
00596               v[Z] = Math::atan2(<a class="code" href="general_8h.html#a54">M</a>(j,i), <a class="code" href="general_8h.html#a54">M</a>(i,i));
00597           } <span class="keywordflow">else</span> {
00598               v[<a class="code" href="Globals_8h.html#a16">X</a>] = Math::atan2(-<a class="code" href="general_8h.html#a54">M</a>(j,k), <a class="code" href="general_8h.html#a54">M</a>(j,j));
00599               v[Y] = Math::atan2(-<a class="code" href="general_8h.html#a54">M</a>(k,i), cy);
00600               v[Z] = 0;
00601           }
00602       }
00603       <span class="keywordflow">if</span> (n==Odd) {v[<a class="code" href="Globals_8h.html#a16">X</a>] = -v[<a class="code" href="Globals_8h.html#a16">X</a>]; v[Y] = - v[Y]; v[Z] = -v[Z];}
00604       <span class="keywordflow">if</span> (<a class="code" href="Makefile_8in.html#a5">f</a>==Rotating) {<a class="code" href="namespacebase.html#a5">Real</a> t = v[<a class="code" href="Globals_8h.html#a16">X</a>]; v[<a class="code" href="Globals_8h.html#a16">X</a>] = v[Z]; v[Z] = t;}
00605 
00606       rep=newRep;
00607       <span class="keywordflow">return</span>;      
00608       
00609     }
00610     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newRep == Quat) { <span class="comment">// to Quat</span>
00611 
00612       <span class="comment">// Algorithm is from the Matrix and Quaternion FAQ</span>
00613       <span class="comment">//  ( currently http://www.cs.ualberta.ca/~andreas/math/matrfaq_latest.html )</span>
00614       <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; m(*this-&gt;m);
00615       v.resize(4);
00616   
00617       <a class="code" href="namespacebase.html#a5">Real</a> tr = 1 + m(0,0) + m(1,1) + m(2,2);
00618       <span class="keywordflow">if</span> (tr &gt; consts::epsilon) {
00619         <a class="code" href="namespacebase.html#a5">Real</a> s = <a class="code" href="namespacebase.html#a63">sqrt</a>(tr)*2.0;
00620         v[0] = (m(2,1) - m(1,2))/s;
00621         v[1] = (m(0,2) - m(2,0))/s;
00622         v[2] = (m(1,0) - m(0,1))/s;
00623         v[3] = 0.25*s;
00624       } 
00625       <span class="keywordflow">else</span> {
00626         
00627         <span class="keywordflow">if</span> ((m(0,0) &gt; m(1,1)) &amp;&amp; (m(0,0) &gt; m(2,2))) {
00628           <a class="code" href="namespacebase.html#a5">Real</a> s = <a class="code" href="namespacebase.html#a63">sqrt</a>(1+m(0,0)-m(1,1)-m(2,2))*2.0;
00629           v[0] = 0.25*s;
00630           v[1] = (m(1,0)+m(0,1))/s;
00631           v[2] = (m(0,2)+m(2,0))/s;
00632           v[3] = (m(2,1)-m(1,2))/s;
00633         }
00634         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m(1,1) &gt; m(2,2)) {
00635           <a class="code" href="namespacebase.html#a5">Real</a> s = <a class="code" href="namespacebase.html#a63">sqrt</a>(1+m(1,1)-m(0,0)-m(2,2))*2.0;
00636           v[0] = (m(1,0)+m(0,1))/s;
00637           v[1] = 0.25*s;
00638           v[2] = (m(2,1)+m(1,2))/s;
00639           v[3] = (m(0,2)-m(2,0))/s;
00640         }
00641         <span class="keywordflow">else</span> {
00642           <a class="code" href="namespacebase.html#a5">Real</a> s = <a class="code" href="namespacebase.html#a63">sqrt</a>(1+m(2,2)-m(0,0)-m(1,1))*2.0;
00643           v[0] = (m(0,2)+m(2,0))/s;
00644           v[1] = (m(2,1)+m(1,2))/s;
00645           v[2] = 0.25*s;
00646           v[3] = (m(1,0)-m(0,1))/s;
00647         }
00648       }
00649       
00650       rep=Quat;
00651       <span class="keywordflow">return</span>;
00652     }
00653     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newRep == Mat) { 
00654       <span class="keywordflow">return</span>; <span class="comment">// nothing to do</span>
00655     }
00656 
00657 
00658   }
00659 
00660   <span class="keywordflow">throw</span> std::runtime_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"conversion from "</span>+representationString(rep)+<span class="stringliteral">" to "</span>+representationString(newRep)+<span class="stringliteral">" unsupported"</span>));
00661 
00662 }
00663         
00664 
00665 
00666 
00667 
00668 <a class="code" href="classbase_1_1matrix.html">Matrix</a> Orient::getBinv()<span class="keyword"> const</span>
00669 <span class="keyword"></span>{
00670   <a class="code" href="classbase_1_1matrix.html">Matrix</a> Binv;
00671 
00672   <span class="keywordflow">if</span> (rep == EulerRPY) {
00673 
00674     <span class="comment">// implementation taken from IKORv2 Euler_to_Velocities() function</span>
00675     Binv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa15">resize</a>(3,3);
00676 
00677     <span class="comment">//const Real&amp; alpha(v[0]); </span>
00678     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a>&amp; beta(v[1]);  
00679     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a>&amp; gamma(v[2]); 
00680     <a class="code" href="namespacebase.html#a5">Real</a> cb = Math::cos(beta);
00681     <a class="code" href="namespacebase.html#a5">Real</a> cg = Math::cos(gamma);
00682     <a class="code" href="namespacebase.html#a5">Real</a> sb = Math::sin(beta);
00683     <a class="code" href="namespacebase.html#a5">Real</a> sg = Math::sin(gamma);
00684 
00685     Binv(0,0) = cg*cb; Binv(0,1) = -sg; Binv(0,2) = 0;
00686     Binv(1,0) = sg*cb; Binv(1,1) = cg;  Binv(1,2) = 0;
00687     Binv(2,0) = -sb;   Binv(2,1) = 0;   Binv(2,2) = 1;
00688   }
00689   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rep == Quat) {
00690 
00691     Binv.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa15">resize</a>(3,4);
00692     
00693     <span class="comment">// this comes from Brian Mirtich's thesis (Univ. of California, Berkeley, 1996, p235), </span>
00694     <span class="comment">// !!! check it is correct (as Brian doesn't use the B notation, compare with</span>
00695     <span class="comment">//     a book that does!)</span>
00696     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a>&amp; qx(v[0]);
00697     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a>&amp; qy(v[1]);
00698     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a>&amp; qz(v[2]);
00699     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a>&amp; qw(v[3]); <span class="comment">// scalar component</span>
00700     
00701     Binv(0,0) = -qx; Binv(0,1) = +qw; Binv(0,2) = +qz; Binv(0,3) = -qy;
00702     Binv(1,0) = -qy; Binv(1,1) = -qz; Binv(1,2) = +qw; Binv(1,3) = +qx;
00703     Binv(2,0) = -qz; Binv(2,1) = +qy; Binv(2,2) = -qx; Binv(2,3) = +qw;
00704     Binv = 2.0*Binv;
00705     
00706   }
00707   <span class="keywordflow">else</span> {
00708     <span class="keywordflow">throw</span> std::runtime_error(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"Binv generation from current orientation representation unsupported"</span>));
00709   }
00710 
00711   <span class="keywordflow">return</span> Binv;
00712 }
00713 
00714 
00715 
00716 Orient Orient::interpolate(<span class="keyword">const</span> Orient&amp; lower, <span class="keyword">const</span> Orient&amp; upper, Real t) 
00717 {
00718   Math::bound(t, 0.0, 1.0);
00719 
00720   <span class="keywordflow">if</span> (t == 0.0) <span class="keywordflow">return</span> lower;
00721   <span class="keywordflow">if</span> (t == 1.0) <span class="keywordflow">return</span> upper;
00722 
00723   <span class="comment">// we convert both orientations to Quats and use the Quat4::interpolate() method</span>
00724   <span class="comment">//  which uses SLERP (Spherical Linear intERPolation)</span>
00725   Orient ofrom(lower); ofrom.changeRep(Quat); <span class="comment">// copy &amp; change rep</span>
00726   Orient oto(upper); oto.changeRep(Quat);
00727   Quat4 from(ofrom[0], ofrom[1], ofrom[2], ofrom[3]); <span class="comment">// convert to Quat4</span>
00728   Quat4 to(oto[0], oto[1], oto[2], oto[3]);
00729 
00730   Quat4 interp(Quat4::interpolate(from,to,t)); <span class="comment">// SLERP</span>
00731 
00732   <span class="keywordflow">return</span> Orient(interp);
00733 }
00734 
00735 
00736 Orient&amp; Orient::invert()
00737 {
00738   <span class="keywordflow">if</span> (rep == Mat) {
00739     Matrix3 m3( base::toMatrix3(*m) );
00740     m3.invert();
00741     *m = <a class="code" href="namespacebase.html#a105">base::fromMatrix3</a>(m3);
00742   }
00743   <span class="keywordflow">else</span> {
00744     Quat4 q( getQuat4() );
00745     q.invert();
00746     *<span class="keyword">this</span> = q;
00747   }
00748   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00749 }
00750 
00751 
00752 
00753 
00754 <span class="keywordtype">void</span> Orient::serialize(Serializer&amp; s)
00755 {
00756   Representation oldrep(rep);
00757   s(rep,<span class="stringliteral">"rep"</span>);
00758 
00759   <span class="keywordflow">if</span> (s.isOutput()) {
00760     <span class="keywordflow">if</span> (rep!=Mat)
00761       s(v,<span class="stringliteral">"v"</span>);
00762     <span class="keywordflow">else</span>
00763       s(*m,<span class="stringliteral">"m"</span>);
00764   }
00765   <span class="keywordflow">else</span> {
00766     <span class="keywordflow">if</span> (rep!=Mat) {
00767       <span class="keywordflow">if</span> (oldrep==Mat) {
00768         <span class="keyword">delete</span> &amp;(*m);
00769         m=MatrixRef(0);
00770       }
00771       s(v,<span class="stringliteral">"v"</span>);
00772     }
00773     <span class="keywordflow">else</span> {
00774       <span class="keywordflow">if</span> (oldrep!=Mat)
00775         m = MatrixRef(NewObj <a class="code" href="namespacebase.html#a18">Matrix</a>(3,3));
00776       s(*m,<span class="stringliteral">"m"</span>);
00777     }
00778   }
00779   <a class="code" href="base.html#a19">Assert</a>(rep &lt; RepEnd);
00780 }
00781 
00782 
00783 
00784 
00785 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:08 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
