<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/SVD.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/SVD.cpp</h1><a href="SVD_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: SVD.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.16 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 
00026 <span class="comment">/*</span>
00027 <span class="comment"> *</span>
00028 <span class="comment"> * Singular Value Decomposition of a Matrix</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> * Currently uses the code from Numerical Recipies in C</span>
00031 <span class="comment"> */</span>
00032 
00033 
00034  
00035 <span class="preprocessor">#include &lt;<a class="code" href="SVD.html">base/SVD</a>&gt;</span>
00036 
00037 <span class="preprocessor">#include &lt;<a class="code" href="Math.html">base/Math</a>&gt;</span>
00038 
00039 <span class="keyword">using</span> <a class="code" href="classbase_1_1SVD.html">base::SVD</a>;
00040 
00041 <span class="keyword">using</span> <a class="code" href="classbase_1_1Math.html">base::Math</a>;
00042 <span class="keyword">using</span> <a class="code" href="classbase_1_1matrix.html">base::Matrix</a>;
00043 <span class="keyword">using</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>;
00044 
00045 
00046 
00047 <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a> SVD::maxCondition = 1e100;
00048 <span class="keyword">const</span> <a class="code" href="namespacebase.html#a5">Real</a> SVD::minSingValue = 1e-6;
00049 
<a name="l00050"></a><a class="code" href="SVD_8cpp.html#a3">00050</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="nrutil_8h.html#a6">FMIN</a>(<span class="keywordtype">float</span> a, <span class="keywordtype">float</span> b) { <span class="keywordflow">return</span> a&lt;b?a:b; }
<a name="l00051"></a><a class="code" href="SVD_8cpp.html#a4">00051</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="nrutil_8h.html#a5">FMAX</a>(<span class="keywordtype">float</span> a, <span class="keywordtype">float</span> b) { <span class="keywordflow">return</span> a&gt;b?a:b; }
<a name="l00052"></a><a class="code" href="SVD_8cpp.html#a5">00052</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="nrutil_8h.html#a10">IMIN</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a&lt;b?a:b; }
<a name="l00053"></a><a class="code" href="SVD_8cpp.html#a6">00053</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="nrutil_8h.html#a9">IMAX</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a&gt;b?a:b; }
00054 
<a name="l00055"></a><a class="code" href="SVD_8cpp.html#a7">00055</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="nrutil_8h.html#a1">SQR</a>(<span class="keywordtype">float</span> a) { <span class="keywordflow">return</span> (a==0.0)?0.0:a*a; }
00056 
00057 
<a name="l00058"></a><a class="code" href="SVD_8cpp.html#a8">00058</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="keywordtype">char</span> error_text[])
00059 { <span class="keywordflow">throw</span> std::runtime_error(<a class="code" href="base.html#a15">Exception</a>(String(error_text))); }
00060 
00061 
00062 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00063 
00064 <span class="preprocessor">#include &lt;stdio.h&gt;</span>  
00065 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00066 <span class="preprocessor">#include &lt;math.h&gt;</span>
00067   
00068   
<a name="l00069"></a><a class="code" href="SVD_8cpp.html#a0">00069</a> <span class="preprocessor">#define NR_END 1</span>
<a name="l00070"></a><a class="code" href="SVD_8cpp.html#a1">00070</a> <span class="preprocessor"></span><span class="preprocessor">#define FREE_ARG char*</span>
00071 <span class="preprocessor"></span>  
00072 
<a name="l00073"></a><a class="code" href="SVD_8cpp.html#a2">00073</a> <span class="preprocessor">#define SIGN(a,b) ((b) &gt;= 0.0 ? fabs(a) : -fabs(a))</span>
00074 <span class="preprocessor"></span>
00075 
00076 
<a name="l00077"></a><a class="code" href="SVD_8cpp.html#a9">00077</a> <span class="keywordtype">float</span> *<a class="code" href="nrutil_8h.html#a14">vector</a>(<span class="keywordtype">long</span> nl, <span class="keywordtype">long</span> nh)
00078 <span class="comment">/* allocate a float vector with subscript range v[nl..nh] */</span>
00079 {
00080         <span class="keywordtype">float</span> *v;
00081 
00082         v=(<span class="keywordtype">float</span> *)malloc((size_t) ((nh-nl+1+<a class="code" href="SVD_8cpp.html#a0">NR_END</a>)*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));
00083         <span class="keywordflow">if</span> (!v) <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"allocation failure in vector()"</span>);
00084         <span class="keywordflow">return</span> v-nl+<a class="code" href="SVD_8cpp.html#a0">NR_END</a>;
00085 }
00086 
<a name="l00087"></a><a class="code" href="SVD_8cpp.html#a10">00087</a> <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a30">free_matrix</a>(<span class="keywordtype">float</span> **m, <span class="keywordtype">long</span> nrl, <span class="keywordtype">long</span> nrh, <span class="keywordtype">long</span> ncl, <span class="keywordtype">long</span> nch)
00088 <span class="comment">/* free a float matrix allocated by matrix() */</span>
00089 {
00090         free((<a class="code" href="SVD_8cpp.html#a1">FREE_ARG</a>) (m[nrl]+ncl-<a class="code" href="SVD_8cpp.html#a0">NR_END</a>));
00091         free((<a class="code" href="SVD_8cpp.html#a1">FREE_ARG</a>) (m+nrl-<a class="code" href="SVD_8cpp.html#a0">NR_END</a>));
00092 }
00093 
00094 
00095 
<a name="l00096"></a><a class="code" href="SVD_8cpp.html#a11">00096</a> <span class="keywordtype">void</span> <a class="code" href="nrutil_8h.html#a25">free_vector</a>(<span class="keywordtype">float</span> *v, <span class="keywordtype">long</span> nl, <span class="keywordtype">long</span> nh)
00097 <span class="comment">/* free a float vector allocated with vector() */</span>
00098 {
00099         free((<a class="code" href="SVD_8cpp.html#a1">FREE_ARG</a>) (v+nl-<a class="code" href="SVD_8cpp.html#a0">NR_END</a>));
00100 }
00101 
00102 
00103 
<a name="l00104"></a><a class="code" href="SVD_8cpp.html#a12">00104</a> <span class="keywordtype">float</span> **<a class="code" href="nrutil_8h.html#a15">matrix</a>(<span class="keywordtype">long</span> nrl, <span class="keywordtype">long</span> nrh, <span class="keywordtype">long</span> ncl, <span class="keywordtype">long</span> nch)
00105 <span class="comment">/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */</span>
00106 {
00107         <span class="keywordtype">long</span> i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
00108         <span class="keywordtype">float</span> **m;
00109 
00110         <span class="comment">/* allocate pointers to rows */</span>
00111         m=(<span class="keywordtype">float</span> **) malloc((size_t)((nrow+<a class="code" href="SVD_8cpp.html#a0">NR_END</a>)*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>*)));
00112         <span class="keywordflow">if</span> (!m) <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"allocation failure 1 in matrix()"</span>);
00113         m += <a class="code" href="SVD_8cpp.html#a0">NR_END</a>;
00114         m -= nrl;
00115 
00116         <span class="comment">/* allocate rows and set pointers to them */</span>
00117         m[nrl]=(<span class="keywordtype">float</span> *) malloc((size_t)((nrow*ncol+<a class="code" href="SVD_8cpp.html#a0">NR_END</a>)*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));
00118         <span class="keywordflow">if</span> (!m[nrl]) <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"allocation failure 2 in matrix()"</span>);
00119         m[nrl] += <a class="code" href="SVD_8cpp.html#a0">NR_END</a>;
00120         m[nrl] -= ncl;
00121 
00122         <span class="keywordflow">for</span>(i=nrl+1;i&lt;=nrh;i++) m[i]=m[i-1]+ncol;
00123 
00124         <span class="comment">/* return pointer to array of pointers to rows */</span>
00125         <span class="keywordflow">return</span> m;
00126 }
00127 
00128 
<a name="l00129"></a><a class="code" href="SVD_8cpp.html#a13">00129</a> <span class="keywordtype">float</span> <a class="code" href="SVD_8cpp.html#a13">pythag</a>(<span class="keywordtype">float</span> a, <span class="keywordtype">float</span> b)
00130 {
00131         <span class="keywordtype">float</span> absa, absb;
00132         absa=fabs(a);
00133         absb=fabs(b);
00134         <span class="keywordflow">if</span>(absa&gt;absb)
00135                 <span class="keywordflow">return</span>(absa*sqrt(1.0+<a class="code" href="nrutil_8h.html#a1">SQR</a>(absb/absa)));
00136         <span class="keywordflow">else</span>
00137                 <span class="keywordflow">return</span>(absb==0.0 ? 0.0 : absb*sqrt(1.0+<a class="code" href="nrutil_8h.html#a1">SQR</a>(absa/absb)));
00138 }
00139 
00140 
00141 
00142 <span class="comment">// the actual SVD routine</span>
00143 
<a name="l00144"></a><a class="code" href="SVD_8cpp.html#a14">00144</a> <span class="keywordtype">void</span> <a class="code" href="matrix_8h.html#a6">svdcmp</a>(<span class="keywordtype">float</span> **a, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n, <span class="keywordtype">float</span> w[], <span class="keywordtype">float</span> **v)
00145 {
00146         <span class="keywordtype">float</span> <a class="code" href="SVD_8cpp.html#a13">pythag</a>(<span class="keywordtype">float</span> a, <span class="keywordtype">float</span> b);
00147         <span class="keywordtype">int</span> flag,i,its,j,jj,k,l,nm, front, back;
00148         <span class="keywordtype">float</span> anorm,c,<a class="code" href="Makefile_8in.html#a5">f</a>,g,h,s,scale,x,y,z,*rv1, *rv2, tol;
00149         <span class="keywordtype">float</span> **ut, **vt;
00150 
00151         vt=<a class="code" href="nrutil_8h.html#a15">matrix</a>(1,n,1,n);
00152         ut=<a class="code" href="nrutil_8h.html#a15">matrix</a>(1,m,1,n);
00153 
00154         tol=(<span class="keywordtype">float</span>)(1e-6);
00155 
00156         rv1=<a class="code" href="nrutil_8h.html#a14">vector</a>(1,n);
00157         rv2=<a class="code" href="nrutil_8h.html#a14">vector</a>(1,n);
00158         g=scale=anorm=0.0;
00159         <span class="keywordflow">for</span> (i=1;i&lt;=n;i++) {
00160                 l=i+1;
00161                 rv1[i]=scale*g;
00162                 g=s=scale=0.0;
00163                 <span class="keywordflow">if</span> (i &lt;= m) {
00164                         <span class="keywordflow">for</span> (k=i;k&lt;=m;k++) 
00165                                 scale += fabs(a[k][i]);
00166                         <span class="keywordflow">if</span> (scale) {
00167                                 <span class="keywordflow">for</span> (k=i;k&lt;=m;k++) {
00168                                         a[k][i] /= scale;
00169                                         s += a[k][i]*a[k][i];
00170                                 }
00171                                 <a class="code" href="Makefile_8in.html#a5">f</a>=a[i][i];
00172                                 g = -<a class="code" href="SVD_8cpp.html#a2">SIGN</a>(sqrt(s),<a class="code" href="Makefile_8in.html#a5">f</a>);
00173                                 h=<a class="code" href="Makefile_8in.html#a5">f</a>*g-s;
00174                                 a[i][i]=<a class="code" href="Makefile_8in.html#a5">f</a>-g;
00175                                 <span class="keywordflow">for</span> (j=l;j&lt;=n;j++) {
00176                                         <span class="keywordflow">for</span> (s=0.0,k=i;k&lt;=m;k++) s += a[k][i]*a[k][j];
00177                                         <a class="code" href="Makefile_8in.html#a5">f</a>=s/h;
00178                                         <span class="keywordflow">for</span> (k=i;k&lt;=m;k++) a[k][j] += <a class="code" href="Makefile_8in.html#a5">f</a>*a[k][i];
00179                                 }
00180                                 <span class="keywordflow">for</span> (k=i;k&lt;=m;k++) a[k][i] *= scale;
00181                         }
00182                 }
00183                 w[i]=scale *g;
00184                 g=s=scale=0.0;
00185                 <span class="keywordflow">if</span> (i &lt;= m &amp;&amp; i != n) {
00186                         <span class="keywordflow">for</span> (k=l;k&lt;=n;k++) scale += fabs(a[i][k]);
00187                         <span class="keywordflow">if</span> (scale) {
00188                                 <span class="keywordflow">for</span> (k=l;k&lt;=n;k++) {
00189                                         a[i][k] /= scale;
00190                                         s += a[i][k]*a[i][k];
00191                                 }
00192                                 <a class="code" href="Makefile_8in.html#a5">f</a>=a[i][l];
00193                                 g = -<a class="code" href="SVD_8cpp.html#a2">SIGN</a>(sqrt(s),<a class="code" href="Makefile_8in.html#a5">f</a>);
00194                                 h=<a class="code" href="Makefile_8in.html#a5">f</a>*g-s;
00195                                 a[i][l]=<a class="code" href="Makefile_8in.html#a5">f</a>-g;
00196                                 <span class="keywordflow">for</span> (k=l;k&lt;=n;k++) rv1[k]=a[i][k]/h;
00197                                 <span class="keywordflow">for</span> (j=l;j&lt;=m;j++) {
00198                                         <span class="keywordflow">for</span> (s=0.0,k=l;k&lt;=n;k++) s += a[j][k]*a[i][k];
00199                                         <span class="keywordflow">for</span> (k=l;k&lt;=n;k++) a[j][k] += s*rv1[k];
00200                                 }
00201                                 <span class="keywordflow">for</span> (k=l;k&lt;=n;k++) a[i][k] *= scale;
00202                         }
00203                 }
00204                 anorm=<a class="code" href="nrutil_8h.html#a5">FMAX</a>(anorm,(fabs(w[i])+fabs(rv1[i])));
00205         }
00206         <span class="keywordflow">for</span> (i=n;i&gt;=1;i--) {
00207                 <span class="keywordflow">if</span> (i &lt; n) {
00208                         <span class="keywordflow">if</span> (g) {
00209                                 <span class="keywordflow">for</span> (j=l;j&lt;=n;j++)
00210                                         v[j][i]=(a[i][j]/a[i][l])/g;
00211                                 <span class="keywordflow">for</span> (j=l;j&lt;=n;j++) {
00212                                         <span class="keywordflow">for</span> (s=0.0,k=l;k&lt;=n;k++) s += a[i][k]*v[k][j];
00213                                         <span class="keywordflow">for</span> (k=l;k&lt;=n;k++) v[k][j] += s*v[k][i];
00214                                 }
00215                         }
00216                         <span class="keywordflow">for</span> (j=l;j&lt;=n;j++) v[i][j]=v[j][i]=0.0;
00217                 }
00218                 v[i][i]=1.0;
00219                 g=rv1[i];
00220                 l=i;
00221         }
00222         <span class="keywordflow">for</span> (i=<a class="code" href="nrutil_8h.html#a10">IMIN</a>(m,n);i&gt;=1;i--) {
00223                 l=i+1;
00224                 g=w[i];
00225                 <span class="keywordflow">for</span> (j=l;j&lt;=n;j++) a[i][j]=0.0;
00226                 <span class="keywordflow">if</span> (g) {
00227                         g=1.0/g;
00228                         <span class="keywordflow">for</span> (j=l;j&lt;=n;j++) {
00229                                 <span class="keywordflow">for</span> (s=0.0,k=l;k&lt;=m;k++) s += a[k][i]*a[k][j];
00230                                 <a class="code" href="Makefile_8in.html#a5">f</a>=(s/a[i][i])*g;
00231                                 <span class="keywordflow">for</span> (k=i;k&lt;=m;k++) a[k][j] += <a class="code" href="Makefile_8in.html#a5">f</a>*a[k][i];
00232                         }
00233                         <span class="keywordflow">for</span> (j=i;j&lt;=m;j++) a[j][i] *= g;
00234                 } <span class="keywordflow">else</span> <span class="keywordflow">for</span> (j=i;j&lt;=m;j++) a[j][i]=0.0;
00235                 ++a[i][i];
00236         }
00237         <span class="keywordflow">for</span> (k=n;k&gt;=1;k--) {
00238                 <span class="keywordflow">for</span> (its=1;its&lt;=30;its++) {
00239                         flag=1;
00240                         <span class="keywordflow">for</span> (l=k;l&gt;=1;l--) {
00241                                 nm=l-1;
00242                                 <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)(fabs(rv1[l])+anorm) == anorm) {
00243                                         flag=0;
00244                                         <span class="keywordflow">break</span>;
00245                                 }
00246                                 <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)(fabs(w[nm])+anorm) == anorm) <span class="keywordflow">break</span>;
00247                         }
00248                         <span class="keywordflow">if</span> (flag) {
00249                                 c=0.0;
00250                                 s=1.0;
00251                                 <span class="keywordflow">for</span> (i=l;i&lt;=k;i++) {
00252                                         <a class="code" href="Makefile_8in.html#a5">f</a>=s*rv1[i];
00253                                         rv1[i]=c*rv1[i];
00254                                         <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)(fabs(<a class="code" href="Makefile_8in.html#a5">f</a>)+anorm) == anorm) <span class="keywordflow">break</span>;
00255                                         g=w[i];
00256                                         h=<a class="code" href="SVD_8cpp.html#a13">pythag</a>(<a class="code" href="Makefile_8in.html#a5">f</a>,g);
00257                                         w[i]=h;
00258                                         h=1.0/h;
00259                                         c=g*h;
00260                                         s = -<a class="code" href="Makefile_8in.html#a5">f</a>*h;
00261                                         <span class="keywordflow">for</span> (j=1;j&lt;=m;j++) {
00262                                                 y=a[j][nm];
00263                                                 z=a[j][i];
00264                                                 a[j][nm]=y*c+z*s;
00265                                                 a[j][i]=z*c-y*s;
00266                                         }
00267                                 }
00268                         }
00269                         z=w[k];
00270                         <span class="keywordflow">if</span> (l == k) {
00271                                 <span class="keywordflow">if</span> (z &lt; 0.0) {
00272                                         w[k] = -z;
00273                                         <span class="keywordflow">for</span> (j=1;j&lt;=n;j++) v[j][k] = -v[j][k];
00274                                 }
00275                                 <span class="keywordflow">break</span>;
00276                         }
00277                         <span class="keywordflow">if</span> (its == 30) <a class="code" href="nrutil_8h.html#a13">nrerror</a>(<span class="stringliteral">"no convergence in 30 svdcmp iterations"</span>);
00278                         x=w[l];
00279                         nm=k-1;
00280                         y=w[nm];
00281                         g=rv1[nm];
00282                         h=rv1[k];
00283                         <a class="code" href="Makefile_8in.html#a5">f</a>=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
00284                         g=<a class="code" href="SVD_8cpp.html#a13">pythag</a>(<a class="code" href="Makefile_8in.html#a5">f</a>,1.0);
00285                         <a class="code" href="Makefile_8in.html#a5">f</a>=((x-z)*(x+z)+h*((y/(<a class="code" href="Makefile_8in.html#a5">f</a>+<a class="code" href="SVD_8cpp.html#a2">SIGN</a>(g,<a class="code" href="Makefile_8in.html#a5">f</a>)))-h))/x;
00286                         c=s=1.0;
00287                         <span class="keywordflow">for</span> (j=l;j&lt;=nm;j++) {
00288                                 i=j+1;
00289                                 g=rv1[i];
00290                                 y=w[i];
00291                                 h=s*g;
00292                                 g=c*g;
00293                                 z=<a class="code" href="SVD_8cpp.html#a13">pythag</a>(<a class="code" href="Makefile_8in.html#a5">f</a>,h);
00294                                 rv1[j]=z;
00295                                 c=<a class="code" href="Makefile_8in.html#a5">f</a>/z;
00296                                 s=h/z;
00297                                 <a class="code" href="Makefile_8in.html#a5">f</a>=x*c+g*s;
00298                                 g = g*c-x*s;
00299                                 h=y*s;
00300                                 y *= c;
00301                                 <span class="keywordflow">for</span> (jj=1;jj&lt;=n;jj++) {
00302                                         x=v[jj][j];
00303                                         z=v[jj][i];
00304                                         v[jj][j]=x*c+z*s;
00305                                         v[jj][i]=z*c-x*s;
00306                                 }
00307                                 z=<a class="code" href="SVD_8cpp.html#a13">pythag</a>(<a class="code" href="Makefile_8in.html#a5">f</a>,h);
00308                                 w[j]=z;
00309                                 <span class="keywordflow">if</span> (z) {
00310                                         z=1.0/z;
00311                                         c=<a class="code" href="Makefile_8in.html#a5">f</a>*z;
00312                                         s=h*z;
00313                                 }
00314                                 <a class="code" href="Makefile_8in.html#a5">f</a>=c*g+s*y;
00315                                 x=c*y-s*g;
00316                                 <span class="keywordflow">for</span> (jj=1;jj&lt;=m;jj++) {
00317                                         y=a[jj][j];
00318                                         z=a[jj][i];
00319                                         a[jj][j]=y*c+z*s;
00320                                         a[jj][i]=z*c-y*s;
00321                                 }
00322                         }
00323                         rv1[l]=0.0;
00324                         rv1[k]=<a class="code" href="Makefile_8in.html#a5">f</a>;
00325                         w[k]=x;
00326                 }
00327         }
00328 
00329 
00330 
00331         front=1;
00332         back=n;
00333         <span class="keywordflow">for</span>(i=1;i&lt;=n;i++)
00334         {
00335                 <span class="keywordflow">if</span>(w[i]&lt;tol)
00336                 {
00337                         rv1[back]=i;
00338                         back--;
00339                 }
00340                 <span class="keywordflow">else</span>
00341                 {
00342                         rv1[front]=i;
00343                         front++;
00344                 }
00345         }
00346 
00347         <span class="keywordflow">for</span>(i=1;i&lt;=n;i++)
00348         {
00349                 rv2[i]=w[(<span class="keywordtype">int</span>)(rv1[i])];
00350                 <span class="keywordflow">for</span>(j=1;j&lt;=n;j++)
00351                         vt[j][i]=v[j][(<span class="keywordtype">int</span>)(rv1[i])];
00352                 <span class="keywordflow">for</span>(j=1;j&lt;=m;j++)
00353                         ut[j][i]=a[j][(<span class="keywordtype">int</span>)(rv1[i])];
00354         }
00355 
00356         <span class="keywordflow">for</span>(i=1;i&lt;=n;i++)
00357         {
00358                 w[i]=rv2[i];
00359                 <span class="keywordflow">for</span>(j=1;j&lt;=n;j++)
00360                         v[j][i]=vt[j][i];
00361                 <span class="keywordflow">for</span>(j=1;j&lt;=m;j++)
00362                         a[j][i]=ut[j][i];
00363         }
00364 
00365         <a class="code" href="nrutil_8h.html#a25">free_vector</a>(rv1,1,n);
00366         <a class="code" href="nrutil_8h.html#a25">free_vector</a>(rv2,1,n);
00367         <a class="code" href="nrutil_8h.html#a30">free_matrix</a>(vt,1,n,1,m);
00368         <a class="code" href="nrutil_8h.html#a30">free_matrix</a>(ut,1,m,1,n);
00369 
00370 }
00371 
00372 
00373 
00374 
00375 } <span class="comment">// extern C</span>
00376 
00377 
00378 
00379 SVD::SVD(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a> &amp;A)
00380   : <a class="code" href="general_8h.html#a54">M</a>(A.rows()), <a class="code" href="general_8h.html#a53">N</a>(A.cols())
00381 {
00382   <span class="keywordtype">float</span> **v, *w, **u;
00383 
00384   <span class="comment">// convert A to an NR matrix (put in u, which will be replaced)</span>
00385   v=::matrix(1,<a class="code" href="general_8h.html#a53">N</a>,1,<a class="code" href="general_8h.html#a53">N</a>);  <span class="comment">// v matrix</span>
00386   u=::matrix(1,<a class="code" href="general_8h.html#a54">M</a>,1,<a class="code" href="general_8h.html#a53">N</a>);  <span class="comment">// u matrix has extra columns of zeros</span>
00387   w=::vector(1,<a class="code" href="general_8h.html#a53">N</a>);      <span class="comment">// vector of singular values</span>
00388   
00389   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;<a class="code" href="general_8h.html#a54">M</a>; r++)
00390     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt;<a class="code" href="general_8h.html#a53">N</a>; c++)
00391       u[r+1][c+1] = float( A(r,c) ); <span class="comment">// NB: possible loss of precision (Real != float necesarily)</span>
00392   
00393   <span class="comment">// call NR SVD</span>
00394   <a class="code" href="matrix_8h.html#a6">svdcmp</a>(u, <span class="keywordtype">int</span>(M), <span class="keywordtype">int</span>(N), w, v);
00395   
00396   <span class="comment">// now store results into U, V &amp; s</span>
00397   UMat = <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(M,M);
00398   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;<a class="code" href="general_8h.html#a54">M</a>; r++)
00399     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt; Math::minimum(N,M); c++)
00400       UMat(r,c) = <a class="code" href="namespacebase.html#a5">Real</a>( u[r+1][c+1] );
00401   
00402   VMat.resize(N,N);
00403   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;<a class="code" href="general_8h.html#a53">N</a>; r++)
00404     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt;<a class="code" href="general_8h.html#a53">N</a>; c++)
00405       VMat(r,c) = <a class="code" href="namespacebase.html#a5">Real</a>( v[r+1][c+1] );
00406   
00407   s.resize(N);
00408   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;<a class="code" href="general_8h.html#a53">N</a>; i++)
00409     s[i] = <a class="code" href="namespacebase.html#a5">Real</a>( w[i+1] );
00410 }
00411 
00412 
00413 
00414 <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; SVD::U()<span class="keyword"> const</span>
00415 <span class="keyword"></span>{
00416   <span class="keywordflow">return</span> UMat;
00417 }
00418 
00419 <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; SVD::V()<span class="keyword"> const</span>
00420 <span class="keyword"></span>{
00421   <span class="keywordflow">return</span> VMat;
00422 }
00423 
00424 <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a> SVD::diag()<span class="keyword"> const</span>
00425 <span class="keyword"></span>{
00426   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> d( Math::minimum(M,N) );
00427   d = <a class="code" href="namespacebase.html#a205">vectorRange</a>(s, <a class="code" href="namespacebase.html#a30">Range</a>(0, d.size()));
00428   <span class="keywordflow">return</span> d;
00429 }
00430   
00431 
00432 <a class="code" href="classbase_1_1matrix.html">Matrix</a> SVD::S()<span class="keyword"> const</span>
00433 <span class="keyword"></span>{
00434   <a class="code" href="classbase_1_1matrix.html">Matrix</a> S( <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(M,N) );
00435   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt; Math::minimum(N,M); i++)
00436     S(i,i) = s[i];
00437   <span class="keywordflow">return</span> S;
00438 }
00439 
00440 
00441 <a class="code" href="namespacebase.html#a5">Real</a> SVD::condition(Real maxCond)<span class="keyword"> const</span>
00442 <span class="keyword"></span>{
00443   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> d(diag());
00444   <a class="code" href="namespacebase.html#a2">Int</a> minInd = <a class="code" href="namespacebase.html#a222">min_index</a>(d);
00445   <a class="code" href="namespacebase.html#a2">Int</a> maxInd = <a class="code" href="namespacebase.html#a221">max_index</a>(d);
00446    
00447   <a class="code" href="namespacebase.html#a5">Real</a> min = d[minInd];
00448   <a class="code" href="namespacebase.html#a5">Real</a> max = d[maxInd];
00449 
00450   <span class="keywordflow">if</span>(min / max &lt; 1.0/maxCond)
00451     <span class="keywordflow">return</span> maxCond;
00452   <span class="keywordflow">else</span>
00453     <span class="keywordflow">return</span> max / min;
00454 
00455 }
00456 
00457 
00458 <a class="code" href="classbase_1_1matrix.html">Matrix</a> SVD::inv(Real minSingVal)<span class="keyword"> const</span>
00459 <span class="keyword"></span>{
00460   <span class="comment">// combine the products to form the pseudo inverse solution</span>
00461   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a54">M</a> = UMat.size1();
00462   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a53">N</a> = VMat.size1();
00463   <a class="code" href="classbase_1_1matrix.html">Matrix</a> tmpMat( <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(N, M) ); <span class="comment">// VMat * 'D^-1'</span>
00464   <a class="code" href="namespacebase.html#a86">matrixRange</a>(tmpMat, <a class="code" href="namespacebase.html#a30">Range</a>(0,N), <a class="code" href="namespacebase.html#a30">Range</a>(0,N) ) = VMat;
00465    
00466   <span class="comment">// invert the diagonal elements and apply to the tmpMat matrix</span>
00467   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;s.size(); i++)
00468     {
00469       <a class="code" href="namespacebase.html#a5">Real</a> tmp = s[i];
00470       <span class="keywordflow">if</span>(fabs(tmp) &lt; minSingVal)
00471         tmp = 0.0;
00472       <span class="keywordflow">else</span>
00473         tmp = 1.0 / tmp;
00474        
00475       <a class="code" href="namespacebase.html#a84">matrixColumn</a>(tmpMat,i) *= tmp;
00476     }
00477                                                                                                                                                                                                     
00478   <span class="comment">// U^-1 == U^T</span>
00479   <a class="code" href="classbase_1_1matrix.html">Matrix</a> invA(N, M);
00480   invA = tmpMat * <a class="code" href="namespacebase.html#a98">transpose</a>(UMat);
00481                                                                                                                                                                                                     
00482   <span class="keywordflow">return</span> invA;
00483 }
00484  
00485 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:15 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
