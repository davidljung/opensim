<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: physics/GJKCollisionDetector.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>physics/GJKCollisionDetector.cpp</h1><a href="GJKCollisionDetector_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: GJKCollisionDetector.cpp 1031 2004-02-11 20:46:36Z jungd $</span>
00019 <span class="comment">  $Revision: 1.6 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:46:36 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="GJKCollisionDetector.html">physics/GJKCollisionDetector</a>&gt;</span>
00026 <span class="preprocessor">#include &lt;<a class="code" href="Triangle3.html">gfx/Triangle3</a>&gt;</span>
00027 <span class="preprocessor">#include &lt;<a class="code" href="ref.html">base/ref</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="Quat4.html">base/Quat4</a>&gt;</span>
00029 
00030 <span class="keyword">using</span> <a class="code" href="classphysics_1_1GJKCollisionDetector.html">physics::GJKCollisionDetector</a>;
00031 <span class="keyword">using</span> <a class="code" href="classphysics_1_1CollisionState.html">physics::CollisionState</a>;
00032 <span class="keyword">using</span> <a class="code" href="classphysics_1_1CollisionModelProvider.html">physics::CollisionModelProvider</a>;
00033 <span class="keyword">using</span> <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a>;
00034 <span class="keyword">using</span> <a class="code" href="classbase_1_1Matrix3.html">base::Matrix3</a>;
00035 <span class="keyword">using</span> base::transpose;
00036 <span class="keyword">using</span> base::inverse;
00037 <span class="keyword">using</span> base::cross;
00038 <span class="keyword">using</span> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>;
00039 
00040 
00041 <span class="preprocessor">#include &lt;osg/Node&gt;</span>
00042 <span class="preprocessor">#include &lt;osg/Group&gt;</span>
00043 <span class="preprocessor">#include &lt;osg/Geode&gt;</span>
00044 <span class="preprocessor">#include &lt;osg/Transform&gt;</span>
00045 <span class="preprocessor">#include &lt;osg/StateSet&gt;</span>
00046 <span class="preprocessor">#include &lt;osg/Material&gt;</span>
00047 <span class="preprocessor">#include &lt;osg/Array&gt;</span>
00048 <span class="preprocessor">#include &lt;osg/PolygonMode&gt;</span>
00049 <span class="preprocessor">#include &lt;osg/Geometry&gt;</span>
00050 
00051 <span class="keyword">using</span> osg::Vec4;
00052 <span class="keyword">using</span> osg::StateSet;
00053 
00054 
00055 
00056 
00057 <span class="comment">// public</span>
00058 
00059 
00060 GJKCollisionDetector::GJKCollisionDetector()
00061   : collisionDetectionEnabled(true), node(0)
00062 {
00063 }
00064 
00065 
00066 GJKCollisionDetector::~GJKCollisionDetector()
00067 {
00068 }
00069 
00070 
<a name="l00071"></a><a class="code" href="GJKCollisionDetector_8cpp.html#a0">00071</a> <span class="keyword">const</span> Real <a class="code" href="GJKCollisionDetector_8cpp.html#a0">rel_error</a> = 1e-6; <span class="comment">// relative error in the computed distance</span>
<a name="l00072"></a><a class="code" href="GJKCollisionDetector_8cpp.html#a1">00072</a> <span class="keyword">const</span> Real <a class="code" href="GJKCollisionDetector_8cpp.html#a1">abs_error</a> = 1e-10; <span class="comment">// absolute error if the distance is almost zero</span>
00073   
00074 
00075 
00076 GJKCollisionDetector::GJKCollisionState::GJKCollisionState(ref&lt;const Solid&gt; solid1, ref&lt;const Solid&gt; solid2,
00077                                                            CollisionModel::CollisionModelType modelType)
00078   : CollisionState(solid1, solid2)
00079 {
00080   ref&lt;const GJKCollisionModel&gt; cm1 = narrow_ref&lt;const GJKCollisionModel&gt;( solid1-&gt;getCollisionModel(modelType) );
00081   ref&lt;const GJKCollisionModel&gt; cm2 = narrow_ref&lt;const GJKCollisionModel&gt;( solid2-&gt;getCollisionModel(modelType) );
00082 
00083 }
00084 
00085 GJKCollisionDetector::GJKCollisionState::~GJKCollisionState()
00086 {
00087 }
00088 
00089 
00090 
00091 
00092 ref&lt;CollisionState&gt; GJKCollisionDetector::newCollisionState(ref&lt;const Solid&gt; solid1, ref&lt;const Solid&gt; solid2)<span class="keyword"> const</span>
00093 <span class="keyword"></span>{
00094   GJKCollisionState *sp = <a class="code" href="MemoryTracer.html#a1">NewNamedObj</a>(<span class="stringliteral">"GJKCollisionState"</span>) GJKCollisionState(solid1, solid2, getType());
00095   <span class="keywordflow">return</span> ref&lt;GJKCollisionState&gt;(sp);
00096 }
00097 
00098 <span class="keywordtype">bool</span> GJKCollisionDetector::collision(ref&lt;const Solid&gt; solid1, ref&lt;const Solid&gt; solid2, CollisionQueryType queryType)
00099 {
00100   <span class="keywordflow">if</span> (!collisionDetectionEnabled) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00101   <span class="keywordflow">if</span> (queryType == PotentialCollision) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00102 
00103   <span class="comment">// This must be called before GJK intersect/closest_points functions</span>
00104   <span class="comment">// to ensure that a GJKCollisionState for the pair has been created</span>
00105 
00106   ref&lt;GJKCollisionState&gt; cs(narrow_ref&lt;GJKCollisionState&gt;(getCollisionState(solid1,solid2))); 
00107 
00108   <span class="comment">// Do a pair-wise collision check</span>
00109 
00110   ref&lt;const GJKCollisionModel&gt; model1 
00111     = narrow_ref&lt;const GJKCollisionModel&gt;(solid1-&gt;getCollisionModel(getType()));
00112   ref&lt;const GJKCollisionModel&gt; model2 
00113     = narrow_ref&lt;const GJKCollisionModel&gt;(solid2-&gt;getCollisionModel(getType()));
00114   
00115   <a class="code" href="classbase_1_1Transform.html">base::Transform</a> t1(solid1-&gt;getPosition(), solid1-&gt;getOrientation());
00116   <a class="code" href="classbase_1_1Transform.html">base::Transform</a> t2(solid2-&gt;getPosition(), solid2-&gt;getOrientation());
00117   
00118   <span class="comment">// update OSGVisual (if it exists)</span>
00119   <span class="keywordflow">if</span> (node!=0) {
00120     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a26">Point3</a> s0(t1(cs-&gt;lastSupportPoint[0]));
00121     <span class="keyword">const</span> <a class="code" href="namespacebase.html#a26">Point3</a> s1(t2(cs-&gt;lastSupportPoint[1]));
00122     (*verts)[0].set(s0.x,s0.y,s0.z); 
00123     (*verts)[1].set(s1.x,s1.y,s1.z); 
00124     geom-&gt;setVertexArray(verts);
00125   }
00126 
00127 
00128   <span class="comment">// get last support verts</span>
00129   ref&lt;const Polyhedron::Vertex&gt; support0(cs-&gt;lastSupport[0]);
00130   ref&lt;const Polyhedron::Vertex&gt; support1(cs-&gt;lastSupport[1]);
00131 
00132   <span class="comment">// perform collision check</span>
00133   ref&lt;GJKCollisionModel::GJKModelState&gt; ms1(NewObj GJKCollisionModel::GJKModelState(support0));
00134   ref&lt;GJKCollisionModel::GJKModelState&gt; ms2(NewObj GJKCollisionModel::GJKModelState(support1));
00135 
00136   <span class="keywordtype">bool</span> collided = intersect(model1, model2, t1, t2, ms1, ms2, cs);
00137 
00138   cs-&gt;lastSupport[0] = ms1-&gt;lastSupport;
00139   cs-&gt;lastSupport[1] = ms2-&gt;lastSupport;
00140   cs-&gt;lastSupportPoint[0] = ms1-&gt;lastSupportPoint;
00141   cs-&gt;lastSupportPoint[1] = ms2-&gt;lastSupportPoint;
00142 
00143 
00144   <span class="keywordflow">if</span> (collided) {
00145 
00146     <span class="comment">// construct contacts </span>
00147 
00148     <span class="comment">/*    </span>
00149 <span class="comment">    const DtScalar* p1 = collision_data-&gt;point1;</span>
00150 <span class="comment">    const DtScalar* p2 = collision_data-&gt;point2;</span>
00151 <span class="comment">    const DtScalar* n = collision_data-&gt;normal;</span>
00152 <span class="comment">    Point3 cp1(p1[0],p1[1],p1[2]);</span>
00153 <span class="comment">    Point3 cp2(p2[0],p2[1],p2[2]);</span>
00154 <span class="comment">    Vector3 cn(n[0],n[1],n[2]);</span>
00155 <span class="comment">    CollisionState::Contact contact(cp1, cp2,cn);</span>
00156 <span class="comment"></span>
00157 <span class="comment">    cs-&gt;contacts.clear();</span>
00158 <span class="comment">    cs-&gt;contacts.push_back(contact);</span>
00159 <span class="comment">    */</span>
00160     
00161     std::cout &lt;&lt; <span class="stringliteral">"Collided.\n"</span>; <span class="comment">//  T1=\n" &lt;&lt; T1.getBasis() &lt;&lt; "\n:" &lt;&lt; T1.getOrigin() &lt;&lt; "\n";</span>
00162   }
00163   <span class="keywordflow">else</span> {
00164     std::cout &lt;&lt; <span class="stringliteral">"No Collision\n"</span>; <span class="comment">// v=" &lt;&lt; cs-&gt;v &lt;&lt; std::endl;</span>
00165   }
00166     
00167   <span class="keywordflow">return</span> collided;
00168 }
00169 
00170 
00171 <span class="comment">// GJK algorithm</span>
00172 
00173 <span class="keywordtype">void</span> GJKCollisionDetector::compute_det() 
00174 {
00175   <span class="keyword">static</span> <a class="code" href="namespacebase.html#a5">Real</a> dp[4][4];
00176 
00177   <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> i = 0, bit = 1; i &lt; 4; ++i, bit &lt;&lt;=1) 
00178     <span class="keywordflow">if</span> (bits &amp; bit) dp[i][last] = dp[last][i] = <a class="code" href="namespacebase.html#a209">dot</a>(y[i], y[last]);
00179   dp[last][last] = <a class="code" href="namespacebase.html#a209">dot</a>(y[last], y[last]);
00180 
00181   det[last_bit][last] = 1;
00182   <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> j = 0, sj = 1; j &lt; 4; ++j, sj &lt;&lt;= 1) {
00183     <span class="keywordflow">if</span> (bits &amp; sj) {
00184       <a class="code" href="namespacebase.html#a2">Int</a> s2 = sj|last_bit;
00185       det[s2][j] = dp[last][last] - dp[last][j]; 
00186       det[s2][last] = dp[j][j] - dp[j][last];
00187       <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> k = 0, sk = 1; k &lt; j; ++k, sk &lt;&lt;= 1) {
00188         <span class="keywordflow">if</span> (bits &amp; sk) {
00189           <a class="code" href="namespacebase.html#a2">Int</a> s3 = sk|s2;
00190           det[s3][k] = det[s2][j] * (dp[j][j] - dp[j][k]) + 
00191                        det[s2][last] * (dp[last][j] - dp[last][k]);
00192           det[s3][j] = det[sk|last_bit][k] * (dp[k][k] - dp[k][j]) + 
00193                        det[sk|last_bit][last] * (dp[last][k] - dp[last][j]);
00194           det[s3][last] = det[sk|sj][k] * (dp[k][k] - dp[k][last]) + 
00195                           det[sk|sj][j] * (dp[j][k] - dp[j][last]);
00196         }
00197       }
00198     }
00199   }
00200   <span class="keywordflow">if</span> (all_bits == 15) {
00201     det[15][0] = det[14][1] * (dp[1][1] - dp[1][0]) + 
00202                  det[14][2] * (dp[2][1] - dp[2][0]) + 
00203                  det[14][3] * (dp[3][1] - dp[3][0]);
00204     det[15][1] = det[13][0] * (dp[0][0] - dp[0][1]) + 
00205                  det[13][2] * (dp[2][0] - dp[2][1]) + 
00206                  det[13][3] * (dp[3][0] - dp[3][1]);
00207     det[15][2] = det[11][0] * (dp[0][0] - dp[0][2]) + 
00208                  det[11][1] * (dp[1][0] - dp[1][2]) +  
00209                  det[11][3] * (dp[3][0] - dp[3][2]);
00210     det[15][3] = det[7][0] * (dp[0][0] - dp[0][3]) + 
00211                  det[7][1] * (dp[1][0] - dp[1][3]) + 
00212                  det[7][2] * (dp[2][0] - dp[2][3]);
00213   }
00214 }
00215 
00216 
00217 <span class="keyword">inline</span> <span class="keywordtype">bool</span> GJKCollisionDetector::valid(Int s) 
00218 {  
00219   <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> i = 0, bit = 1; i &lt; 4; ++i, bit &lt;&lt;= 1) {
00220     <span class="keywordflow">if</span> (all_bits &amp; bit) {
00221       <span class="keywordflow">if</span> (s &amp; bit) { <span class="keywordflow">if</span> (det[s][i] &lt;= 0) <span class="keywordflow">return</span> <span class="keyword">false</span>; }
00222       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (det[s|bit][i] &gt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00223     }
00224   }
00225   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00226 }
00227 
00228 <span class="keyword">inline</span> <span class="keywordtype">void</span> GJKCollisionDetector::compute_vector(Int bits, Vector3&amp; v)
00229 {
00230   <a class="code" href="namespacebase.html#a5">Real</a> sum = 0;
00231   v.setZero();
00232   <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> i = 0, bit = 1; i &lt; 4; ++i, bit &lt;&lt;= 1) {
00233     <span class="keywordflow">if</span> (bits &amp; bit) {
00234       sum += det[bits][i];
00235       v += y[i] * det[bits][i];
00236     }
00237   }
00238   v *= 1 / sum;
00239 }
00240 
00241 <span class="keyword">inline</span> <span class="keywordtype">void</span> GJKCollisionDetector::compute_points(<span class="keywordtype">int</span> bits, Point3&amp; p1, Point3&amp; p2)
00242 {
00243   <a class="code" href="namespacebase.html#a5">Real</a> sum = 0;
00244   p1.setZero();
00245   p2.setZero();
00246   <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> i = 0, bit = 1; i &lt; 4; ++i, bit &lt;&lt;= 1) {
00247     <span class="keywordflow">if</span> (bits &amp; bit) {
00248       sum += det[bits][i];
00249       p1 += p[i] * det[bits][i];
00250       p2 += q[i] * det[bits][i];
00251     }
00252   }
00253   <a class="code" href="namespacebase.html#a5">Real</a> s = 1 / sum;
00254   p1 *= s;
00255   p2 *= s;
00256 }
00257 
00258 <span class="keyword">inline</span> <span class="keywordtype">bool</span> GJKCollisionDetector::closest(Vector3&amp; v) 
00259 {
00260   compute_det();
00261   <span class="keywordflow">for</span> (<a class="code" href="namespacebase.html#a2">Int</a> s = bits; s; --s) {
00262     <span class="keywordflow">if</span> ((s &amp; bits) == s) {
00263       <span class="keywordflow">if</span> (valid(s|last_bit)) {
00264         bits = s|last_bit;
00265         compute_vector(bits, v);
00266         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00267       }
00268     }
00269   }
00270   <span class="keywordflow">if</span> (valid(last_bit)) {
00271     bits = last_bit;
00272     v = y[last];
00273     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00274   }
00275 
00276   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00277 }
00278 
00279 
00280 <span class="keywordtype">bool</span> GJKCollisionDetector::intersect(ref&lt;const GJKCollisionModel&gt; model1, ref&lt;const GJKCollisionModel&gt; model2,
00281                                      <span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t1, <span class="keyword">const</span> <a class="code" href="classbase_1_1Transform.html">base::Transform</a>&amp; t2, 
00282                                      ref&lt;GJKCollisionModel::GJKModelState&gt; modelState1,
00283                                      ref&lt;GJKCollisionModel::GJKModelState&gt; modelState2,
00284                                      ref&lt;GJKCollisionState&gt; collisionState)
00285 {
00286   Vector3 w;
00287   Vector3&amp; v(collisionState-&gt;v);
00288 
00289   bits = 0;
00290   all_bits = 0;
00291 
00292 
00293   <span class="keywordflow">do</span> {
00294     last = 0;
00295     last_bit = 1;
00296     <span class="keywordflow">while</span> (bits &amp; last_bit) { ++last; last_bit &lt;&lt;= 1; }
00297     w =   t1(model1-&gt;support(modelState1,t1.rotate(-v))) 
00298         - t2(model2-&gt;support(modelState2,t2.<a class="code" href="classbase_1_1Transform.html#base_1_1Transforma36">rotate</a>( v))); 
00299     <span class="keywordflow">if</span> (<a class="code" href="namespacebase.html#a209">dot</a>(v, w) &gt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00300 
00301     y[last] = w;
00302     all_bits = bits|last_bit;
00303     <span class="keywordflow">if</span> (!closest(v)) {
00304       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00305     }
00306   } 
00307   <span class="keywordflow">while</span> (bits &lt; 15 &amp;&amp; !v.equalsZero() ); 
00308   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00309 }
00310 
00311 
00312 <span class="comment"></span>
00313 <span class="comment">/// create a visual for debugging purposes</span>
00314 <span class="comment"></span>osg::Node* GJKCollisionDetector::createOSGVisual(Visual::Attributes visualAttributes)<span class="keyword"> const</span>
00315 <span class="keyword"></span>{
00316   <span class="keywordflow">if</span> (!(visualAttributes &amp; ShowCollisionDetection)) <span class="keywordflow">return</span> <a class="code" href="MemoryTracer.html#a0">NewObj</a> osg::Node();
00317 
00318   <span class="keywordflow">if</span> ((node!=0) &amp;&amp; (attributes==visualAttributes))
00319     <span class="keywordflow">return</span> &amp;(*node);
00320 
00321   <span class="comment">// show a line between the last support point and the passed v.</span>
00322   geom = <span class="keyword">new</span> osg::Geometry();
00323 
00324   StateSet* state = <span class="keyword">new</span> osg::StateSet();
00325   osg::Material* mat = <span class="keyword">new</span> osg::Material();
00326   Vec4 col( 1, 1, 0, 1);
00327   mat-&gt;setAmbient( osg::Material::FRONT_AND_BACK, col );
00328   mat-&gt;setDiffuse( osg::Material::FRONT_AND_BACK, col );
00329   state-&gt;setAttribute( mat );
00330   <span class="comment">//geom-&gt;setStateSet(state);</span>
00331 
00332   verts = <span class="keyword">new</span> osg::Vec3Array(2);
00333   (*verts)[0].set(0,0,0);
00334   (*verts)[1].set(0,0,0);
00335   geom-&gt;setVertexArray(verts);
00336 
00337   osg::Vec4Array* colors = <span class="keyword">new</span> osg::Vec4Array(1);
00338   (*colors)[0].set(1.0f,0.0f,0.0f,1.0f);
00339   geom-&gt;setColorArray(colors);
00340   geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);
00341 
00342   osg::DrawArrays* linearray = <span class="keyword">new</span> osg::DrawArrays(osg::PrimitiveSet::LINES,0,2);
00343   geom-&gt;addPrimitiveSet(linearray);
00344 
00345   osg::Geode* geode = <span class="keyword">new</span> osg::Geode();
00346   geode = <span class="keyword">new</span> osg::Geode();
00347   geode-&gt;setName(<span class="stringliteral">"Debug"</span>);
00348   geode-&gt;addDrawable(&amp;(*geom));
00349 
00350   node = geode;
00351   attributes = visualAttributes;
00352 
00353   <span class="keywordflow">return</span> &amp;(*node);
00354 }
00355 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:23 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
