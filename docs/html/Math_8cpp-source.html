<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/Math.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/Math.cpp</h1><a href="Math_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: Math.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.17 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="Math.html">base/Math</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="SVD.html">base/SVD</a>&gt;</span>
00028 
00029 <span class="keyword">using</span> <a class="code" href="classbase_1_1Math.html">base::Math</a>;
00030 
00031 <span class="keyword">using</span> <a class="code" href="classbase_1_1matrix.html">base::Matrix</a>;
00032 <span class="keyword">using</span> <a class="code" href="classbase_1_1vector.html">base::Vector</a>;
00033 <span class="keyword">using</span> base::swap;
00034 <span class="keyword">using</span> <a class="code" href="classbase_1_1SVD.html">base::SVD</a>;
00035 
00036 
00037 <span class="comment">// define this to use the old IKORv2 mat_null for null-space computation instead of</span>
00038 <span class="comment">//  the class SVD in method nullSpace().  Although both provide the null-space of</span>
00039 <span class="comment">//  a matrix, the spanning vector set is not unique - and each routine typically</span>
00040 <span class="comment">//  produces a different set.  This is useful for comparison with old code.</span>
00041 <span class="comment">//  (NB: the old IKORv2 code must be included in the build via externally defining</span>
00042 <span class="comment">//   BUILDOLDIKOR)</span>
00043 <span class="comment">//#define USEOLDIKOR_NULLSPACE</span>
00044 
00045 <span class="preprocessor">#ifdef BUILDOLDIKOR</span>
00046 <span class="preprocessor"></span><span class="preprocessor">  #ifdef USEOLDIKOR_NULLSPACE</span>
00047 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00048 <span class="preprocessor">    #include &lt;<a class="code" href="general_8h.html">robot/control/oldikor/IKOR/general.h</a>&gt;</span>
00049 <span class="preprocessor">    #include &lt;<a class="code" href="headers_8h.html">robot/control/oldikor/IKOR/headers.h</a>&gt;</span>
00050 <span class="preprocessor">    #include &lt;<a class="code" href="matrix_8h.html">robot/control/oldikor/UTILS/matrix.h</a>&gt;</span>
00051   }
00052 <span class="preprocessor">  #endif</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00054 <span class="preprocessor"></span><span class="preprocessor">  #undef USEOLDIKOR_NULLSPACE</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00056 <span class="preprocessor"></span>
00057 
00058 
00059 <a class="code" href="namespacebase.html#a5">Real</a> Math::angleDifference(Real angle1, Real angle2)
00060 {
00061   <a class="code" href="namespacebase.html#a5">Real</a> a1 = <a class="code" href="classbase_1_1Math.html#base_1_1Mathe24">normalizeAngle</a>(angle1);
00062   <a class="code" href="namespacebase.html#a5">Real</a> a2 = <a class="code" href="classbase_1_1Math.html#base_1_1Mathe24">normalizeAngle</a>(angle2);
00063   <span class="keywordflow">if</span> (a1 &gt;= 0) {
00064     <span class="keywordflow">if</span> (a2 &gt;= 0)
00065       <span class="keywordflow">return</span> a1-a2;
00066     <span class="keywordflow">else</span> {
00067       <span class="keywordflow">if</span> ((a1-a2) &lt;= consts::Pi)
00068         <span class="keywordflow">return</span> a1-a2;
00069       <span class="keywordflow">else</span>
00070         <span class="keywordflow">return</span> (-consts::Pi-a2)-(consts::Pi-a1);
00071     }
00072   }
00073   <span class="keywordflow">else</span> {
00074     <span class="keywordflow">if</span> (a2 &lt; 0)
00075       <span class="keywordflow">return</span> a1-a2;
00076     <span class="keywordflow">else</span> {
00077       <span class="keywordflow">if</span> ((a1-a2) &gt; -consts::Pi)
00078         <span class="keywordflow">return</span> a1-a2;
00079       <span class="keywordflow">else</span>
00080         <span class="keywordflow">return</span> (consts::Pi-a2)-(-consts::Pi-a1);
00081     }
00082   }
00083 }
00084 
00085 
00086 
00087 
00088 
00089 
00090 
00091 <span class="keywordtype">void</span> Math::decomposeLUP(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; A, <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; L, <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; U, <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; Pi, Real epsilon)
00092 {
00093   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> n = A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>();
00094 
00095   <a class="code" href="base.html#a21">Assertm</a>( (L.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == n) &amp;&amp; (L.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() == n)
00096            &amp;&amp; (U.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == n) &amp;&amp; (U.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() == n) &amp;&amp; (<a class="code" href="namespacebase_1_1consts.html#a8">Pi</a>.size() == n),
00097            <span class="stringliteral">"L,U,Pi are square and of same dimension as A"</span>);
00098 
00099   <a class="code" href="namespacebase.html#a5">Real</a> p,a;
00100   <a class="code" href="namespacebase.html#a2">Int</a> kp,i,j,k;
00101   <a class="code" href="classbase_1_1matrix.html">Matrix</a> AA(A);
00102 
00103   <span class="keywordflow">for</span>(i=0; i&lt;n; i++) <a class="code" href="namespacebase_1_1consts.html#a8">Pi</a>[i] = i;
00104   <span class="keywordflow">for</span>(k=0; k&lt;n-1; k++) {
00105     p = <a class="code" href="namespacebase.html#a5">Real</a>(0); kp = 0;
00106     <span class="keywordflow">for</span>(i=k; i&lt;n; i++) {
00107       a = <a class="code" href="namespacebase.html#a5">Real</a>(<a class="code" href="classbase_1_1Math.html#base_1_1Mathe5">abs</a>(AA(i,k)));
00108       <span class="keywordflow">if</span> ( a &gt; p ) {
00109         p = a;
00110         kp = i;
00111       }
00112     }
00113     <span class="keywordflow">if</span> (<a class="code" href="classbase_1_1Math.html#base_1_1Mathe17">equals</a>(p,0,epsilon)) 
00114       <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"Matrix A is singular"</span>));
00115     
00116     <a class="code" href="namespacebase.html#a46">swap</a>(Pi[k],Pi[kp]);
00117     <span class="keywordflow">for</span>(i=0; i&lt;n;i++) <a class="code" href="namespacebase.html#a46">swap</a>(AA(k,i),AA(kp,i));
00118     
00119     <span class="keywordflow">for</span>(i=k+1; i&lt;n;i++) {
00120       AA(i,k) /= AA(k,k);
00121       <span class="keywordflow">for</span>(j=k+1; j&lt;n; j++)
00122         AA(i,j) -= AA(i,k)*AA(k,j);
00123     }
00124   }
00125   
00126   <span class="keywordflow">for</span>(i=0;i&lt;n;i++) {
00127     <span class="keywordflow">for</span>(j=0;j&lt;n;j++)
00128       <span class="keywordflow">if</span> (i&gt;j) {
00129         L(i,j) = AA(i,j); U(i,j) = 0;
00130       }
00131       <span class="keywordflow">else</span> {
00132         U(i,j) = AA(i,j); L(i,j) = 0;
00133       }
00134     L(i,i) = <a class="code" href="namespacebase.html#a5">Real</a>(1);
00135     
00136   }
00137 
00138 }
00139 
00140 
00141 <a class="code" href="classdemeter_1_1Vector.html">Vector</a> Math::solveLUP(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; L, <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; U, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; Pi, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; b)
00142 {  
00143   <a class="code" href="namespacebase.html#a2">Int</a> n = L.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>();
00144 
00145   <a class="code" href="base.html#a21">Assertm</a>( (b.size() == n) &amp;&amp; (L.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == n)
00146            &amp;&amp; (U.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>()==n) || (U.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() == n) &amp;&amp; (<a class="code" href="namespacebase_1_1consts.html#a8">Pi</a>.size() == n),
00147            <span class="stringliteral">"L,U,Pi must are square and of same dimension (that of b)"</span>);
00148 
00149   <a class="code" href="namespacebase.html#a1">SInt</a> i,j;
00150   <a class="code" href="classdemeter_1_1Vector.html">Vector</a> y(n), x(n);
00151   <a class="code" href="namespacebase.html#a5">Real</a> s;
00152   <span class="comment">// forward subst.</span>
00153   <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="namespacebase.html#a1">SInt</a>(n);i++) {
00154     s = 0;
00155     <span class="keywordflow">for</span>(j=0;j&lt;i;j++) s += L(i,j)*y[j];
00156     y[i] = b[<a class="code" href="namespacebase.html#a2">Int</a>(Pi[i])] - s;
00157   }
00158   <span class="comment">// backward subst.</span>
00159   <span class="keywordflow">for</span>(i=n-1;i&gt;=0;i--) {
00160     s = 0;
00161     <span class="keywordflow">for</span>(j=i+1;j&lt;<a class="code" href="namespacebase.html#a1">SInt</a>(n);j++) s += U(i,j)*x[j]; 
00162     x[i] = (y[i] - s)/(U(i,i));
00163   }
00164   <span class="keywordflow">return</span> x;
00165 }
00166 
00167 
00168 
00169 
00170 <a class="code" href="classbase_1_1matrix.html">Matrix</a> Math::inverse(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; A, Real epsilon)
00171 {
00172   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> nr = A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>();
00173   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> nc = A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>();
00174 
00175   <span class="keywordflow">if</span> (nr == nc) {
00176     <span class="comment">// Solve AX = I by solving eqns: Ax = e (for each e a col of I)</span>
00177     <a class="code" href="classbase_1_1matrix.html">Matrix</a> <a class="code" href="Globals_8h.html#a16">X</a>(nr,nc);
00178     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> x(nr);
00179     
00180     <a class="code" href="classbase_1_1matrix.html">Matrix</a> L(nr,nc),U(nr,nc);
00181     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> <a class="code" href="namespacebase_1_1consts.html#a8">Pi</a>(nr);
00182     
00183     <a class="code" href="classbase_1_1Math.html#base_1_1Mathe27">decomposeLUP</a>(A, L, U, Pi, epsilon);
00184     
00185     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt;nc; c++) {
00186       x = <a class="code" href="classbase_1_1Math.html#base_1_1Mathe28">solveLUP</a>(L,U,Pi,<a class="code" href="namespacebase.html#a203">unitVector</a>(nc,c));
00187       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;nr; r++) <a class="code" href="Globals_8h.html#a16">X</a>(r,c) = x[r];
00188     }
00189     
00190     <span class="keywordflow">return</span> <a class="code" href="Globals_8h.html#a16">X</a>;
00191   }
00192   <span class="keywordflow">else</span>
00193     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"Can't invert a non-square matrix"</span>));
00194   
00195 }
00196 
00197 
00198 <a class="code" href="classbase_1_1matrix.html">Matrix</a> Math::nullSpace(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; A, Int&amp; nullSpaceRank, Real&amp; k2)
00199 {
00200   <span class="keywordflow">if</span> ((A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() == 0) || (A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>() == 0))
00201     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"Can't compute null-space of a 0x0 matrix!"</span>));
00202 
00203 <span class="preprocessor">#ifndef USEOLDIKOR_NULLSPACE</span>
00204 <span class="preprocessor"></span>  <span class="comment">// this is a transliteration of the IKORv2.0 function mat_null() (in matrix.c)</span>
00205   <span class="comment">// (except that mat_null uses the Numerical Recipies in C function svdcmp() and</span>
00206   <span class="comment">//  we use class SVD)</span>
00207 
00208   <a class="code" href="base.html#a19">Assert</a>(A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>() &lt;= A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>());
00209 
00210   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="Globals_8h.html#a15">R</a> = A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(); <span class="comment">// M</span>
00211   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> C = A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>(); <span class="comment">// N</span>
00212 
00213   <span class="comment">// make R == C by adding rows of zeros if necessary</span>
00214   <a class="code" href="classbase_1_1matrix.html">Matrix</a> Asqr(C,C);
00215   <span class="keywordflow">if</span> (<a class="code" href="Globals_8h.html#a15">R</a> &lt; C) {
00216     <a class="code" href="namespacebase.html#a86">matrixRange</a>(Asqr,<a class="code" href="namespacebase.html#a30">Range</a>(0,R), <a class="code" href="namespacebase.html#a30">Range</a>(0,C)) = A;
00217     <a class="code" href="namespacebase.html#a86">matrixRange</a>(Asqr,<a class="code" href="namespacebase.html#a30">Range</a>(R,C), <a class="code" href="namespacebase.html#a30">Range</a>(0,C)) = <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(C-R,C);
00218   }
00219   <span class="keywordflow">else</span>
00220     Asqr = A;
00221  
00222   SVD svd(Asqr);
00223   
00224   <span class="comment">// reorder (and record the reordering in 'order')</span>
00225   <span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; V(svd.V());
00226   <a class="code" href="classdemeter_1_1Vector.html">Vector</a>  S(svd.diag());
00227 
00228   <a class="code" href="classbase_1_1vector.html">IVector</a> order(C);
00229   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;C; i++) order[i]=i;
00230 
00231   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a1">SInt</a> i=C-1; i&gt;0; i--)
00232     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a1">SInt</a> j=i-1; j&gt;=0; j--)
00233       <span class="keywordflow">if</span> ( Math::abs(S[i]) &gt; Math::abs(S[j]) ) {
00234         <a class="code" href="namespacebase.html#a46">base::swap</a>(S[i],S[j]);
00235         <a class="code" href="namespacebase.html#a46">base::swap</a>(order[i],order[j]);
00236       }
00237 
00238   <a class="code" href="namespacebase.html#a5">Real</a> s_min;
00239   <span class="keywordflow">if</span> (<a class="code" href="Globals_8h.html#a15">R</a>&lt;=C)
00240     s_min = Math::abs(S[R-1]);
00241   <span class="keywordflow">else</span>
00242     s_min = Math::abs(S[C-1]);
00243   <a class="code" href="namespacebase.html#a5">Real</a> s_max = Math::abs(S[0]);
00244 
00245 
00246   <a class="code" href="classbase_1_1matrix.html">Matrix</a> ns(C,C); <span class="comment">// truncate unused columns before return</span>
00247   nullSpaceRank=0;
00248   <span class="keywordflow">while</span> (Math::abs(S[C-1-nullSpaceRank]) &lt; SVD::minSingValue) {
00249     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> j=0; j&lt;C; j++) 
00250       ns(j,nullSpaceRank) = V(j,order[C-1-nullSpaceRank]);
00251     nullSpaceRank++;
00252     <span class="keywordflow">if</span> (nullSpaceRank == C) <span class="keywordflow">break</span>;
00253   }
00254 
00255   <span class="keywordflow">if</span> (nullSpaceRank &lt; C) {
00256     <span class="keywordflow">if</span> ( (Math::abs(s_min)&gt;=SVD::minSingValue) &amp;&amp; (Math::abs(s_min/s_max) &lt; SVD::minSingValue)) {
00257       <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> j=0; j&lt;C; j++) 
00258         ns(j,nullSpaceRank) = V(order[j],C-1-nullSpaceRank);
00259       nullSpaceRank++;
00260     }
00261   }
00262 
00263   <span class="keywordflow">if</span> (<a class="code" href="classbase_1_1Math.html#base_1_1Mathe17">equals</a>(s_min,0,SVD::minSingValue))
00264     k2 = consts::maxReal;
00265   <span class="keywordflow">else</span>
00266     k2 = s_max/s_min;
00267 
00268   <a class="code" href="classbase_1_1matrix.html">Matrix</a> n(C,nullSpaceRank);
00269   <span class="keywordflow">if</span> ((C &gt; 0) &amp;&amp; (nullSpaceRank &gt; 0))
00270     n = <a class="code" href="namespacebase.html#a86">matrixRange</a>(ns, <a class="code" href="namespacebase.html#a30">Range</a>(0,C), <a class="code" href="namespacebase.html#a30">Range</a>(0,nullSpaceRank));
00271 
00272   <span class="keywordflow">return</span> n;
00273 
00274 <span class="preprocessor">#else</span>
00275 <span class="preprocessor"></span>  <span class="comment">// use the old IKOR mat_null() function so we get exactly the same</span>
00276   <span class="comment">//  vectors to aid debugging</span>
00277 
00278   <a class="code" href="structMATRIX.html">MATRIX</a> *a = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(A.size1(), A.size2());
00279   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;A.size1(); r++)
00280     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt;A.size2(); c++)
00281       a-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[r][c] = A(r,c);
00282 
00283   <span class="comment">//  Int m = Math::maximum(A.size1(), A.size2());</span>
00284   <a class="code" href="structMATRIX.html">MATRIX</a> *n = <a class="code" href="matrix_8h.html#a25">mat_malloc</a>(A.size2(), A.size1());
00285   <span class="keywordtype">int</span> n_rank;
00286   <span class="keywordtype">float</span> K2;
00287   <a class="code" href="matrix_8h.html#a24">mat_null</a>(a, &amp;n_rank, n, &amp;K2);
00288 
00289   nullSpaceRank = n_rank;
00290   k2 = K2;
00291 
00292   <a class="code" href="classbase_1_1matrix.html">Matrix</a> nn(A.size2(), nullSpaceRank);
00293   <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> r=0; r&lt;A.size2(); r++)
00294     <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> c=0; c&lt;nullSpaceRank; c++)
00295       nn(r,c) = n-&gt;<a class="code" href="structMATRIX.html#MATRIXo0">p</a>[r][c];
00296 
00297   <a class="code" href="matrix_8h.html#a8">mat_free</a>(a);
00298   <a class="code" href="matrix_8h.html#a8">mat_free</a>(n);
00299 
00300   <span class="keywordflow">return</span> nn;
00301 <span class="preprocessor">#endif</span>
00302 <span class="preprocessor"></span>}
00303 
00304 
00305 <a class="code" href="classbase_1_1matrix.html">Matrix</a> Math::pseudoInverse(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; A)
00306 {
00307   <span class="comment">// pad first if necessary</span>
00308   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a54">M</a>=A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(); <span class="comment">// rows</span>
00309   <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> <a class="code" href="general_8h.html#a53">N</a>=A.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>(); <span class="comment">// cols</span>
00310 
00311   <span class="comment">// Use Single-Value-Decomposition (SVD)</span>
00312   <span class="comment">//  this requires that A be MxN where M&gt;=N.  If the system</span>
00313   <span class="comment">//  is under-determined, then M&lt;N, so we need to </span>
00314   <span class="comment">//  pad A with rows of 0s to make it square</span>
00315 
00316   <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a54">M</a>&lt;<a class="code" href="general_8h.html#a53">N</a>) {
00317     <a class="code" href="classbase_1_1matrix.html">Matrix</a> pA(N,N);
00318     <a class="code" href="namespacebase.html#a86">matrixRange</a>(pA,<a class="code" href="namespacebase.html#a30">Range</a>(0,M), <a class="code" href="namespacebase.html#a30">Range</a>(0,N)) = A;
00319     <a class="code" href="namespacebase.html#a86">matrixRange</a>(pA,<a class="code" href="namespacebase.html#a30">Range</a>(M,N), <a class="code" href="namespacebase.html#a30">Range</a>(0,N)) = <a class="code" href="namespacebase.html#a100">zeroMatrix</a>(N-M,N); <span class="comment">// pad</span>
00320 
00321     <a class="code" href="classbase_1_1matrix.html">Matrix</a> pAinv( SVD(pA).inv() ); <span class="comment">// padded pseudo inverse of A</span>
00322     
00323     <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a86">matrixRange</a>(pAinv, <a class="code" href="namespacebase.html#a30">Range</a>(0,N), <a class="code" href="namespacebase.html#a30">Range</a>(0,M)); <span class="comment">// remove padding</span>
00324   }
00325 
00326   <span class="comment">// M&gt;=N</span>
00327   <span class="keywordflow">return</span> SVD(A).inv();
00328 }
00329 
00330 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:06 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
