<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/Expression.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/Expression.cpp</h1><a href="Expression_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)2002 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment"></span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment"></span>
00018 <span class="comment">  $Id: Expression.cpp 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.17 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"></span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="Expression.html">base/Expression</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;<a class="code" href="Matrix.html">base/Matrix</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="Math.html">base/Math</a>&gt;</span>
00029 <span class="preprocessor">#include &lt;<a class="code" href="ConstantExpression.html">base/ConstantExpression</a>&gt;</span>
00030 <span class="preprocessor">#include &lt;<a class="code" href="VariableExpression.html">base/VariableExpression</a>&gt;</span>
00031 <span class="preprocessor">#include &lt;<a class="code" href="SumExpression.html">base/SumExpression</a>&gt;</span>
00032 <span class="preprocessor">#include &lt;<a class="code" href="DifferenceExpression.html">base/DifferenceExpression</a>&gt;</span>
00033 <span class="preprocessor">#include &lt;<a class="code" href="NegateExpression.html">base/NegateExpression</a>&gt;</span>
00034 <span class="preprocessor">#include &lt;<a class="code" href="ProductExpression.html">base/ProductExpression</a>&gt;</span>
00035 <span class="preprocessor">#include &lt;<a class="code" href="QuotientExpression.html">base/QuotientExpression</a>&gt;</span>
00036 <span class="preprocessor">#include &lt;<a class="code" href="SinExpression.html">base/SinExpression</a>&gt;</span>
00037 <span class="preprocessor">#include &lt;<a class="code" href="CosExpression.html">base/CosExpression</a>&gt;</span>
00038 
00039 
00040 <span class="keyword">using</span> <a class="code" href="classbase_1_1Math.html">base::Math</a>;
00041 <span class="keyword">using</span> <a class="code" href="classbase_1_1matrix.html">base::Matrix</a>;
00042 <span class="keyword">using</span> <a class="code" href="classbase_1_1Expression.html">base::Expression</a>;
00043 <span class="keyword">using</span> <a class="code" href="classbase_1_1ExpressionNode.html">base::ExpressionNode</a>;
00044 <span class="keyword">using</span> <a class="code" href="classbase_1_1ConstantExpression.html">base::ConstantExpression</a>;
00045 <span class="keyword">using</span> <a class="code" href="classbase_1_1VariableExpression.html">base::VariableExpression</a>;
00046 <span class="keyword">using</span> <a class="code" href="classbase_1_1SumExpression.html">base::SumExpression</a>;
00047 <span class="keyword">using</span> <a class="code" href="classbase_1_1DifferenceExpression.html">base::DifferenceExpression</a>;
00048 <span class="keyword">using</span> <a class="code" href="classbase_1_1NegateExpression.html">base::NegateExpression</a>;
00049 <span class="keyword">using</span> <a class="code" href="classbase_1_1ProductExpression.html">base::ProductExpression</a>;
00050 <span class="keyword">using</span> <a class="code" href="classbase_1_1QuotientExpression.html">base::QuotientExpression</a>;
00051 <span class="keyword">using</span> <a class="code" href="classbase_1_1SinExpression.html">base::SinExpression</a>;
00052 <span class="keyword">using</span> <a class="code" href="classbase_1_1CosExpression.html">base::CosExpression</a>;
00053 
00054 
00055 
00056 Expression::Expression()
00057 {
00058   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(0));
00059 }
00060 
00061 Expression::Expression(Real constant)
00062 {
00063   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(constant));
00064 }
00065 
00066 Expression::Expression(<span class="keyword">const</span> Expression&amp; e)
00067 {
00068   expr = e.expr;
00069 }
00070 
00071 Expression::Expression(<span class="keyword">const</span> String&amp; exprString)
00072 {
00073   <a class="code" href="namespacebase.html#a2">Int</a> pos=0;
00074   expr = expression(exprString,pos).expr;
00075 }
00076 
00077   
00078   
00079 <a class="code" href="namespacebase.html#a5">base::Real</a> Expression::evaluate(<span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; params)<span class="keyword"> const</span>
00080 <span class="keyword"></span>{
00081   expr-&gt;resetCache();
00082   <span class="keywordflow">return</span> expr-&gt;evaluate(params);
00083 }
00084 
00085 Expression Expression::differentiate( Expression withRespectTo )<span class="keyword"> const</span>
00086 <span class="keyword"></span>{
00087   <span class="keywordflow">if</span> ( withRespectTo.expr-&gt;opType() != ExpressionNode::Variable ) 
00088     <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"Must pass a simple variable expression, such as Expression::p[2]"</span>));
00089 
00090   ref&lt;VariableExpression&gt; vexpr( narrow_ref&lt;VariableExpression&gt;(withRespectTo.expr) );
00091   <span class="keywordflow">return</span> Expression(expr-&gt;differentiate(vexpr-&gt;index));
00092 }
00093 <span class="comment"></span>
00094 <span class="comment">/// \todo add mergeCommonSubexpressions()</span>
00095 <span class="comment"></span><span class="keywordtype">void</span> Expression::simplify()
00096 {
00097   expr = simplifyConstantExpressions(expr);
00098 }
00099 
00100 <span class="keywordtype">void</span> Expression::operationCounts(Int&amp; addsub, Int&amp; multdiv, Int&amp; trig)<span class="keyword"> const</span>
00101 <span class="keyword"></span>{
00102   expr-&gt;operationCounts(addsub,multdiv,trig);
00103 }
00104 
00105 
00106 <a class="code" href="namespacebase.html#a4">base::String</a> Expression::toString()<span class="keyword"> const</span>
00107 <span class="keyword"></span>{
00108   <span class="keywordflow">return</span> expr-&gt;toString();
00109 }
00110 
00111 Expression Expression::VariableIndexer::operator[](Int i)<span class="keyword"> const</span>
00112 <span class="keyword"></span>{
00113   ref&lt;ExpressionNode&gt; expr(NewObj <a class="code" href="classbase_1_1VariableExpression.html">VariableExpression</a>(i));
00114   <span class="keywordflow">return</span> Expression(expr);
00115 }
00116 
00117 
00118 Expression::VariableIndexer Expression::p;
00119 
00120 
00121 
00122 
00123 
00124 <span class="comment">// parsing</span>
00125 <span class="keywordtype">bool</span> Expression::peek(<span class="keyword">const</span> String&amp; s, Int pos, String next)
00126 {
00127   <span class="keywordflow">if</span> (pos + next.size() &gt; s.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00128   
00129   <span class="keywordflow">return</span> (s.find(next, pos) == pos);
00130 }
00131 
<a name="l00132"></a><a class="code" href="Expression_8cpp.html#a0">00132</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="Expression_8cpp.html#a0">isAlpha</a>(String::value_type c)
00133 {
00134   <span class="keywordflow">return</span> ((c &gt;= <span class="charliteral">'a'</span>) &amp;&amp; (c &lt;= 'z')) || ((c &gt;= <span class="charliteral">'A'</span>) &amp;&amp; (c &lt;= <span class="charliteral">'Z'</span>));
00135 }
00136 
<a name="l00137"></a><a class="code" href="Expression_8cpp.html#a1">00137</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="Expression_8cpp.html#a1">isNum</a>(String::value_type c)
00138 {
00139   <span class="keywordflow">return</span> ((c &gt;= <span class="charliteral">'0'</span>) &amp;&amp; (c &lt;= <span class="charliteral">'9'</span>));
00140 }
00141 
<a name="l00142"></a><a class="code" href="Expression_8cpp.html#a2">00142</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="Expression_8cpp.html#a2">isAlphaNum</a>(String::value_type c)
00143 {
00144   <span class="keywordflow">return</span> <a class="code" href="Expression_8cpp.html#a0">isAlpha</a>(c) || <a class="code" href="Expression_8cpp.html#a1">isNum</a>(c);
00145 }
00146 
00147 
00148 SInt Expression::index(<span class="keyword">const</span> String&amp; s, Int&amp; pos)
00149 {
00150   SInt sign=1;
00151   <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'-'</span>)) { <span class="comment">// leading -ve?</span>
00152     sign = -1;
00153     ++pos;
00154   }
00155   <span class="keywordflow">else</span>
00156     <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'+'</span>)) ++pos; <span class="comment">// leading +ve?</span>
00157   
00158   <a class="code" href="namespacebase.html#a2">Int</a> v=0;
00159   <span class="keywordflow">while</span> ( <a class="code" href="Expression_8cpp.html#a1">isNum</a>(s[pos]) ) { 
00160     v = (10*v) + <a class="code" href="namespacebase.html#a2">Int</a>(s[pos]-<span class="charliteral">'0'</span>);
00161     ++pos;
00162   }
00163   
00164   <span class="keywordflow">return</span> <a class="code" href="namespacebase.html#a1">SInt</a>(sign*v);
00165 }
00166 
00167 
00168 <a class="code" href="namespacebase.html#a5">Real</a> Expression::real(<span class="keyword">const</span> String&amp; s, Int&amp; pos)
00169 {
00170   <a class="code" href="namespacebase.html#a5">Real</a> sign=1.0;
00171   <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'-'</span>)) { <span class="comment">// leading -ve?</span>
00172     sign = -1.0;
00173     ++pos;
00174   }
00175   <span class="keywordflow">else</span>
00176     <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'+'</span>)) ++pos; <span class="comment">// leading +ve?</span>
00177   
00178   <a class="code" href="namespacebase.html#a5">Real</a> v=0;
00179   <span class="keywordflow">while</span> ( <a class="code" href="Expression_8cpp.html#a1">isNum</a>(s[pos]) ) { <span class="comment">// whole part</span>
00180     v = (10.0*v) + <a class="code" href="namespacebase.html#a2">Int</a>(s[pos]-<span class="charliteral">'0'</span>);
00181     ++pos;
00182   }
00183   <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'.'</span>)) { <span class="comment">// fraction part (optional)</span>
00184     ++pos;
00185     <a class="code" href="namespacebase.html#a5">Real</a> m=0.1;
00186     <span class="keywordflow">while</span> (<a class="code" href="Expression_8cpp.html#a1">isNum</a>(s[pos])) {
00187       v = v + <a class="code" href="namespacebase.html#a5">Real</a>(<a class="code" href="namespacebase.html#a2">Int</a>(s[pos]-<span class="charliteral">'0'</span>))*m;
00188       m *= 0.1;
00189       ++pos;
00190     }
00191   }
00192   <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'e'</span>) || peek(s,pos,<span class="charliteral">'E'</span>)) { <span class="comment">// exponent part (optional)</span>
00193     <span class="keywordflow">if</span> (peek(s,pos+1,<span class="charliteral">'-'</span>) || (peek(s,pos+1,<span class="charliteral">'+'</span>))) { <span class="comment">// -ve or +ve required</span>
00194       ++pos;
00195       <a class="code" href="namespacebase.html#a5">Real</a> esign = peek(s,pos,<span class="charliteral">'-'</span>)?-1.0:1.0;
00196       ++pos;
00197       <a class="code" href="namespacebase.html#a5">Real</a> exp=0;
00198       <span class="keywordflow">while</span> ( <a class="code" href="Expression_8cpp.html#a1">isNum</a>(s[pos]) ) {
00199         exp = (10.0*exp) + <a class="code" href="namespacebase.html#a2">Int</a>(s[pos]-<span class="charliteral">'0'</span>);
00200         ++pos;
00201       }
00202       v = v * Math::pow(10.0,esign*exp);
00203     }
00204   }
00205 
00206   <span class="keywordflow">return</span> sign*v;
00207 }
00208 
00209   
00210 Expression Expression::expression(<span class="keyword">const</span> String&amp; s, Int&amp; pos)
00211 {
00212   Expression lhs = term(s,pos);
00213   <span class="keywordflow">while</span> (peek(s,pos,<span class="charliteral">'+'</span>) || peek(s,pos,<span class="charliteral">'-'</span>)) {
00214     String::value_type op = s[pos++];
00215     Expression rhs = term(s,pos);
00216     <span class="keywordflow">if</span> (op == <span class="charliteral">'+'</span>)
00217       lhs = lhs + rhs;
00218     <span class="keywordflow">else</span>
00219       lhs = lhs - rhs;
00220   }
00221   <span class="keywordflow">return</span> lhs;
00222 }
00223 
00224 
00225 Expression Expression::term(<span class="keyword">const</span> String&amp; s, Int&amp; pos)
00226 {
00227   Expression lhs = prod(s, pos);
00228   <span class="keywordflow">while</span> (peek(s,pos,<span class="charliteral">'*'</span>) || peek(s,pos,<span class="charliteral">'/'</span>)) {
00229     String::value_type op = s[pos++];
00230     Expression rhs = prod(s,pos);
00231     <span class="keywordflow">if</span> (op == <span class="charliteral">'*'</span>)
00232       lhs = lhs * rhs;
00233     <span class="keywordflow">else</span>
00234       lhs = lhs / rhs;
00235   }
00236   <span class="keywordflow">return</span> lhs;
00237 }
00238 
00239 
00240 Expression Expression::prod(<span class="keyword">const</span> String&amp; s, Int&amp; pos)
00241 {
00242   Expression e;
00243   <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'('</span>)) { <span class="comment">// '(' expression ')'</span>
00244     ++pos;
00245     e = expression(s,pos);
00246     <span class="keywordflow">if</span> (!peek(s,pos,<span class="charliteral">')'</span>)) <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"expecting ')' but got '"</span>)+s[pos]+<span class="stringliteral">"' in expression"</span>));
00247     ++pos;
00248   }
00249   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (peek(s,pos,<span class="stringliteral">"p["</span>)) { <span class="comment">// 'p[' index ']'</span>
00250     pos += 2;
00251     <a class="code" href="namespacebase.html#a2">Int</a> i = index(s,pos);
00252     <span class="keywordflow">if</span> (!peek(s,pos,<span class="charliteral">']'</span>)) <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"expecting ']' but got '"</span>)+s[pos]+<span class="stringliteral">"' after 'p[&lt;index&gt;' in expression"</span>));
00253     ++pos;
00254     e = Expression::p[i];
00255   }
00256   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (peek(s,pos,<span class="stringliteral">"cos("</span>)) { <span class="comment">// cos</span>
00257     pos += 4;
00258     Expression arg = expression(s,pos);
00259     e = <a class="code" href="namespacebase.html#a65">base::cos</a>(arg);
00260     <span class="keywordflow">if</span> (!peek(s,pos,<span class="charliteral">')'</span>)) <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"expecting ')' but got '"</span>)+s[pos]+<span class="stringliteral">"' after 'cos(&lt;expression&gt;' in expression"</span>));
00261     ++pos;
00262   }
00263   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (peek(s,pos,<span class="stringliteral">"sin("</span>)) { <span class="comment">// sin</span>
00264     pos += 4;
00265     Expression arg = expression(s,pos);
00266     e = <a class="code" href="namespacebase.html#a64">base::sin</a>(arg);
00267     <span class="keywordflow">if</span> (!peek(s,pos,<span class="charliteral">')'</span>)) <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"expecting ')' but got '"</span>)+s[pos]+<span class="stringliteral">"' after 'sin(&lt;expression&gt;' in expression"</span>));
00268     ++pos;
00269   }
00270   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (peek(s,pos,<span class="stringliteral">"tan("</span>)) { <span class="comment">// tan</span>
00271     pos += 4;
00272     Expression arg = expression(s,pos);
00273     e = <a class="code" href="namespacebase.html#a64">base::sin</a>(arg) / <a class="code" href="namespacebase.html#a65">base::cos</a>(arg); 
00274     <span class="keywordflow">if</span> (!peek(s,pos,<span class="charliteral">')'</span>)) <span class="keywordflow">throw</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"expecting ')' but got '"</span>)+s[pos]+<span class="stringliteral">"' after 'tan(&lt;expression&gt;' in expression"</span>));
00275     ++pos;
00276   }
00277   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (peek(s,pos,<span class="stringliteral">"pi"</span>)) { <span class="comment">// 'pi' is an alias for Expression(consts::Pi)</span>
00278     pos += 2;
00279     e = Expression(consts::Pi);
00280   }
00281   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (peek(s,pos,<span class="charliteral">'s'</span>)) { <span class="comment">// 's' as an alias for p[0] (we already checked for 'sin..')</span>
00282     ++pos;
00283     e = Expression::p[0];
00284   }
00285   <span class="keywordflow">else</span> { <span class="comment">// assume real</span>
00286     <a class="code" href="namespacebase.html#a5">Real</a> v = real(s,pos);
00287     e = Expression(v);
00288   }
00289     
00290   <span class="keywordflow">return</span> e;
00291 }
00292 
00293 
00294 
00295 <span class="comment">// Member Operators/Operations</span>
00296 Expression&amp; Expression::operator+=(<span class="keyword">const</span> Expression&amp; e)
00297 {
00298   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1SumExpression.html">SumExpression</a>(expr,e.expr));
00299   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00300 }
00301 
00302 Expression&amp; Expression::operator-=(<span class="keyword">const</span> Expression&amp; e)
00303 {
00304   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1DifferenceExpression.html">DifferenceExpression</a>(expr,e.expr));
00305   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00306 }
00307 
00308 Expression&amp; Expression::operator*=(<span class="keyword">const</span> Expression&amp; e)
00309 {
00310   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ProductExpression.html">ProductExpression</a>(expr,e.expr));
00311   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00312 }
00313 
00314 Expression&amp; Expression::operator/=(<span class="keyword">const</span> Expression&amp; e)
00315 {
00316   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1QuotientExpression.html">QuotientExpression</a>(expr,e.expr));
00317   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00318 }
00319 
00320 Expression&amp; Expression::negate()
00321 {
00322   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1NegateExpression.html">NegateExpression</a>(expr));
00323   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00324 }
00325 
00326 Expression&amp; Expression::sin()
00327 {
00328   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1SinExpression.html">SinExpression</a>(expr));
00329   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00330 }
00331 
00332 Expression&amp; Expression::cos()
00333 {
00334   expr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> CosExpression(expr));
00335   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00336 }
00337 
00338 
00339 <span class="keywordtype">void</span> Expression::serialize(Serializer&amp; s)
00340 {
00341   <span class="comment">// register instantiators for all the ExpressionNode classes for dynamic instantiation upon deserialization</span>
00342   Serializable::registerSerializableInstantiator&lt;ExpressionNode,SumExpression&gt;(sumInstantiator);
00343   Serializable::registerSerializableInstantiator&lt;ExpressionNode,DifferenceExpression&gt;(differenceInstantiator);
00344   Serializable::registerSerializableInstantiator&lt;ExpressionNode,ProductExpression&gt;(productInstantiator);
00345   Serializable::registerSerializableInstantiator&lt;ExpressionNode,QuotientExpression&gt;(quotientInstantiator);
00346   Serializable::registerSerializableInstantiator&lt;ExpressionNode,NegateExpression&gt;(negateInstantiator);
00347   Serializable::registerSerializableInstantiator&lt;ExpressionNode,ConstantExpression&gt;(constantInstantiator);
00348   Serializable::registerSerializableInstantiator&lt;ExpressionNode,VariableExpression&gt;(variableInstantiator);
00349   Serializable::registerSerializableInstantiator&lt;ExpressionNode,SinExpression&gt;(sinInstantiator);
00350   Serializable::registerSerializableInstantiator&lt;ExpressionNode,CosExpression&gt;(cosInstantiator);
00351   s.comment(<a class="code" href="namespacebase.html#a4">String</a>(<span class="stringliteral">"Symbolic expression: "</span>+<a class="code" href="namespacebase.html#a54">toString</a>()));
00352   s.baseRef(expr,<span class="stringliteral">"expression"</span>);
00353 }
00354 
00355 
00356 
00357 
00358 <span class="comment">// Simplification helper methods</span>
00359 ref&lt;ExpressionNode&gt; Expression::simplifyConstantExpressions(ref&lt;ExpressionNode&gt; expr)
00360 {
00361   <span class="keywordflow">if</span> (!expr) { <a class="code" href="base.html#a19">Assert</a>(expr); }
00362 
00363   ref&lt;ExpressionNode&gt; sexpr(expr); <span class="comment">// (potentially) simpler expression</span>
00364 
00365   <span class="keywordflow">if</span> (sexpr-&gt;isBinaryOp()) { 
00366     ref&lt;BinaryOpExpression&gt; binExpr(narrow_ref&lt;BinaryOpExpression&gt;(sexpr));
00367 
00368     <span class="comment">// recursively simplify subtree first</span>
00369     binExpr-&gt;leftArg  = simplifyConstantExpressions(binExpr-&gt;leftArg);
00370     binExpr-&gt;rightArg = simplifyConstantExpressions(binExpr-&gt;rightArg);
00371 
00372     <span class="comment">// Test for constness and zero (&lt; base::epsilon)</span>
00373     <span class="keywordtype">bool</span> leftIsConst  = binExpr-&gt;leftArg-&gt;opType()  == ExpressionNode::Constant;
00374     <span class="keywordtype">bool</span> rightIsConst = binExpr-&gt;rightArg-&gt;opType() == ExpressionNode::Constant;
00375     ref&lt;ConstantExpression&gt; leftConst;
00376     <span class="keywordflow">if</span> (leftIsConst) leftConst = narrow_ref&lt;ConstantExpression&gt;(binExpr-&gt;leftArg);
00377     <span class="keywordtype">bool</span> leftIsZero = leftIsConst?(Math::equals(leftConst-&gt;constValue,0)):<span class="keyword">false</span>;
00378     ref&lt;ConstantExpression&gt; rightConst;
00379     <span class="keywordflow">if</span> (rightIsConst) rightConst = narrow_ref&lt;ConstantExpression&gt;(binExpr-&gt;rightArg);
00380     <span class="keywordtype">bool</span> rightIsZero = rightIsConst?(Math::equals(rightConst-&gt;constValue,0)):<span class="keyword">false</span>;
00381 
00382     <span class="comment">// if both left &amp; right are constants, replace with evaluated constant</span>
00383     <span class="comment">//  or if only one is a constant and == 0, eliminate it (Sum/Diff) or replace</span>
00384     <span class="comment">//  whole expression with 0 (Prod/Div)</span>
00385 
00386     <span class="keywordflow">if</span> (binExpr-&gt;opType() == ExpressionNode::Sum) {
00387 
00388       <span class="keywordflow">if</span> (leftIsConst) {
00389         <span class="keywordflow">if</span> (rightIsConst)
00390           sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(leftConst-&gt;constValue + rightConst-&gt;constValue));
00391         <span class="keywordflow">else</span>
00392           <span class="keywordflow">if</span> (leftIsZero)
00393             sexpr = binExpr-&gt;rightArg; <span class="comment">// 0+x = x</span>
00394       }
00395       <span class="keywordflow">else</span>
00396         <span class="keywordflow">if</span> (rightIsConst &amp;&amp; rightIsZero)
00397           sexpr = binExpr-&gt;leftArg; <span class="comment">// x+0 = x</span>
00398 
00399     } <span class="comment">// end Sum</span>
00400     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (binExpr-&gt;opType() == ExpressionNode::Difference) {
00401 
00402       <span class="keywordflow">if</span> (leftIsConst) {
00403         <span class="keywordflow">if</span> (rightIsConst)
00404           sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(leftConst-&gt;constValue - rightConst-&gt;constValue));
00405         <span class="keywordflow">else</span>
00406           <span class="keywordflow">if</span> (leftIsZero)
00407             sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1NegateExpression.html">NegateExpression</a>(binExpr-&gt;rightArg)); <span class="comment">// 0-x = -x</span>
00408       }
00409       <span class="keywordflow">else</span>
00410         <span class="keywordflow">if</span> (rightIsConst &amp;&amp; rightIsZero)
00411           sexpr = binExpr-&gt;leftArg; <span class="comment">// x-0 = x</span>
00412 
00413     } <span class="comment">// end Difference</span>
00414     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (binExpr-&gt;opType() == ExpressionNode::Product) {
00415 
00416       <span class="keywordtype">bool</span> leftIsOne       = leftIsConst?(Math::equals(leftConst-&gt;constValue,1)):<span class="keyword">false</span>;
00417       <span class="keywordtype">bool</span> leftIsMinusOne  = leftIsConst?(Math::equals(leftConst-&gt;constValue,-1)):<span class="keyword">false</span>;
00418       <span class="keywordtype">bool</span> rightIsOne      = rightIsConst?(Math::equals(rightConst-&gt;constValue,1)):<span class="keyword">false</span>;
00419       <span class="keywordtype">bool</span> rightIsMinusOne = rightIsConst?(Math::equals(rightConst-&gt;constValue,-1)):<span class="keyword">false</span>;
00420 
00421       <span class="keywordflow">if</span> (leftIsConst) {
00422         <span class="keywordflow">if</span> (rightIsConst)
00423           sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(leftConst-&gt;constValue * rightConst-&gt;constValue));
00424         <span class="keywordflow">else</span> {
00425           <span class="keywordflow">if</span> (leftIsZero)
00426             sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> ConstantExpression(0)); <span class="comment">// 0*x = 0</span>
00427           <span class="keywordflow">else</span>
00428             <span class="keywordflow">if</span> (leftIsOne)
00429               sexpr = binExpr-&gt;rightArg; <span class="comment">// 1*x = x</span>
00430             <span class="keywordflow">else</span>
00431               <span class="keywordflow">if</span> (leftIsMinusOne) {
00432                 <span class="keywordflow">if</span> ( binExpr-&gt;rightArg-&gt;opType() == ExpressionNode::Negative) 
00433                   sexpr = narrow_ref&lt;NegateExpression&gt;( binExpr-&gt;rightArg )-&gt;arg; <span class="comment">// -1 * -x = x</span>
00434                 <span class="keywordflow">else</span> sexpr = ref&lt;NegateExpression&gt;( <a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1NegateExpression.html">NegateExpression</a>( binExpr-&gt;rightArg )); <span class="comment">// -1*x = -x</span>
00435               }
00436         
00437         }
00438       } 
00439       <span class="keywordflow">else</span>
00440         <span class="keywordflow">if</span> (rightIsConst) {
00441           <span class="keywordflow">if</span> (rightIsZero)
00442             sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(0)); <span class="comment">// x*0 = 0</span>
00443           <span class="keywordflow">else</span>
00444             <span class="keywordflow">if</span> (rightIsOne)
00445               sexpr = binExpr-&gt;leftArg; <span class="comment">// x*1 = x</span>
00446             <span class="keywordflow">else</span>
00447               <span class="keywordflow">if</span> (rightIsMinusOne) {
00448                 <span class="keywordflow">if</span> ( binExpr-&gt;leftArg-&gt;opType() == ExpressionNode::Negative )
00449                   sexpr = narrow_ref&lt;NegateExpression&gt;( binExpr-&gt;leftArg )-&gt;arg; <span class="comment">// -x * -1 = x</span>
00450                 <span class="keywordflow">else</span> sexpr = ref&lt;NegateExpression&gt;( <a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1NegateExpression.html">NegateExpression</a>( binExpr-&gt;leftArg )); <span class="comment">// x*-1 = -x</span>
00451               }
00452         }
00453 
00454     } <span class="comment">// end Product</span>
00455     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (binExpr-&gt;opType() == ExpressionNode::Quotient) {
00456 
00457       <span class="keywordtype">bool</span> rightIsOne = rightIsConst?(<a class="code" href="namespacebase.html#a61">equals</a>(rightConst-&gt;constValue,1)):<span class="keyword">false</span>;
00458 
00459       <span class="keywordflow">if</span> (leftIsConst) {
00460         <span class="keywordflow">if</span> (rightIsConst)
00461           sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(leftConst-&gt;constValue / rightConst-&gt;constValue));
00462         <span class="keywordflow">else</span> {
00463           <span class="keywordflow">if</span> (leftIsZero)
00464             sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> ConstantExpression(0)); <span class="comment">// 0/x = 0</span>
00465         }
00466         
00467       }
00468       <span class="keywordflow">else</span>
00469         <span class="keywordflow">if</span> (rightIsConst) {
00470           <span class="keywordflow">if</span> (rightIsZero) {
00471             <span class="keywordflow">throw</span> std::out_of_range(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"cannot divide by constant 0"</span>)); <span class="comment">// x/0 = error</span>
00472           }
00473           <span class="keywordflow">else</span>
00474             <span class="keywordflow">if</span> (rightIsOne)
00475               sexpr = binExpr-&gt;leftArg; <span class="comment">// x/1 = x</span>
00476         }
00477 
00478     } <span class="comment">// end Quotient</span>
00479 
00480   } <span class="comment">// end BinaryOp</span>
00481   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sexpr-&gt;isUnaryOp()) {
00482     ref&lt;UnaryOpExpression&gt; unaryExpr(narrow_ref&lt;UnaryOpExpression&gt;(sexpr));
00483 
00484     <span class="comment">// recursively simplify subtree first</span>
00485     unaryExpr-&gt;arg = simplifyConstantExpressions(unaryExpr-&gt;arg);
00486 
00487     <span class="comment">// Test for constness </span>
00488     <span class="keywordtype">bool</span> isConst  = unaryExpr-&gt;arg-&gt;opType() == ExpressionNode::Constant;
00489     ref&lt;ConstantExpression&gt; argConst;
00490     <span class="keywordflow">if</span> (isConst) argConst = narrow_ref&lt;ConstantExpression&gt;(unaryExpr-&gt;arg);
00491 
00492     <span class="keywordflow">if</span> (unaryExpr-&gt;opType() == ExpressionNode::Sine) {
00493       <span class="keywordflow">if</span> (isConst)
00494         sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> <a class="code" href="classbase_1_1ConstantExpression.html">ConstantExpression</a>(Math::sin(argConst-&gt;constValue)));
00495     }
00496     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unaryExpr-&gt;opType() == ExpressionNode::Cosine) {
00497       <span class="keywordflow">if</span> (isConst)
00498         sexpr = ref&lt;ExpressionNode&gt;(<a class="code" href="MemoryTracer.html#a0">NewObj</a> ConstantExpression(Math::cos(argConst-&gt;constValue)));
00499     }
00500     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unaryExpr-&gt;opType() == ExpressionNode::Negative) {
00501       ref&lt;NegateExpression&gt; nexpr( narrow_ref&lt;NegateExpression&gt;(unaryExpr) );
00502       <span class="keywordflow">if</span> (nexpr-&gt;arg-&gt;opType() == ExpressionNode::Constant) {
00503         <span class="keywordtype">bool</span> isZero = Math::equals(ref&lt;ConstantExpression&gt;(narrow_ref&lt;ConstantExpression&gt;(nexpr-&gt;arg))-&gt;constValue,0);
00504         <span class="keywordflow">if</span> (isZero)
00505           sexpr = nexpr-&gt;arg;
00506       }
00507       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nexpr-&gt;arg-&gt;opType() == ExpressionNode::Negative) {
00508         sexpr = narrow_ref&lt;NegateExpression&gt;(nexpr-&gt;arg)-&gt;arg;
00509       }
00510     } <span class="comment">// end Negative</span>
00511 
00512   } <span class="comment">// end UnaryOp</span>
00513 
00514   <span class="keywordflow">return</span> sexpr;
00515 }
00516 
00517 
00518 
00519 
00520 <span class="keywordtype">void</span> base::simplify( ExpressionMatrix&amp; m ) 
00521 {
00522   <span class="keywordflow">for</span> ( <a class="code" href="namespacebase.html#a2">Int</a> r=0; r &lt; m.size1(); r++ ) {
00523     <span class="keywordflow">for</span> ( <a class="code" href="namespacebase.html#a2">Int</a> c=0; c &lt; m.size2(); c++ ) {
00524       m(r,c).simplify();
00525     }
00526   }
00527   <span class="keywordflow">return</span>;
00528 }
00529 
00530 
00531 
00532 <a class="code" href="classbase_1_1matrix.html">base::Matrix</a> base::evaluate( <span class="keyword">const</span> ExpressionMatrix&amp; m, <span class="keyword">const</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>&amp; params ) 
00533 {
00534   <a class="code" href="classbase_1_1matrix.html">Matrix</a> em(m.size1(), m.size2());
00535   <span class="keywordflow">for</span> ( <a class="code" href="namespacebase.html#a2">Int</a> r=0; r &lt; m.size1(); r++ ) 
00536     <span class="keywordflow">for</span> ( <a class="code" href="namespacebase.html#a2">Int</a> c=0; c &lt; m.size2(); c++ ) 
00537       em(r,c) = m(r,c).evaluate(params);
00538   <span class="keywordflow">return</span> em;
00539 }
00540 
00541 
<a name="l00542"></a><a class="code" href="namespacebase.html#a76">00542</a> <a class="code" href="classbase_1_1matrix.html">base::ExpressionMatrix</a> <a class="code" href="namespacebase.html#a76">base::toExpressionMatrix</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1matrix.html">Matrix</a>&amp; m)
00543 {
00544   <a class="code" href="classbase_1_1matrix.html">ExpressionMatrix</a> em(m.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(), m.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>());
00545   <span class="keywordflow">for</span>( <a class="code" href="namespacebase.html#a2">Int</a> r=0; r &lt; m.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa8">size1</a>(); r++ ) 
00546     <span class="keywordflow">for</span> ( <a class="code" href="namespacebase.html#a2">Int</a> c=0; c &lt; m.<a class="code" href="classbase_1_1matrix.html#base_1_1matrixa9">size2</a>(); c++ ) 
00547       em(r,c)=m(r,c);
00548   <span class="keywordflow">return</span> em;
00549 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:05 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
