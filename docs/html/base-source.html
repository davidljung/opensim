<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/base Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/base</h1><a href="base.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* **-*-c++-*-**************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: base 1045 2004-02-27 19:18:29Z jungd $</span>
00019 <span class="comment"> </span>
00020 <span class="comment">****************************************************************************/</span>
00021 
00022 <span class="preprocessor">#ifndef _BASE_</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define _BASE_</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include &lt;iostream&gt;</span>
00026 <span class="preprocessor">#include &lt;string&gt;</span>
00027 <span class="preprocessor">#include &lt;sstream&gt;</span>
00028 <span class="preprocessor">#include &lt;list&gt;</span>
00029 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00030 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00031 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
00032 <span class="preprocessor">#include &lt;functional&gt;</span>
00033 
00034 <span class="preprocessor">#include &lt;<a class="code" href="reflist.html">base/reflist</a>&gt;</span>
00035 
00036 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00037 <span class="preprocessor">#include &lt;string.h&gt;</span>
00038 <span class="preprocessor">#include &lt;math.h&gt;</span>
00039 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00040 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00041 <span class="preprocessor">#include &lt;GL/gl.h&gt;</span>
00042 }
00043 
00044 <span class="comment">// instantiate unit tests</span>
00045 <span class="preprocessor">#ifdef DEBUG</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define INSTANTIATE_TEST_SUITES</span>
00047 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">bool</span> _abortOnAssertionFailure;
00048 <span class="preprocessor">#endif</span>
00049 <span class="preprocessor"></span>
00050 <span class="comment">// add support for conversion to/from some Open Scene Graph (OSG) types</span>
<a name="l00051"></a><a class="code" href="base.html#a0">00051</a> <span class="preprocessor">#define USE_OSG</span>
00052 <span class="preprocessor"></span>
00053 
00054 
00055 <span class="keyword">namespace </span><a class="code" href="base_2Jamfile_8ft.html#a0">base</a> {
<a name="l00056"></a><a class="code" href="namespacebase.html#a0">00056</a>   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>     <a class="code" href="namespacebase.html#a0">Byte</a>;
<a name="l00057"></a><a class="code" href="namespacebase.html#a1">00057</a>   <span class="keyword">typedef</span> <span class="keywordtype">int</span>               <a class="code" href="namespacebase.html#a1">SInt</a>;
<a name="l00058"></a><a class="code" href="namespacebase.html#a2">00058</a>   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      <a class="code" href="namespacebase.html#a2">Int</a>;
<a name="l00059"></a><a class="code" href="namespacebase.html#a3">00059</a>   <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacebase.html#a3">LInt</a>;
<a name="l00060"></a><a class="code" href="namespacebase.html#a4">00060</a>   <span class="keyword">typedef</span> std::string       <a class="code" href="namespacebase.html#a4">String</a>;
<a name="l00061"></a><a class="code" href="namespacebase.html#a5">00061</a>   <span class="keyword">typedef</span> <span class="keywordtype">double</span>            <a class="code" href="namespacebase.html#a5">Real</a>;   <span class="comment">// Real &amp; GLreal must be the same built-in type</span>
<a name="l00062"></a><a class="code" href="namespacebase.html#a6">00062</a>   <span class="keyword">typedef</span> GLdouble          <a class="code" href="namespacebase.html#a6">GLreal</a>;
<a name="l00063"></a><a class="code" href="namespacebase.html#a7">00063</a>   <span class="keyword">const</span> GLenum <a class="code" href="namespacebase.html#a7">GL_REAL</a> = GL_DOUBLE;
<a name="l00064"></a><a class="code" href="namespacebase.html#a8">00064</a>   <span class="keyword">const</span> GLenum <a class="code" href="namespacebase.html#a8">GL_UINT</a> = GL_UNSIGNED_INT; <span class="comment">// GL_UINT must match Int</span>
00065 
00066 <span class="comment"></span>
00067 <span class="comment">  /// throw a std::runtime_error(errorstring).  If DEBUG, output an assertion failure message</span>
00068 <span class="comment">  ///  to the Log and abort() if abortOnAssertionFailure mode set</span>
00069 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a35">assertionFailure</a>(<span class="keyword">const</span> <a class="code" href="namespacebase.html#a4">String</a>&amp; errorstring);
00070   
<a name="l00071"></a><a class="code" href="namespacebase.html#a36">00071</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a36">tassert</a>(A assertion, <span class="keyword">const</span> <a class="code" href="namespacebase.html#a4">String</a>&amp; errorstring)
00072   {
00073     <span class="keywordflow">if</span> (!assertion) 
00074       <a class="code" href="namespacebase.html#a35">assertionFailure</a>(errorstring);
00075   }
00076 
<a name="l00077"></a><a class="code" href="namespacebase.html#a37">00077</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a37">clearMemory</a>(T* start, <a class="code" href="namespacebase.html#a2">Int</a> length)
00078   { memset(start, 0, size_t(length*<span class="keyword">sizeof</span>(T))); }
00079 
<a name="l00080"></a><a class="code" href="namespacebase.html#a38">00080</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a38">copyMemory</a>(<span class="keyword">const</span> T* src, T* dest, <a class="code" href="namespacebase.html#a2">Int</a> length)
00081   { memcpy(dest, src, length*<span class="keyword">sizeof</span>(T)); }
00082 
00083   <span class="comment">// convenience: subscripting &amp; indexing for list ( O(n) )</span>
<a name="l00084"></a><a class="code" href="namespacebase.html#a39">00084</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; <a class="code" href="namespacebase.html#a39">elementAt</a>(<span class="keyword">const</span> std::list&lt;T&gt;&amp; l, <span class="keyword">typename</span> std::list&lt;T&gt;::size_type i) 
00085   {
00086     <span class="keyword">typename</span> std::list&lt;T&gt;::const_iterator it = l.begin();
00087     <span class="keywordflow">while</span> ((it != l.end()) &amp;&amp; (i &gt; 0)) {
00088       ++it; --i;
00089     }
00090     <span class="keywordflow">if</span> (it == l.end()) <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">"elementAt - specified index not present"</span>);
00091     <span class="keywordflow">return</span> *it;
00092   }
00093 
<a name="l00094"></a><a class="code" href="namespacebase.html#a40">00094</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T&amp; <a class="code" href="namespacebase.html#a39">elementAt</a>(std::list&lt;T&gt;&amp; l, <span class="keyword">typename</span> std::list&lt;T&gt;::size_type i) 
00095   {
00096     <span class="keyword">typename</span> std::list&lt;T&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> it = l.begin();
00097     <span class="keywordflow">while</span> ((it != l.end()) &amp;&amp; (i &gt; 0)) {
00098       ++it; --i;
00099     }
00100     <span class="keywordflow">if</span> (it == l.end()) <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">"elementAt - specified index not present"</span>);
00101     <span class="keywordflow">return</span> *it;
00102   }
00103 
00104 
<a name="l00105"></a><a class="code" href="namespacebase.html#a41">00105</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> <a class="code" href="classbase_1_1ref.html">ref&lt;T&gt;</a> <a class="code" href="namespacebase.html#a39">elementAt</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>&amp; l, <span class="keyword">typename</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>::size_type i) 
00106   {
00107     <span class="keyword">typename</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>::const_iterator it = l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista0">begin</a>();
00108     <span class="keywordflow">while</span> ((it != l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista3">end</a>()) &amp;&amp; (i &gt; 0)) {
00109       ++it; --i;
00110     }
00111     <span class="keywordflow">if</span> (it == l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista3">end</a>()) <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">"elementAt - specified index not present"</span>);
00112     <span class="keywordflow">return</span> *it;
00113   }
00114 
<a name="l00115"></a><a class="code" href="namespacebase.html#a42">00115</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <a class="code" href="classbase_1_1ref.html">ref&lt;T&gt;</a> <a class="code" href="namespacebase.html#a39">elementAt</a>(<a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>&amp; l, <span class="keyword">typename</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>::size_type i) 
00116   {
00117     <span class="keyword">typename</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a><a class="code" href="classstd_1_1iterator.html">::iterator</a> it = l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista0">begin</a>();
00118     <span class="keywordflow">while</span> ((it != l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista3">end</a>()) &amp;&amp; (i &gt; 0)) {
00119       ++it; --i;
00120     }
00121     <span class="keywordflow">if</span> (it == l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista3">end</a>()) <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">"elementAt - specified index not present"</span>);
00122     <span class="keywordflow">return</span> *it;
00123   }
00124 
<a name="l00125"></a><a class="code" href="namespacebase.html#a43">00125</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span> std::list&lt;T&gt;::size_type <a class="code" href="namespacebase.html#a43">indexOf</a>(<span class="keyword">const</span> std::list&lt;T&gt;&amp; l, <span class="keyword">const</span> T&amp; t)
00126   {
00127     <span class="keyword">typename</span> std::list&lt;T&gt;::const_iterator it = l.begin();
00128     <span class="keyword">typename</span> std::list&lt;T&gt;::size_type index=0;
00129     <span class="keywordflow">while</span> ((it != l.end()) &amp;&amp; (*it != t)) {
00130       ++it; ++index;
00131     }
00132     <span class="keywordflow">if</span> (it == l.end()) <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">"indexOf - specificed element not in the list"</span>);
00133     <span class="keywordflow">return</span> index;
00134   }
00135 
<a name="l00136"></a><a class="code" href="namespacebase.html#a44">00136</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a44">contains</a>(<span class="keyword">const</span> std::list&lt;T&gt;&amp; l, <span class="keyword">const</span> T&amp; e)
00137   {
00138     <span class="keyword">typename</span> std::list&lt;T&gt;::const_iterator it = std::find(l.begin(), l.end(), e);
00139     <span class="keywordflow">return</span> (it != l.end());
00140   }
00141 
<a name="l00142"></a><a class="code" href="namespacebase.html#a45">00142</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> <a class="code" href="namespacebase.html#a44">contains</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>&amp; l, <a class="code" href="classbase_1_1ref.html">ref&lt;T&gt;</a> e)
00143   {
00144     <span class="keyword">typename</span> <a class="code" href="classbase_1_1reflist.html">reflist&lt;T&gt;</a>::const_iterator_const it = std::find(l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista2">const_begin</a>(), l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista5">const_end</a>(), e);
00145     <span class="keywordflow">return</span> (it != l.<a class="code" href="classbase_1_1reflist.html#base_1_1reflista5">const_end</a>());
00146   }
00147 
00148   
<a name="l00149"></a><a class="code" href="namespacebase.html#a46">00149</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a46">swap</a>(T&amp; a, T&amp; b)
00150   {
00151     <span class="keyword">const</span> T temp(a);
00152     a = b;
00153     b = temp;
00154   }
00155 
00156 
<a name="l00157"></a><a class="code" href="namespacebase.html#a47">00157</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> Op&gt; Op <a class="code" href="namespacebase.html#a47">for_all</a>(C&amp; c, Op f)
00158   {
00159     <span class="keyword">typename</span> C::const_iterator b = c.begin();
00160     <span class="keyword">typename</span> C::const_iterator e = c.end();
00161     <span class="keywordflow">return</span> std::for_each(b,e,<a class="code" href="Makefile_8in.html#a5">f</a>);
00162   }
00163 
00164 
<a name="l00165"></a><a class="code" href="classbase_1_1DeleteObject.html">00165</a>   <span class="keyword">class </span><a class="code" href="classbase_1_1DeleteObject.html">DeleteObject</a> {
00166   <span class="keyword">public</span>:
<a name="l00167"></a><a class="code" href="classbase_1_1DeleteObject.html#base_1_1DeleteObjecta0">00167</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classbase_1_1DeleteObject.html#base_1_1DeleteObjecta0">operator()</a>(<span class="keyword">const</span> T* ptr)<span class="keyword"> const </span>{ <span class="keyword">delete</span> ptr; }
00168   };
00169 
<a name="l00170"></a><a class="code" href="namespacebase.html#a48">00170</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a48">delete_all</a>(C&amp; c)
00171   {
00172     <a class="code" href="namespacebase.html#a47">for_all</a>(c, <a class="code" href="classbase_1_1DeleteObject.html">DeleteObject</a>());
00173   }
00174 
00175   
00176   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Predicate&gt;
<a name="l00177"></a><a class="code" href="namespacebase.html#a49">00177</a>   OutputIterator <a class="code" href="namespacebase.html#a49">copy_if</a>(InputIterator begin, InputIterator end,
00178                          OutputIterator destBegin, Predicate p)
00179   {
00180     <span class="keywordflow">while</span>(begin!=end) {
00181       <span class="keywordflow">if</span> (p(*begin)) *destBegin++=*begin;
00182       ++begin;
00183     }
00184     <span class="keywordflow">return</span> destBegin;
00185   }
00186 
00187   String <a class="code" href="namespacebase.html#a50">intToString</a>(Int i);
00188   String <a class="code" href="namespacebase.html#a51">realToString</a>(Real r);
00189   Int <a class="code" href="namespacebase.html#a52">stringToInt</a>(<span class="keyword">const</span> String&amp; s);
00190   Real <a class="code" href="namespacebase.html#a53">stringToReal</a>(<span class="keyword">const</span> String&amp; s);
00191 
<a name="l00192"></a><a class="code" href="namespacebase.html#a54">00192</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <a class="code" href="namespacebase.html#a4">String</a> <a class="code" href="namespacebase.html#a54">toString</a>(<span class="keyword">const</span> T&amp; t)
00193   {
00194     std::ostringstream oss;
00195     oss &lt;&lt; t;
00196     <span class="keywordflow">return</span> oss.str();
00197   }
00198 
<a name="l00199"></a><a class="code" href="namespacebase.html#a55">00199</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <a class="code" href="namespacebase.html#a55">fromString</a>(<span class="keyword">const</span> <a class="code" href="namespacebase.html#a4">String</a>&amp; s)
00200   {
00201     std::istringstream iss(s);
00202     T t;
00203     iss &gt;&gt; t;
00204     <span class="keywordflow">return</span> t;
00205   }
00206 
00207   
00208 
00209   <span class="keyword">class </span>Cloneable;
<a name="l00210"></a><a class="code" href="namespacebase.html#a56">00210</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; C&amp; <a class="code" href="namespacebase.html#a56">clone</a>(<span class="keyword">const</span> C&amp; c) 
00211   {
00212     <span class="keywordflow">return</span> dynamic_cast&lt;C&amp;&gt;( static_cast&lt;const Cloneable&amp;&gt;(c).clone());
00213   }
00214   
00215 
00216 
00217   <span class="keyword">extern</span> std::ostream&amp; _Debug;
00218   <span class="keyword">extern</span> std::ostream&amp; _Log;
00219   <span class="keyword">extern</span> std::ostream&amp; _Console;
00220 
00221   <span class="comment"></span>
00222 <span class="comment">  /// convert typeid().name() string into demangled form (e.g. "base::Object")</span>
00223 <span class="comment"></span>  String <a class="code" href="namespacebase.html#a57">demangleTypeidName</a>(<span class="keyword">const</span> String&amp; typeidName);
00224 <span class="comment"></span>
00225 <span class="comment">  /// convert type_info into qualified class name (calls demangleTypeidName() )</span>
00226 <span class="comment"></span>  String <a class="code" href="namespacebase.html#a58">className</a>(<span class="keyword">const</span> std::type_info&amp; ti);
00227 
<a name="l00228"></a><a class="code" href="namespacebase.html#a12">00228</a>   <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="namespacebase.html#a12">_currentDebugVerbosity</a>;
00229 
00230   <span class="comment">// make narrow casting explicit for readability</span>
00231   <span class="keyword">template</span> &lt;
00232     <span class="keyword">typename</span> Sub,
00233     <span class="keyword">typename</span> Super&gt;
00234   <span class="comment">//inline Sub* narrow_cast(Select&lt; SUPERSUBCLASS_STRICT(Super,Sub),Super*,NullType&gt;::Result p) { return static_cast&lt;Sub*&gt;(p); }</span>
<a name="l00235"></a><a class="code" href="namespacebase.html#a59">00235</a>   <span class="keyword">inline</span> Sub* <a class="code" href="namespacebase.html#a59">narrow_cast</a>(Super* p) { <span class="keywordflow">return</span> static_cast&lt;Sub*&gt;(p); }
00236 
00237   <span class="keyword">template</span> &lt;
00238     <span class="keyword">typename</span> Sub,
00239     <span class="keyword">typename</span> Super&gt;
00240   <span class="comment">//inline Sub&amp; narrow_cast(Select&lt; SUPERSUBCLASS_STRICT(Super,Sub),Super&amp;,NullType&gt;::Result p) { return static_cast&lt;Sub&amp;&gt;(p); }</span>
<a name="l00241"></a><a class="code" href="namespacebase.html#a60">00241</a>   <span class="keyword">inline</span> Sub&amp; <a class="code" href="namespacebase.html#a59">narrow_cast</a>(Super&amp; p) { <span class="keywordflow">return</span> static_cast&lt;Sub&amp;&gt;(p); }
00242   
00243 } <span class="comment">// base</span>
00244 
00245 
00246 <span class="preprocessor">#include &lt;<a class="code" href="MemoryTracer.html">base/MemoryTracer</a>&gt;</span>
00247 
00248 
00249 <span class="comment">// global names</span>
00250 <span class="keyword">using</span> std::for_each;
00251 <span class="keyword">using</span> std::mem_fun;
00252 
00253 <span class="comment">//using base::Byte;</span>
00254 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a2">base::Int</a>;
00255 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a1">base::SInt</a>;
00256 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a3">base::LInt</a>;
00257 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a4">base::String</a>;
00258 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a5">base::Real</a>;
00259 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a6">base::GLreal</a>;
00260 <span class="keyword">using</span> base::GL_REAL;
00261 <span class="keyword">using</span> base::GL_UINT;
00262 <span class="keyword">using</span> base::clone;
00263 <span class="keyword">using</span> base::for_all;
00264 <span class="keyword">using</span> base::narrow_cast;
00265 
00266 
00267 
00268 <span class="comment">// Use Log() funcions to output to the log file.  This will remain in</span>
00269 <span class="comment">//  release code.  Use Debug() if you want output that will dissapear</span>
00270 <span class="comment">//  in release code.  Use Console() to write on the graphical console</span>
00271 <span class="comment">//  (e.g. for user status messages etc.)</span>
00272 <span class="comment">// NB: see debugtools header for Debug() usage.</span>
00273 
00274 <span class="preprocessor">#include &lt;<a class="code" href="debugtools.html">base/debugtools</a>&gt;</span>
00275 
00276 <span class="preprocessor">#ifdef __mips</span>
00277 <span class="preprocessor"></span><span class="preprocessor">#define __func__ String("unknown")</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00279 <span class="preprocessor"></span>
00280 <span class="preprocessor">#ifdef __GNUC_</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#define _LOG_CALLER_NAME __PRETTY_FUNCTION__ &lt;&lt; " -- "</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00283"></a><a class="code" href="base.html#a1">00283</a> <span class="preprocessor"></span><span class="preprocessor">#define _LOG_CALLER_NAME base::className(typeid(*this)) &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; " -- "</span>
00284 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00285 <span class="preprocessor"></span>
<a name="l00286"></a><a class="code" href="base.html#a2">00286</a> <span class="preprocessor">#define Log(o) { base::_Log &lt;&lt; _LOG_CALLER_NAME &lt;&lt; o; }</span>
<a name="l00287"></a><a class="code" href="base.html#a3">00287</a> <span class="preprocessor"></span><span class="preprocessor">#define Logln(o) { base::_Log &lt;&lt; _LOG_CALLER_NAME &lt;&lt; o &lt;&lt; "\n"; }</span>
<a name="l00288"></a><a class="code" href="base.html#a4">00288</a> <span class="preprocessor"></span><span class="preprocessor">#define Logc(o) { base::_Log &lt;&lt; o; }</span>
<a name="l00289"></a><a class="code" href="base.html#a5">00289</a> <span class="preprocessor"></span><span class="preprocessor">#define Logcln(o) { base::_Log &lt;&lt; o &lt;&lt; "\n"; }</span>
00290 <span class="preprocessor"></span>
<a name="l00291"></a><a class="code" href="base.html#a6">00291</a> <span class="preprocessor">#define Logf(o) { base::_Log &lt;&lt; __func__ &lt;&lt; " -- " &lt;&lt; o; }</span>
<a name="l00292"></a><a class="code" href="base.html#a7">00292</a> <span class="preprocessor"></span><span class="preprocessor">#define Logfln(o) { base::_Log &lt;&lt; __func__ &lt;&lt; " -- " &lt;&lt; o &lt;&lt; "\n"; }</span>
<a name="l00293"></a><a class="code" href="base.html#a8">00293</a> <span class="preprocessor"></span><span class="preprocessor">#define Logfc(o) Logc(o)</span>
<a name="l00294"></a><a class="code" href="base.html#a9">00294</a> <span class="preprocessor"></span><span class="preprocessor">#define Logfcln(o) Logcln(o)</span>
00295 <span class="preprocessor"></span>
<a name="l00296"></a><a class="code" href="base.html#a10">00296</a> <span class="preprocessor">#define Console(o) { base::_Console &lt;&lt; o; }</span>
<a name="l00297"></a><a class="code" href="base.html#a11">00297</a> <span class="preprocessor"></span><span class="preprocessor">#define Consoleln(o) { base::_Console &lt;&lt; o &lt;&lt; std::endl; }</span>
00298 <span class="preprocessor"></span>
00299 
00300 
00301 <span class="comment">// Often, when an Assert() fails, it is not clear where the exception</span>
00302 <span class="comment">//  was raised from the message alone.  Enabling this flag will cause</span>
00303 <span class="comment">//  the program to abort() from inside Assert() so that a debugger </span>
00304 <span class="comment">//  stack trace can show the point of failure.</span>
00305 <span class="preprocessor">#ifdef DEBUG</span>
00306 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="keywordtype">bool</span> _abortOnAssertionFailure;
00307 <span class="preprocessor">  #define abortOnAssertionFailureEnabled(e) _abortOnAssertionFailure=(e)</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00309"></a><a class="code" href="base.html#a12">00309</a> <span class="preprocessor"></span><span class="preprocessor">  #define abortOnAssertionFailureEnabled(e)</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00311 <span class="preprocessor"></span>
00312 
00313 <span class="comment">// During development it is not unusual for exceptions to be thrown in unexpected places. For example,</span>
00314 <span class="comment">//  from a function declared with throw().  It also happens when an exception tries to propagate</span>
00315 <span class="comment">//  through C code in the call stack.  For example, this is common if the main loop of the app</span>
00316 <span class="comment">//  is being executed from a C library callback (e.g. from GLUT).</span>
00317 <span class="comment">//  This typically results in a call to abort() before the exception is caught.  The only way to trace where</span>
00318 <span class="comment">//  the exception was thrown in that case is via the debugger.  To make life a little easier, in DEBUG mode</span>
00319 <span class="comment">//  the Exception() macro is defined to print the exception text upon construction - so it can be seen even if</span>
00320 <span class="comment">//  the exception is not caught.  However, this can be annoying in circumstances when exceptions are</span>
00321 <span class="comment">//  expected (for example, in test cases that test for correct exception throwing).  Consequently, it may</span>
00322 <span class="comment">//  be disabled.</span>
00323 <span class="preprocessor">#ifdef DEBUG</span>
00324 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="keywordtype">bool</span> _outputExceptionOnConstruction;
00325 <span class="preprocessor">  #define exceptionOutputEnabled(e) _outputExceptionOnConstruction=(e)</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00327"></a><a class="code" href="base.html#a13">00327</a> <span class="preprocessor"></span><span class="preprocessor">  #define exceptionOutputEnabled(e)</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00329 <span class="preprocessor"></span>
00330 <span class="comment">// If an exception is caught and the program exits normally, it may still be useful for</span>
00331 <span class="comment">//  debugging to know where it was originally constructed.  For this reason, it is possible</span>
00332 <span class="comment">//  to cause an abort() at the construction point.</span>
00333 <span class="preprocessor">#ifdef DEBUG</span>
00334 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="keywordtype">bool</span> _abortOnExceptionConstruction;
00335 <span class="preprocessor">  #define abortOnExceptionConstructionEnabled(e) _abortOnExceptionConstruction=(e)</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00337"></a><a class="code" href="base.html#a14">00337</a> <span class="preprocessor"></span><span class="preprocessor">  #define abortOnExceptionConstructionEnabled(e)</span>
00338 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00339 <span class="preprocessor"></span>
00340 
00341 
00342 <span class="preprocessor">#ifdef __GNUC__</span>
00343 <span class="preprocessor"></span>
00344 <span class="preprocessor">  #ifdef DEBUG</span>
00345 <span class="preprocessor"></span><span class="preprocessor">    #define _PrintConstructingException(o) \</span>
00346 <span class="preprocessor">              printf("constructing exception: %s\n", \</span>
00347 <span class="preprocessor">               (String(__PRETTY_FUNCTION__)+" (line "+base::intToString(__LINE__)+") - "+String(o)).c_str())</span>
00348 <span class="preprocessor"></span>  
00349   
00350 <span class="preprocessor">    #define Exception(o) ( \</span>
00351 <span class="preprocessor">                          ( (_abortOnExceptionConstruction? \</span>
00352 <span class="preprocessor">                              (_PrintConstructingException(o),::abort(),0) \</span>
00353 <span class="preprocessor">                            : (_outputExceptionOnConstruction?(_PrintConstructingException(o)):(0)) \</span>
00354 <span class="preprocessor">                            ) \</span>
00355 <span class="preprocessor">                          ), \</span>
00356 <span class="preprocessor">                             String(String("exception thrown: ")+__PRETTY_FUNCTION__+":\n - "+String(o)) \</span>
00357 <span class="preprocessor">                         )</span>
00358 <span class="preprocessor"></span>
00359 
00360 <span class="preprocessor">  #else   // ndef DEBUG</span>
00361 <span class="preprocessor"></span><span class="preprocessor">    #define Exception(o) String(String("exception thrown: ")+__PRETTY_FUNCTION__+" - "+String(o))</span>
00362 <span class="preprocessor"></span><span class="preprocessor">  #endif  // DEBUG</span>
00363 <span class="preprocessor"></span>
00364 <span class="preprocessor">  #define Exceptionf(o) String(String("exception thrown: ")+__PRETTY_FUNCTION__+":\n - "+String(o))</span>
00365 <span class="preprocessor"></span><span class="preprocessor">  #define Assertion(o) String(String("assertion failed: ")+__PRETTY_FUNCTION__+" (line "+base::intToString(__LINE__)+") - "+String(o))</span>
00366 <span class="preprocessor"></span><span class="preprocessor">  #define Assertionf(o) String(String("assertion failed: ")+__PRETTY_FUNCTION__+" (line "+base::intToString(__LINE__)+") - "+String(o))</span>
00367 <span class="preprocessor"></span>
00368 
00369 <span class="preprocessor">#else // ndef __GNUC__</span>
00370 <span class="preprocessor"></span>
00371 <span class="preprocessor">  #ifdef DEBUG</span>
00372 <span class="preprocessor"></span>
00373 <span class="preprocessor">    #define _PrintConstructingException(o) \</span>
00374 <span class="preprocessor">              printf("constructing exception: %s\n", \</span>
00375 <span class="preprocessor">               (String(base::className(typeid(*this)))+"::"+String(__func__)+" - "+String(o)).c_str())</span>
00376 <span class="preprocessor"></span>  
00377 <span class="preprocessor">    #define Exception(o) ( \</span>
00378 <span class="preprocessor">                           ( (_abortOnExceptionConstruction? \</span>
00379 <span class="preprocessor">                               (_PrintConstructingException(o),::abort(),0) \</span>
00380 <span class="preprocessor">                             : (_outputExceptionOnConstruction?(_PrintConstructingException(o)):(0)) \</span>
00381 <span class="preprocessor">                             ) \</span>
00382 <span class="preprocessor">                           ), \</span>
00383 <span class="preprocessor">                              String(String("exception thrown: ")+String(base::className(typeid(*this)))+"::"+String(__func__)+":\n - "+String(o)) \</span>
00384 <span class="preprocessor">                         )</span>
00385 <span class="preprocessor"></span><span class="preprocessor">  #else</span>
<a name="l00386"></a><a class="code" href="base.html#a15">00386</a> <span class="preprocessor"></span><span class="preprocessor">    #define Exception(o) String(String("exception thrown: ")+String(base::className(typeid(*this)))+"::"+String(__func__)+":\n - "+String(o))</span>
00387 <span class="preprocessor"></span><span class="preprocessor">  #endif</span>
<a name="l00388"></a><a class="code" href="base.html#a16">00388</a> <span class="preprocessor"></span><span class="preprocessor">  #define Exceptionf(o) String(String("exception thrown: ")+String(__func__)+":\n - "+String(o))</span>
<a name="l00389"></a><a class="code" href="base.html#a17">00389</a> <span class="preprocessor"></span><span class="preprocessor">  #define Assertion(o) String(String("assertion failed: ")+String(base::className(typeid(*this)))+"::"+String(__func__)+" - "+String(o))</span>
<a name="l00390"></a><a class="code" href="base.html#a18">00390</a> <span class="preprocessor"></span><span class="preprocessor">  #define Assertionf(o) String(String("assertion failed: ")+String(__func__)+" - "+String(o))</span>
00391 <span class="preprocessor"></span>
00392 <span class="preprocessor">#endif // __GNUC__</span>
00393 <span class="preprocessor"></span>
00394 <span class="preprocessor">#ifdef DEBUG</span>
00395 <span class="preprocessor"></span>
00396 <span class="preprocessor">  #define Assert(a) { if (!(a)) base::assertionFailure(Assertion(#a)); }</span>
00397 <span class="preprocessor"></span><span class="preprocessor">  #define Assertf(a) { if (!(a)) base::assertionFailure(Assertionf(#a)); }</span>
00398 <span class="preprocessor"></span><span class="preprocessor">  #define Assertm(a,s) { if (!(a)) base::assertionFailure(Assertion(s)); }</span>
00399 <span class="preprocessor"></span><span class="preprocessor">  #define Assertmf(a,s) { if (!(a)) base::assertionFailure(Assertionf(s)); }</span>
00400 <span class="preprocessor"></span><span class="preprocessor">#else // ndef DEBUG</span>
<a name="l00401"></a><a class="code" href="base.html#a19">00401</a> <span class="preprocessor"></span><span class="preprocessor">  #define Assert(a) </span>
<a name="l00402"></a><a class="code" href="base.html#a20">00402</a> <span class="preprocessor"></span><span class="preprocessor">  #define Assertf(a) </span>
<a name="l00403"></a><a class="code" href="base.html#a21">00403</a> <span class="preprocessor"></span><span class="preprocessor">  #define Assertm(a,s) </span>
<a name="l00404"></a><a class="code" href="base.html#a22">00404</a> <span class="preprocessor"></span><span class="preprocessor">  #define Assertmf(a,s) </span>
00405 <span class="preprocessor"></span><span class="preprocessor">#endif // DEBUG</span>
00406 <span class="preprocessor"></span>
<a name="l00407"></a><a class="code" href="base.html#a23">00407</a> <span class="preprocessor">#define Assertifm(f,a,s) Assertm(!f || a,s)</span>
<a name="l00408"></a><a class="code" href="base.html#a24">00408</a> <span class="preprocessor"></span><span class="preprocessor">#define Assertifmf(f,a,s) Assertmf(!f || a,s)</span>
00409 <span class="preprocessor"></span>
<a name="l00410"></a><a class="code" href="base.html#a25">00410</a> <span class="preprocessor">#define instanceof(var,type) (dynamic_cast&lt;type*&gt;(&amp;var) != 0)</span>
00411 <span class="preprocessor"></span>
00412 
00413 
00414 <span class="comment">// More globals</span>
00415 
00416 <span class="preprocessor">#include &lt;<a class="code" href="array.html">base/array</a>&gt;</span>
00417 <span class="preprocessor">#include &lt;<a class="code" href="ref.html">base/ref</a>&gt;</span>
00418 <span class="keyword">using</span> <a class="code" href="classbase_1_1array.html">base::array</a>;
00419 <span class="keyword">using</span> <a class="code" href="classbase_1_1ref.html">base::ref</a>;
00420 
00421 
00422 <span class="preprocessor">#endif</span>
00423 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:04 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
