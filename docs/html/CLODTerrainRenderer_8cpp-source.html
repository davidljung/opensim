<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: gfx/CLODTerrainRenderer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>gfx/CLODTerrainRenderer.cpp</h1><a href="CLODTerrainRenderer_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//</span>
00002 <span class="comment">// This code is a hacked up version of the Demeter Terrain</span>
00003 <span class="comment">// code from http://www.terrainengine.com</span>
00004 <span class="comment">// (hacked up because I removed the SDL and CommonC++</span>
00005 <span class="comment">//  dependencies, and helpded it compile with gcc3.x)</span>
00006 <span class="comment">// -David Jung.</span>
00007 <span class="comment">//</span>
00008 
00009 <span class="comment">// Demeter Terrain Visualization Library by Clay Fowler</span>
00010 <span class="comment">// Copyright (C) 2001 Clay Fowler</span>
00011 
00012 <span class="comment">/*</span>
00013 <span class="comment">This library is free software; you can redistribute it and/or</span>
00014 <span class="comment">modify it under the terms of the GNU Library General Public</span>
00015 <span class="comment">License as published by the Free Software Foundation; either</span>
00016 <span class="comment">version 2 of the License, or (at your option) any later version.</span>
00017 <span class="comment"></span>
00018 <span class="comment">This library is distributed in the hope that it will be useful,</span>
00019 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00020 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00021 <span class="comment">Library General Public License for more details.</span>
00022 <span class="comment"></span>
00023 <span class="comment">You should have received a copy of the GNU Library General Public</span>
00024 <span class="comment">License along with this library; if not, write to the</span>
00025 <span class="comment">Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
00026 <span class="comment">Boston, MA  02111-1307, USA.</span>
00027 <span class="comment">*/</span>
00028 
00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
00030 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00031"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a0">00031</a> <span class="preprocessor">#define GL_GLEXT_PROTOTYPES</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#include &lt;GL/gl.h&gt;</span>
00033 <span class="preprocessor">#include &lt;GL/glext.h&gt;</span>
00034 }
00035 
00036 <span class="preprocessor">#include &lt;<a class="code" href="CLODTerrainRenderer.html">gfx/CLODTerrainRenderer</a>&gt;</span>
00037 <span class="preprocessor">#include &lt;<a class="code" href="BitArray.html">base/BitArray</a>&gt;</span>
00038 
00039 
00040 <span class="preprocessor">#include &lt;string&gt;</span>
00041 
00042 <span class="preprocessor">#include &lt;osg/Image&gt;</span>
00043 
00044 <span class="preprocessor">#include &lt;osgDB/Registry&gt;</span>
00045 <span class="preprocessor">#include &lt;osgDB/ReadFile&gt;</span>
00046 
00047 <span class="keyword">using</span> std::cout;
00048 <span class="keyword">using</span> std::endl;
00049 <span class="keyword">using</span> std::flush;
00050 <span class="keyword">using</span> std::vector;
00051 <span class="keyword">using</span> std::string;
00052 
00053 <span class="keyword">using</span> <span class="keyword">namespace </span><a class="code" href="gfx_2Jamfile_8ft.html#a0">gfx</a>;
00054 <span class="keyword">using</span> <span class="keyword">namespace </span>demeter;
00055 
00056 <span class="keyword">using</span> <a class="code" href="classbase_1_1BitArray.html">base::BitArray</a>;
00057 
00058 <span class="preprocessor">#ifndef GLAPIENTRY</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#define GLAPIENTRY</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00061 <span class="preprocessor"></span>
<a name="l00062"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a1">00062</a> <span class="preprocessor">#define GL_CLAMP_TO_EDGE_EXT                0x812F</span>
<a name="l00063"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a2">00063</a> <span class="preprocessor"></span><span class="preprocessor">#define GL_TEXTURE0_ARB                     0x84C0</span>
<a name="l00064"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a3">00064</a> <span class="preprocessor"></span><span class="preprocessor">#define GL_TEXTURE1_ARB                     0x84C1</span>
<a name="l00065"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a4">00065</a> <span class="preprocessor"></span><span class="preprocessor">#define GL_COMBINE_RGB_EXT                                      0x8571</span>
<a name="l00066"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a5">00066</a> <span class="preprocessor"></span><span class="preprocessor">#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT     0x81A8</span>
<a name="l00067"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a6">00067</a> <span class="preprocessor"></span><span class="preprocessor">#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT     0x81A9</span>
<a name="l00068"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a7">00068</a> <span class="preprocessor"></span><span class="preprocessor">#define COMPRESSED_RGB_S3TC_DXT1_EXT        0x83F0</span>
00069 <span class="preprocessor"></span>
<a name="l00070"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a8">00070</a> <span class="keyword">typedef</span> void (GLAPIENTRY *<a class="code" href="CLODTerrainRenderer_8cpp.html#a8">PFNGLMULTITEXCOORD2FARBPROC</a>)(GLenum texture,GLfloat s,GLfloat t);
<a name="l00071"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a9">00071</a> <span class="keyword">typedef</span> void (GLAPIENTRY *<a class="code" href="CLODTerrainRenderer_8cpp.html#a9">PFNGLACTIVETEXTUREARBPROC</a>)(GLenum texture);
00072 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
00073 <span class="preprocessor"></span><span class="keyword">typedef</span> void (GLAPIENTRY *PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
00074 <span class="keyword">typedef</span> void (GLAPIENTRY *PFNGLUNLOCKARRAYSEXTPROC) (<span class="keywordtype">void</span>);
00075 <span class="preprocessor">#endif</span>
00076 <span class="preprocessor"></span>
00077 
<a name="l00078"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a10">00078</a> <a class="code" href="CLODTerrainRenderer_8cpp.html#a8">PFNGLMULTITEXCOORD2FARBPROC</a> <a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a> = NULL;
<a name="l00079"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a11">00079</a> <a class="code" href="CLODTerrainRenderer_8cpp.html#a9">PFNGLACTIVETEXTUREARBPROC</a> <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a> = NULL;
00080 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
00081 <span class="preprocessor"></span>    PFNGLLOCKARRAYSEXTPROC glLockArraysEXT_ptr = NULL;
00082     PFNGLUNLOCKARRAYSEXTPROC glUnlockArraysEXT_ptr = NULL;
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor"></span>
00085 
<a name="l00086"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a12">00086</a> <a class="code" href="classdemeter_1_1Settings.html">Settings</a>* <a class="code" href="CLODTerrainRenderer_8cpp.html#a12">pSettingsInstance</a> = NULL; <span class="comment">// Singleton instance of the global settings</span>
00087 
<a name="l00088"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a13">00088</a> <span class="keywordtype">float</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> = 0.0f;
<a name="l00089"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a14">00089</a> <span class="keywordtype">float</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a14">numLevels</a> = 0.0f;
<a name="l00090"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a15">00090</a> <span class="keywordtype">float</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a15">hashDelta</a> = 0.0f;
00091 
00092 GLuint <a class="code" href="CLODTerrainRenderer_8cpp.html#a16">CreateTexture</a>(<a class="code" href="namespacedemeter.html#a0">Uint8</a>* pTexels,<span class="keywordtype">int</span> width,<span class="keywordtype">int</span> height,<span class="keywordtype">int</span> rowLength,<span class="keywordtype">int</span> border,<span class="keywordtype">int</span> internalFormat,<span class="keywordtype">bool</span> bClamp,<span class="keywordtype">bool</span> bColorKey = <span class="keyword">false</span>);
00093 <span class="keywordtype">void</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a17">LoadImage</a>(<span class="keywordtype">char</span>* szFilename,<span class="keywordtype">int</span>* pWidth,<span class="keywordtype">int</span>* pHeight,<a class="code" href="namespacedemeter.html#a0">Uint8</a>** pBuffer,<span class="keywordtype">bool</span> bColorKey = <span class="keyword">false</span>);
00094 <span class="keywordtype">int</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a18">RayPlaneIntersect</a>(<a class="code" href="classdemeter_1_1Ray.html">Ray</a> *ray,<a class="code" href="classdemeter_1_1Plane.html">Plane</a> *plane,<a class="code" href="classdemeter_1_1Vector.html">Vector</a>* point,<span class="keywordtype">float</span> *distance);
00095 <span class="keywordtype">int</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a19">RayBoxIntersect</a>(<a class="code" href="classdemeter_1_1Ray.html">Ray</a> *ray,Box *box,<a class="code" href="classdemeter_1_1Vector.html">Vector</a> *point,<span class="keywordtype">float</span> *distance);
00096 <span class="keywordtype">bool</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>(<span class="keywordtype">double</span> number);
00097 
<a name="l00098"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka0">00098</a> TerrainBlock::TerrainBlock(<a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>* pParent)
00099 {
00100     m_pChildren = NULL;
00101     m_pParent = pParent;
00102     m_pTriangleStrip = NULL;
00103 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
00104 <span class="preprocessor"></span>        m_pTriangles = NULL;
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor"></span>}
00107 
<a name="l00108"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka1">00108</a> TerrainBlock::TerrainBlock(<span class="keywordtype">int</span> homeVertex,<span class="keywordtype">int</span> stride,<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain,<a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>* pParent)
00109 {
00110     m_pTriangleStrip = NULL;
00111     m_pParent = pParent;
00112     m_HomeIndex = homeVertex;
00113     m_Stride = stride;
00114     <span class="keyword">static</span> <span class="keywordtype">int</span> numBlocksBuilt = 0;
00115 
00116         <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
00117         {
00118         <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a15">hashDelta</a> &lt;= numBlocksBuilt++)
00119         {
00120             cout &lt;&lt; <span class="stringliteral">"#"</span> &lt;&lt; flush;
00121             numBlocksBuilt = 0;
00122         }
00123         }
00124 <span class="comment">// Find this block's bounding box.</span>
00125     <span class="keywordtype">float</span> minElevation = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina14">GetElevation</a>(homeVertex);
00126     <span class="keywordtype">float</span> maxElevation = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina14">GetElevation</a>(homeVertex);
00127     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = homeVertex; i &lt;= homeVertex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() * m_Stride; i += pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>())
00128     {
00129       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt; i + m_Stride; j++)
00130         {
00131           <span class="keywordtype">float</span> elevation = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina14">GetElevation</a>(j);
00132           <span class="keywordflow">if</span> (elevation &lt; minElevation)
00133             minElevation = elevation;
00134           <span class="keywordflow">if</span> (maxElevation &lt; elevation)
00135             maxElevation = elevation;
00136         }
00137     }
00138     <a class="code" href="classdemeter_1_1Vector.html">Vector</a> boxUpperLeft,boxLowerRight,boxCenter;
00139     boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[homeVertex].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr34">m_OffsetX</a>;
00140     boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[homeVertex].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr35">m_OffsetY</a>;
00141     boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = maxElevation;
00142     boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[homeVertex + m_Stride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_Stride].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr34">m_OffsetX</a>;
00143     boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[homeVertex + m_Stride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_Stride].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr35">m_OffsetY</a>;
00144     boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = minElevation;
00145     boxCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = (boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>) * 0.5f;
00146     boxCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = (boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>) * 0.5f;
00147     boxCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = (boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> + boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>) * 0.5f;
00148     m_BoundingBoxUpperCenter = boxCenter;
00149     m_BoundingBoxLowerCenter = boxCenter;
00150     m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = boxUpperLeft.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00151     m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = boxLowerRight.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00152 
00153 <span class="comment">// Recursively build children blocks of this block.</span>
00154     <span class="keywordflow">if</span> (2 &lt; m_Stride)
00155     {
00156       m_pChildren = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>*[4];
00157       <span class="keywordtype">int</span> childrenStride = m_Stride / 2;
00158       m_pChildren[0] = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka0">TerrainBlock</a>(homeVertex,                                                                                                                                     childrenStride,pTerrain,<span class="keyword">this</span>);
00159       m_pChildren[1] = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka0">TerrainBlock</a>(homeVertex + childrenStride,                                                                                                    childrenStride,pTerrain,<span class="keyword">this</span>);
00160       m_pChildren[2] = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka0">TerrainBlock</a>(homeVertex + childrenStride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + childrenStride,    childrenStride,pTerrain,<span class="keyword">this</span>);
00161       m_pChildren[3] = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka0">TerrainBlock</a>(homeVertex + childrenStride * pTerrain-&gt;GetWidthVertices(),                                     childrenStride,pTerrain,<span class="keyword">this</span>);
00162     }
00163     <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka13">CalculateGeometry</a>(pTerrain);
00164 }
00165 
<a name="l00166"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka2">00166</a> TerrainBlock::~TerrainBlock()
00167 {
00168   m_pParent = NULL;
00169   m_pTriangleStrip = NULL;
00170   <span class="keywordflow">if</span> (m_pChildren != NULL &amp;&amp; 2 &lt; m_Stride)
00171     {
00172       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)
00173         {
00174           <span class="keyword">delete</span> m_pChildren[i];
00175           m_pChildren[i] = NULL;
00176         }
00177       <span class="keyword">delete</span>[] m_pChildren;
00178     }
00179 }
00180 
<a name="l00181"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka7">00181</a> <span class="keywordtype">bool</span> TerrainBlock::IsActive()
00182 {
00183   <span class="keywordflow">return</span> m_bIsActive;
00184 }
00185 
<a name="l00186"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">00186</a> <span class="keywordtype">void</span> TerrainBlock::Tessellate(<span class="keywordtype">double</span>* pMatModelView,<span class="keywordtype">double</span>* pMatProjection,<span class="keywordtype">int</span>* pViewport,<a class="code" href="classdemeter_1_1TriangleStrip.html">TriangleStrip</a>* pTriangleStrips,<a class="code" href="classdemeter_1_1TriangleFan.html">TriangleFan</a>* pTriangleFans,<span class="keywordtype">int</span>* pCountStrips,<span class="keywordtype">int</span>* pCountFans,<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
00187 {
00188   <span class="keywordflow">if</span> ((*pCountStrips &lt; pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr31">m_MaxNumberOfPrimitives</a>) &amp;&amp; pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina35">CubeInFrustum</a>(m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,m_CubeCenterZ,m_CubeSize))
00189     {
00190       <span class="keywordflow">if</span> (m_Stride == 2)
00191         {
00192           <span class="keywordtype">int</span> offset;
00193           
00194           pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(m_HomeIndex,1);
00195           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[0] = m_HomeIndex;
00196           offset = m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00197           pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00198           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[1] = offset;
00199           offset = m_HomeIndex + 1;
00200           pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00201           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[2] = offset;
00202           offset = m_HomeIndex + 1 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00203           pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00204           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[3] = offset;
00205           offset = m_HomeIndex + 2;
00206           pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00207           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[4] = offset;
00208           offset = m_HomeIndex + 2 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00209           pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00210           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[5] = offset;
00211           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr1">m_NumberOfVertices</a> = 6;
00212           pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr5">m_bEnabled</a> = <span class="keyword">true</span>;
00213           *pCountStrips = *pCountStrips + 1;
00214           
00215           <span class="keywordflow">if</span> (*pCountStrips &lt; pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr31">m_MaxNumberOfPrimitives</a>)
00216             {
00217               offset = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_HomeIndex;
00218               pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00219               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[0] = offset;
00220               offset = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00221               pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00222               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[1] = offset;
00223               offset = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_HomeIndex + 1;
00224               pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00225               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[2] = offset;
00226               offset = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_HomeIndex + 1 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00227               pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00228               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[3] = offset;
00229               offset = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_HomeIndex + 2;
00230               pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00231               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[4] = offset;
00232               offset = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + m_HomeIndex + 2 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00233               pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00234               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[5] = offset;
00235               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr1">m_NumberOfVertices</a> = 6;
00236               pTriangleStrips[*pCountStrips].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr5">m_bEnabled</a> = <span class="keyword">true</span>;
00237               *pCountStrips = *pCountStrips + 1;
00238             }
00239           
00240           m_bIsActive = <span class="keyword">true</span>;
00241         }
00242       <span class="keywordflow">else</span>
00243         {
00244           <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr23">m_MaximumVisibleBlockSize</a> &lt; m_Stride)
00245             {
00246               m_pChildren[0]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00247               m_pChildren[1]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00248               m_pChildren[2]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00249               m_pChildren[3]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00250               m_bIsActive = <span class="keyword">false</span>;
00251               m_bChildrenActive = <span class="keyword">true</span>;
00252             }
00253           <span class="keywordflow">else</span>
00254             {
00255               <span class="keywordtype">double</span> screenTopX,screenTopY,screenTopZ,screenBottomX,screenBottomY,screenBottomZ;
00256               <span class="keywordtype">float</span> halfWidth = m_CubeSize * 0.5f;
00257               <span class="comment">// Check the vertical screen size of the block </span>
00258               gluProject(m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>,pMatModelView,pMatProjection,pViewport,&amp;screenTopX,&amp;screenTopY,&amp;screenTopZ);
00259               gluProject(m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>,pMatModelView,pMatProjection,pViewport,&amp;screenBottomX,&amp;screenBottomY,&amp;screenBottomZ);
00260               <span class="keywordtype">float</span> screenDistVertical = fabs(screenTopY - screenBottomY);
00261                                 <span class="comment">// Use both the X and Y axes to find the horizontal screen size of the block by using the larger of the two.</span>
00262               gluProject(m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> - halfWidth,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>,pMatModelView,pMatProjection,pViewport,&amp;screenTopX,&amp;screenTopY,&amp;screenTopZ);
00263               gluProject(m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + halfWidth,m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>,pMatModelView,pMatProjection,pViewport,&amp;screenBottomX,&amp;screenBottomY,&amp;screenBottomZ);
00264               <span class="keywordtype">float</span> screenDistX = fabs(screenTopX - screenBottomX);
00265               gluProject(m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> - halfWidth,m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>,pMatModelView,pMatProjection,pViewport,&amp;screenTopX,&amp;screenTopY,&amp;screenTopZ);
00266               gluProject(m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + halfWidth,m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>,pMatModelView,pMatProjection,pViewport,&amp;screenBottomX,&amp;screenBottomY,&amp;screenBottomZ);
00267               <span class="keywordtype">float</span> screenDistY = fabs(screenTopX - screenBottomX);
00268               <span class="keywordtype">float</span> screenDistHorizontal = screenDistX &lt; screenDistY ? screenDistY : screenDistX;
00269               
00270                                 <span class="comment">// Use the smaller of vertical and horizontal screen size to decide whether or not the block should be simplified.</span>
00271               <span class="keywordtype">float</span> screenDist = screenDistHorizontal &lt; screenDistVertical ? screenDistHorizontal : screenDistVertical;
00272               
00273               <span class="keywordflow">if</span> (screenDist &lt;= pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina7">GetDetailThreshold</a>())
00274                 {
00275                   <span class="comment">// This block is simplified, so add its triangles to the list and stop recursing.</span>
00276                   CreateTriangleStrip(pTriangleStrips,pCountStrips,pTerrain);
00277                   m_bIsActive = <span class="keyword">true</span>;
00278                   m_bChildrenActive = <span class="keyword">false</span>;
00279                 }
00280               <span class="keywordflow">else</span>
00281                 {
00282                   m_pChildren[0]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00283                   m_pChildren[1]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00284                   m_pChildren[2]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00285                   m_pChildren[3]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(pMatModelView,pMatProjection,pViewport,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans,pTerrain);
00286                   m_bIsActive = <span class="keyword">false</span>;
00287                   m_bChildrenActive = <span class="keyword">true</span>;
00288                 }
00289             }
00290         }
00291     }
00292   <span class="keywordflow">else</span>
00293     {
00294       m_bIsActive = <span class="keyword">false</span>;
00295       m_bChildrenActive = <span class="keyword">false</span>;
00296     }
00297 }
00298 
00299 <span class="keyword">inline</span> <span class="keywordtype">void</span> TerrainBlock::CreateTriangleStrip(<a class="code" href="classdemeter_1_1TriangleStrip.html">TriangleStrip</a>* pTriangleStrips,<span class="keywordtype">int</span>* pCount,<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
00300 {
00301   <span class="keywordflow">if</span> (*pCount &lt; pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr31">m_MaxNumberOfPrimitives</a>)
00302     {
00303       pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(m_HomeIndex,1);
00304       pTriangleStrips[*pCount].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[0] = m_HomeIndex;
00305       <span class="keywordtype">int</span> offset = m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() * m_Stride;
00306       pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00307       pTriangleStrips[*pCount].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[1] = offset;
00308       offset = m_HomeIndex + m_Stride;
00309       pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00310       pTriangleStrips[*pCount].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[2] = offset;
00311       offset = m_HomeIndex + m_Stride + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() * m_Stride;
00312       pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind4">SetVertexStatus</a>(offset,1);
00313       pTriangleStrips[*pCount].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr0">m_pVertices</a>[3] = offset;
00314       pTriangleStrips[*pCount].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr5">m_bEnabled</a> = <span class="keyword">true</span>;
00315       pTriangleStrips[*pCount].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr1">m_NumberOfVertices</a> = 4;
00316       
00317       m_pTriangleStrip = &amp;pTriangleStrips[*pCount];
00318       *pCount = *pCount + 1;
00319     }
00320 }
00321 
<a name="l00322"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka11">00322</a> <span class="keywordtype">void</span> TerrainBlock::EnableStrip(<span class="keywordtype">bool</span> bEnabled)
00323 {
00324   m_pTriangleStrip-&gt;<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr5">m_bEnabled</a> = <span class="keyword">false</span>;
00325 }
00326 
<a name="l00327"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka10">00327</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> TerrainBlock::GetStride()
00328 {
00329   <span class="keywordflow">return</span> m_Stride;
00330 }
00331 
<a name="l00332"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka9">00332</a> <span class="keyword">inline</span> <a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>* TerrainBlock::GetParent()
00333 {
00334   <span class="keywordflow">return</span> m_pParent;
00335 }
00336 
<a name="l00337"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka12">00337</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> TerrainBlock::GetHomeIndex()
00338 {
00339   <span class="keywordflow">return</span> m_HomeIndex;
00340 }
00341 
<a name="l00342"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">00342</a> <span class="keywordtype">void</span> TerrainBlock::RepairCracks(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain,<a class="code" href="classdemeter_1_1TriangleStrip.html">TriangleStrip</a>* pTriangleStrips,<a class="code" href="classdemeter_1_1TriangleFan.html">TriangleFan</a>* pTriangleFans,<span class="keywordtype">int</span>* pCountStrips,<span class="keywordtype">int</span>* pCountFans)
00343 {
00344   <span class="keywordflow">if</span> (2 &lt; m_Stride)
00345     {
00346       <span class="keywordflow">if</span> (m_bIsActive)
00347         {
00348           <span class="keywordtype">int</span> halfStride = m_Stride / 2;
00349           <span class="keywordtype">int</span> bottomLeft = m_HomeIndex + m_Stride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00350           <span class="keywordtype">int</span> bottomRight = bottomLeft + m_Stride;
00351           <span class="keywordtype">int</span> i,previousVertex=0;
00352           <span class="keywordtype">int</span> v0;
00353           <span class="keywordtype">int</span> numVertices = 0;
00354           
00355           <span class="keywordtype">bool</span> bNeedToFix = <span class="keyword">false</span>;
00356           <span class="keywordflow">for</span> (i = m_HomeIndex + m_Stride - 1; m_HomeIndex &lt; i &amp;&amp; !bNeedToFix; i--)
00357             bNeedToFix = (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1);
00358           <span class="keywordflow">if</span> (!bNeedToFix)
00359             {
00360               <span class="keywordflow">for</span> (i = m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>(); i &lt; m_HomeIndex + m_Stride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() &amp;&amp; !bNeedToFix; i += pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>())
00361                 bNeedToFix = (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1);
00362               <span class="keywordflow">if</span> (!bNeedToFix)
00363                 {
00364                   <span class="keywordflow">for</span> (i = bottomLeft + 1; i &lt; bottomRight &amp;&amp; !bNeedToFix; i++)
00365                     bNeedToFix = (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1);
00366                   <span class="keywordflow">if</span> (!bNeedToFix)
00367                     {
00368                       <span class="keywordflow">for</span> (i = bottomRight - pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>(); m_HomeIndex + m_Stride &lt; i &amp;&amp; !bNeedToFix; i -= pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>())
00369                         bNeedToFix = (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1);
00370                     }
00371                 }
00372             }
00373           
00374           <span class="keywordflow">if</span> (bNeedToFix)
00375             {
00376               <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka11">EnableStrip</a>(<span class="keyword">false</span>);
00377               v0 = m_HomeIndex + halfStride + halfStride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>();
00378               <a class="code" href="base.html#a19">Assert</a>(0 &lt;= v0);
00379               <a class="code" href="base.html#a19">Assert</a>(v0 &lt; pTerrain-&gt;GetNumberOfVertices());
00380               pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[0] = v0;
00381               numVertices = 0;
00382               <span class="keywordflow">for</span> (i = m_HomeIndex + m_Stride; m_HomeIndex &lt;= i; i--)
00383                 {
00384                   <a class="code" href="base.html#a19">Assert</a>(0 &lt;= i);
00385                   <a class="code" href="base.html#a19">Assert</a>(i &lt; pTerrain-&gt;GetNumberOfVertices());
00386                   <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1)
00387                     {
00388                       <span class="keywordflow">if</span> (++numVertices == <a class="code" href="CLODTerrainRenderer.html#a1">MAX_VERTICES_PER_FAN</a> - 1)
00389                         {
00390                           <span class="comment">// We have reached the maximum size for a fan, so start a new fan.</span>
00391                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr1">m_NumberOfVertices</a> = numVertices;
00392                           *pCountFans = *pCountFans + 1;
00393                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[0] = v0;
00394                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[1] = previousVertex;
00395                           numVertices = 2;
00396                         }
00397                       pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[numVertices] = i;
00398                       previousVertex = i;
00399                     }
00400                 }
00401               <span class="keywordflow">for</span> (i = m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>(); i &lt;= m_HomeIndex + m_Stride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>(); i += pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>())
00402                 {
00403                   <a class="code" href="base.html#a19">Assert</a>(0 &lt;= i);
00404                   <a class="code" href="base.html#a19">Assert</a>(i &lt; pTerrain-&gt;GetNumberOfVertices());
00405                   <span class="keywordflow">if</span>(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1)
00406                     {
00407                       <span class="keywordflow">if</span> (++numVertices == <a class="code" href="CLODTerrainRenderer.html#a1">MAX_VERTICES_PER_FAN</a> - 1)
00408                         {
00409                           <span class="comment">// We have reached the maximum size for a fan, so start a new fan.</span>
00410                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr1">m_NumberOfVertices</a> = numVertices;
00411                           *pCountFans = *pCountFans + 1;
00412                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[0] = v0;
00413                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[1] = previousVertex;
00414                           numVertices = 2;
00415                         }
00416                       pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[numVertices] = i;
00417                       previousVertex = i;
00418                     }
00419                 }
00420               <span class="keywordflow">for</span> (i = bottomLeft; i &lt;= bottomRight; i++)
00421                 {
00422                   <a class="code" href="base.html#a19">Assert</a>(0 &lt;= i);
00423                   <a class="code" href="base.html#a19">Assert</a>(i &lt; pTerrain-&gt;GetNumberOfVertices());
00424                   <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1)
00425                     {
00426                       <span class="keywordflow">if</span> (++numVertices == <a class="code" href="CLODTerrainRenderer.html#a1">MAX_VERTICES_PER_FAN</a> - 1)
00427                         {
00428                           <span class="comment">// We have reached the maximum size for a fan, so start a new fan.</span>
00429                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr1">m_NumberOfVertices</a> = numVertices;
00430                           *pCountFans = *pCountFans + 1;
00431                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[0] = v0;
00432                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[1] = previousVertex;
00433                           numVertices = 2;
00434                         }
00435                       pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[numVertices] = i;
00436                       previousVertex = i;
00437                     }
00438                 }
00439               <span class="keywordflow">for</span> (i = bottomRight - pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>(); m_HomeIndex + m_Stride &lt;= i; i -= pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>())
00440                 {
00441                   <a class="code" href="base.html#a19">Assert</a>(0 &lt;= i);
00442                   <a class="code" href="base.html#a19">Assert</a>(i &lt; pTerrain-&gt;GetNumberOfVertices());
00443                   <span class="keywordflow">if</span>(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind5">GetVertexStatus</a>(i) == 1)
00444                     {
00445                       <span class="keywordflow">if</span> (++numVertices == <a class="code" href="CLODTerrainRenderer.html#a1">MAX_VERTICES_PER_FAN</a> - 1)
00446                         {
00447                           <span class="comment">// We have reached the maximum size for a fan, so start a new fan.</span>
00448                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr1">m_NumberOfVertices</a> = numVertices;
00449                           *pCountFans = *pCountFans + 1;
00450                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[0] = v0;
00451                           pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[1] = previousVertex;
00452                           numVertices = 2;
00453                         }
00454                       pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr0">m_pVertices</a>[numVertices] = i;
00455                       previousVertex = i;
00456                     }
00457                 }
00458               pTriangleFans[*pCountFans].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr1">m_NumberOfVertices</a> = numVertices + 1;
00459               *pCountFans = *pCountFans + 1;
00460             }
00461         }
00462       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_bChildrenActive)
00463         {
00464           m_pChildren[0]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">RepairCracks</a>(pTerrain,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans);
00465           m_pChildren[1]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">RepairCracks</a>(pTerrain,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans);
00466           m_pChildren[2]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">RepairCracks</a>(pTerrain,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans);
00467           m_pChildren[3]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">RepairCracks</a>(pTerrain,pTriangleStrips,pTriangleFans,pCountStrips,pCountFans);
00468         }
00469     }
00470 }
00471 
<a name="l00472"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka13">00472</a> <span class="keywordtype">void</span> TerrainBlock::CalculateGeometry(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
00473 {
00474   <span class="keywordtype">float</span> height = m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> - m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00475   <span class="keywordtype">float</span> width = m_Stride * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina13">GetVertexSpacing</a>();
00476   <span class="keywordflow">if</span> (width &lt; height)
00477     m_CubeSize = height;
00478   <span class="keywordflow">else</span>
00479     m_CubeSize = width;
00480   m_CubeCenterZ = 0.5f * (m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> + m_BoundingBoxLowerCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>);
00481   
00482   <span class="keywordtype">float</span> halfCube = m_CubeSize / 2.0f;
00483   m_BoundingBox.<a class="code" href="classdemeter_1_1Box.html#demeter_1_1Boxo1">m_Min</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> - halfCube;
00484   m_BoundingBox.<a class="code" href="classdemeter_1_1Box.html#demeter_1_1Boxo1">m_Min</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> - halfCube;
00485   m_BoundingBox.<a class="code" href="classdemeter_1_1Box.html#demeter_1_1Boxo1">m_Min</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = m_CubeCenterZ - halfCube;
00486   m_BoundingBox.<a class="code" href="classdemeter_1_1Box.html#demeter_1_1Boxo0">m_Max</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + halfCube;
00487   m_BoundingBox.<a class="code" href="classdemeter_1_1Box.html#demeter_1_1Boxo0">m_Max</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = m_BoundingBoxUpperCenter.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + halfCube;
00488   m_BoundingBox.<a class="code" href="classdemeter_1_1Box.html#demeter_1_1Boxo0">m_Max</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = m_CubeCenterZ + halfCube;
00489   
00490 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
00491 <span class="preprocessor"></span>  <span class="comment">// Build triangles for ray intersection and collision detection.</span>
00492   <span class="keywordflow">if</span> (m_Stride == 2)
00493     {
00494       m_pTriangles = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Triangle.html">Triangle</a>[8];
00495       m_pTriangles[0].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 1]);
00496       m_pTriangles[1].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 1],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1]);
00497       m_pTriangles[2].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 1],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 1 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 2]);
00498       m_pTriangles[3].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 2],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 1 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + 2 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()]);
00499       m_pTriangles[4].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex  + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1]);
00500       m_pTriangles[5].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex  + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1]);
00501       m_pTriangles[6].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex  + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 2]);
00502       m_pTriangles[7].DefineFromPoints(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 2],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 1 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()],pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_HomeIndex  + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() + 2 + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>()]);*/
00503     }
00504 <span class="preprocessor">#endif</span>
00505 <span class="preprocessor"></span>}
00506 
<a name="l00507"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka6">00507</a> <span class="keywordtype">void</span> TerrainBlock::DummyFunc(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
00508 {
00509   <span class="comment">// Forces all exported methods to be referenced on GNU compilers - NEVER CALL</span>
00510   printf(<span class="stringliteral">"%d"</span>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina10">GetHeightVertices</a>());
00511   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina14">GetElevation</a>(0.0<a class="code" href="Makefile_8in.html#a5">f</a>,0.0<a class="code" href="Makefile_8in.html#a5">f</a>);
00512   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina13">GetVertexSpacing</a>();
00513   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina11">GetWidth</a>();
00514   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina12">GetHeight</a>();
00515   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa9">GetScreenHeight</a>();
00516   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa7">GetScreenWidth</a>();
00517 }
00518 
<a name="l00519"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka4">00519</a> <span class="keywordtype">void</span> TerrainBlock::Write(FILE* file)
00520 {
00521   fwrite(&amp;m_Stride,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00522   fwrite(&amp;m_HomeIndex,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00523   fwrite(&amp;m_BoundingBoxUpperCenter,<span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1Vector.html">Vector</a>),1,file);
00524   fwrite(&amp;m_BoundingBoxLowerCenter,<span class="keyword">sizeof</span>(Vector),1,file);
00525   <span class="keywordflow">if</span> (2 &lt; m_Stride)
00526     {
00527       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)
00528         m_pChildren[i]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka4">Write</a>(file);
00529     }
00530 }
00531 
<a name="l00532"></a><a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka5">00532</a> <span class="keywordtype">void</span> TerrainBlock::Read(FILE* file,<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
00533 {
00534   fread(&amp;m_Stride,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00535   fread(&amp;m_HomeIndex,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00536   fread(&amp;m_BoundingBoxUpperCenter,<span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1Vector.html">Vector</a>),1,file);
00537   fread(&amp;m_BoundingBoxLowerCenter,<span class="keyword">sizeof</span>(Vector),1,file);
00538   <span class="keywordflow">if</span> (2 &lt; m_Stride)
00539     {
00540       m_pChildren = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>*[4];
00541       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)
00542         {
00543           m_pChildren[i] = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka0">TerrainBlock</a>(<span class="keyword">this</span>);
00544           m_pChildren[i]-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka5">Read</a>(file,pTerrain);
00545         }
00546     }
00547   <a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka13">CalculateGeometry</a>(pTerrain);
00548 }
00549 
<a name="l00550"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina0">00550</a> Terrain::Terrain(<span class="keywordtype">char</span>* szElevationsFilename,<span class="keywordtype">char</span>* szTextureFilename,<span class="keywordtype">char</span>* szDetailTextureFilename,<span class="keywordtype">float</span> vertexSpacing,<span class="keywordtype">float</span> elevationScale,<span class="keywordtype">int</span> maxNumTriangles,<span class="keywordtype">bool</span> bUseBorders) : <a class="code" href="classosg_1_1Referenced.html">Referenced</a>()
00551 {
00552   <span class="comment">// Set all default values</span>
00553   m_szSourceURL = NULL;
00554   m_MaxNumberOfPrimitives = maxNumTriangles / 4;
00555   m_pTriangleStrips = NULL;
00556   m_pTriangleFans = NULL;
00557   m_szTextureFilename = NULL;
00558   m_szDetailTextureFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[5];
00559   sprintf(m_szDetailTextureFilename,<span class="stringliteral">"none"</span>);
00560   m_pVertices = NULL;
00561   m_CommonTextureRepeats = 20.0f;
00562   m_pVertexStatus = NULL;
00563   m_pRootBlock = NULL;
00564   m_pCommonTexture = NULL;
00565   m_VertexSpacing = vertexSpacing;
00566   m_MaximumVisibleBlockSize = 128;
00567   <a class="code" href="namespacedemeter.html#a0">Uint8</a> red;
00568   <a class="code" href="namespacedemeter.html#a0">Uint8</a> green;
00569   <a class="code" href="namespacedemeter.html#a0">Uint8</a> blue;
00570   <span class="comment">// Load elevation data</span>
00571   <span class="keywordtype">char</span>* szFullFilename;
00572   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szElevationsFilename,&amp;szFullFilename);
00573   osg::ref_ptr&lt;osg::Image&gt; pImage = osgDB::Registry::instance()-&gt;readImage(szFullFilename,<span class="keyword">true</span>).getImage();
00574   <span class="keywordflow">if</span> (pImage == NULL)
00575     {
00576       String msg(<span class="stringliteral">"Failed to load elevation image file '"</span>);
00577       <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
00578     }
00579   <span class="keywordflow">else</span>
00580     {
00581       <span class="comment">// Test to see if the image is a power of 2 in both width and height.</span>
00582       <span class="keywordflow">if</span> (!<a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>((<span class="keywordtype">double</span>)pImage-&gt;s()) || !<a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>((<span class="keywordtype">double</span>)pImage-&gt;t()))
00583         {
00584           pImage-&gt;ensureValidSizeForTexturing(8192);
00585         }
00586       
00587       <span class="comment">// Test to see if the image is 24-bit color.</span>
00588       <span class="keywordflow">if</span> (pImage-&gt;getPixelSizeInBits() != 24)
00589         {
00590           String msg(<span class="stringliteral">"The elevation image file '"</span>);
00591           msg += szFullFilename;
00592           msg += <span class="stringliteral">"' is NOT a 24-bit image. Elevation files must be 24-bit images."</span>;
00593           <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
00594         }
00595       
00596       <span class="keywordtype">int</span> pitch = 3 * pImage-&gt;s(); <span class="comment">// why 3? !!!</span>
00597       m_WidthVertices = pImage-&gt;s() + 1; <span class="comment">// Add 1 dummy pixel line to edge for block strides</span>
00598       m_HeightVertices = pImage-&gt;t() + 1;
00599       m_NumberOfVertices = m_WidthVertices * m_HeightVertices;
00600       m_pVertices = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>[m_WidthVertices * m_HeightVertices];
00601       <span class="keywordtype">int</span> i,j;
00602       <span class="keywordtype">float</span> x,y;
00603       <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImagePixels = (<a class="code" href="namespacedemeter.html#a0">Uint8</a>*)pImage-&gt;data();
00604       y = m_HeightVertices * m_VertexSpacing;
00605       m_MaxElevation = 0.0f;
00606       <span class="keywordflow">for</span> (i = pImage-&gt;t() * pitch - pitch,j = 0; i &gt;= 0; i -= pitch,y -= m_VertexSpacing)
00607         {
00608           <span class="keywordflow">if</span> (i == pImage-&gt;t() * pitch)
00609             {
00610               x=0.0f;
00611               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m = 0; m &lt; m_WidthVertices; m++,j++,x += m_VertexSpacing)
00612                 {
00613                   m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = x;
00614                   m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = y;
00615                   m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = m_pVertices[j - m_WidthVertices].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00616                 }
00617             }
00618           <span class="keywordflow">else</span>
00619             {
00620               <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImageRow = pImagePixels + i;
00621               x=0.0f;
00622               <span class="keywordtype">int</span> bytesPerPixel = pImage-&gt;getPixelSizeInBits() / 8;
00623               <span class="keywordflow">for</span> (<a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImagePixel = pImageRow; pImagePixel &lt; pImageRow + pImage-&gt;s() * bytesPerPixel; pImagePixel += bytesPerPixel,j++,x += m_VertexSpacing)
00624                 {
00625                   <a class="code" href="namespacedemeter.html#a1">Uint32</a>* pCurrentPixel = (<a class="code" href="namespacedemeter.html#a1">Uint32</a>*)pImagePixel;
00626                   <span class="comment">//              SDL_GetRGB(*pCurrentPixel,pImage-&gt;dataType(),&amp;red,&amp;green,&amp;blue);</span>
00627                   red   = (*pCurrentPixel) &amp; 0xff; <span class="comment">// !!!! check this is ok for Intel endian</span>
00628                   green = ((*pCurrentPixel) &amp; 0xff00) &gt;&gt; 8; <span class="comment">// (we should really use dataType intelligently!)</span>
00629                   blue  = ((*pCurrentPixel) &amp; 0xff0000) &gt;&gt; 16;
00630                   m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = x;
00631                   m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = y;
00632                   m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = red * elevationScale;
00633                   <span class="keywordflow">if</span> (m_MaxElevation &lt; m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>)
00634                     m_MaxElevation = m_pVertices[j].z;
00635                 }
00636               m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = m_WidthVertices * m_VertexSpacing;
00637               m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = y;
00638               m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = m_pVertices[j - 1].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00639               <span class="keywordflow">if</span> (m_MaxElevation &lt; m_pVertices[j].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>)
00640                 m_MaxElevation = m_pVertices[j].z;
00641               j++; <span class="comment">// Account for dummy column on right edge</span>
00642               x += m_VertexSpacing;
00643             }
00644         }
00645       
00646       x = 0.0f;
00647       <span class="keywordflow">for</span> (i = m_NumberOfVertices - m_WidthVertices; i &lt; m_NumberOfVertices; i++)
00648         m_pVertices[i].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = m_pVertices[i - m_WidthVertices].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00649       
00650     }
00651   m_DetailThreshold = 4.0f;
00652   BuildBlocks();
00653   <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina27">SetTexture</a>(szTextureFilename,bUseBorders);
00654   <span class="keywordflow">if</span> (szDetailTextureFilename != NULL)
00655     <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina28">SetCommonTexture</a>(szDetailTextureFilename);
00656   <span class="keyword">delete</span>[] szFullFilename;
00657 }
00658 
<a name="l00659"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina1">00659</a> Terrain::Terrain(<span class="keywordtype">char</span>* szCompiledMapFilename,<span class="keywordtype">int</span> maxNumTriangles,<span class="keywordtype">bool</span> bUseBorders,<span class="keywordtype">float</span> offsetX,<span class="keywordtype">float</span> offsetY) : <a class="code" href="classosg_1_1Referenced.html">Referenced</a>()
00660 {
00661   m_szSourceURL = NULL;
00662   Init(szCompiledMapFilename,maxNumTriangles,bUseBorders,offsetX,offsetY);
00663 }
00664 
<a name="l00665"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina2">00665</a> Terrain::Terrain(<span class="keywordtype">char</span>* szURL,<span class="keywordtype">char</span>* szCompiledMapFilename,<span class="keywordtype">int</span> maxNumTriangles,<span class="keywordtype">bool</span> bUseBorders) : <a class="code" href="classosg_1_1Referenced.html">Referenced</a>()
00666 {
00667   m_szSourceURL = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szURL) + 1];
00668   sprintf(m_szSourceURL,szURL);
00669   <span class="keywordflow">if</span> (DownloadFile(szCompiledMapFilename))
00670     Init(szCompiledMapFilename,maxNumTriangles,bUseBorders);
00671 }                       
00672 
<a name="l00673"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina3">00673</a> Terrain::~Terrain()
00674 {
00675   <span class="keywordflow">while</span> (!m_Textures.empty())
00676     {
00677       vector&lt;Texture*&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> iter = m_Textures.begin();
00678       <a class="code" href="classdemeter_1_1Texture.html">Texture</a>* pTexture = *iter;
00679       m_Textures.erase(iter);
00680       <span class="keyword">delete</span> pTexture;
00681     }
00682   
00683   <span class="keywordflow">if</span> (m_pCommonTexture != NULL)
00684     <span class="keyword">delete</span> m_pCommonTexture;
00685   
00686   <span class="keyword">delete</span>[] m_pTriangleStrips;
00687   <span class="keyword">delete</span>[] m_pTriangleFans;
00688   <span class="keyword">delete</span>[] m_pVertices;
00689   <span class="keyword">delete</span> m_pVertexStatus;
00690   <span class="keyword">delete</span>[] m_szTextureFilename;
00691   <span class="keyword">delete</span>[] m_szDetailTextureFilename;
00692   <span class="keyword">delete</span> m_pRootBlock;
00693 }
00694 
00695 <span class="keywordtype">void</span> Terrain::Init(<span class="keywordtype">char</span>* szCompiledMapFilename,<span class="keywordtype">int</span> maxNumTriangles,<span class="keywordtype">bool</span> bUseBorders,<span class="keywordtype">float</span> offsetX,<span class="keywordtype">float</span> offsetY)
00696 {
00697   m_MaxNumberOfPrimitives = maxNumTriangles / 4;
00698   m_pTriangleStrips = NULL;
00699   m_pTriangleFans = NULL;
00700   m_pCommonTexture = NULL;
00701   m_DetailThreshold = 4.0f;
00702   m_pVertices = NULL;
00703   m_pRootBlock = NULL;
00704   m_pVertexStatus = NULL;
00705   m_szTextureFilename = NULL;
00706   m_szDetailTextureFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[5];
00707   sprintf(m_szDetailTextureFilename,<span class="stringliteral">"none"</span>);
00708   m_MaximumVisibleBlockSize = 24;
00709   m_CommonTextureRepeats = 20.0f;
00710   m_OffsetX = offsetX;
00711   m_OffsetY = offsetY;
00712   
00713   <span class="keywordflow">if</span>(!<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa19">IsHeadless</a>())
00714     {
00715 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
00716 <span class="preprocessor"></span>      glLockArraysEXT_ptr = (PFNGLLOCKARRAYSEXTPROC)SDL_GL_GetProcAddress(<span class="stringliteral">"glLockArraysEXT"</span>);
00717       glUnlockArraysEXT_ptr = (PFNGLUNLOCKARRAYSEXTPROC)SDL_GL_GetProcAddress(<span class="stringliteral">"glUnlockArraysEXT"</span>);
00718 <span class="preprocessor">#endif</span>
00719 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a> == NULL)
00720         {
00721           <span class="comment">// !!! put something back here that check properly</span>
00722           <span class="comment">//      glActiveTextureARB_ptr = (PFNGLACTIVETEXTUREARBPROC)SDL_GL_GetProcAddress("glActiveTextureARB");</span>
00723           <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a> = glActiveTextureARB;
00724           <span class="comment">//      glMultiTexCoord2fARB_ptr = (PFNGLMULTITEXCOORD2FARBPROC)SDL_GL_GetProcAddress("glMultiTexCoord2fARB");</span>
00725           <a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a> = glMultiTexCoord2fARB;
00726           <span class="keywordflow">if</span>(!<a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a> || !<a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a>)
00727             {
00728               cout &lt;&lt; <span class="stringliteral">"TERRAIN: ERROR: Multitexture extensions not supported by this OpenGL vendor!"</span> &lt;&lt; endl;
00729               exit(-1);
00730             }
00731         }
00732       m_bMultiTextureSupported = <span class="keyword">true</span>;
00733 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
00734 <span class="preprocessor"></span>      glVertexPointer(3,GL_FLOAT,0,m_pVertices);
00735       
00736       <span class="comment">// Generate texture coordinate arrays</span>
00737       <span class="keywordtype">float</span>* pTextureMain = <span class="keyword">new</span> <span class="keywordtype">float</span>[m_NumberOfVertices * 2];
00738       <span class="keywordtype">float</span>* pTextureDetail = <span class="keyword">new</span> <span class="keywordtype">float</span>[m_NumberOfVertices * 2];
00739       <span class="keywordtype">float</span> u = 0.0f;
00740       <span class="keywordtype">float</span> v = 0.0f;
00741       <span class="keywordtype">float</span> deltaU = (<span class="keywordtype">float</span>)m_NumberOfTextureTilesWidth / (<span class="keywordtype">float</span>)m_WidthVertices;
00742       <span class="keywordtype">float</span> deltaV = (<span class="keywordtype">float</span>)m_NumberOfTextureTilesHeight / (<span class="keywordtype">float</span>)m_HeightVertices;
00743       <span class="keywordtype">int</span> k = 0;
00744       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_NumberOfVertices; i += m_WidthVertices)
00745         {
00746           u = 0.0f;
00747           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt; i + m_WidthVertices; j++)
00748             {
00749               pTextureMain[k] = u;
00750               pTextureMain[k + 1] = v;
00751               pTextureDetail[k] = u;<span class="comment">// * 100.0f;</span>
00752               pTextureDetail[k + 1] = v;<span class="comment">// * 100.0f;</span>
00753               k += 2;
00754               u += deltaU;
00755             }
00756           v += deltaV;
00757         }
00758       
00759       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(GL_TEXTURE0_ARB);
00760       glTexCoordPointer(2,GL_FLOAT,0,pTextureMain);
00761       glEnableClientState(GL_TEXTURE_COORD_ARRAY);
00762       
00763       glEnableClientState(GL_VERTEX_ARRAY);
00764       
00765       glLockArraysEXT_ptr(0,m_NumberOfVertices);
00766 <span class="preprocessor">#endif</span>
00767 <span class="preprocessor"></span>    }
00768   Read(szCompiledMapFilename,bUseBorders);
00769 }
00770 
<a name="l00771"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina36">00771</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> Terrain::IsMultiTextureSupported()
00772 {
00773   <span class="keywordflow">return</span> m_bMultiTextureSupported;
00774 }
00775 
<a name="l00776"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina21">00776</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> Terrain::GetNumberOfVertices()
00777 {
00778   <span class="keywordflow">return</span> m_NumberOfVertices;
00779 }
00780 
<a name="l00781"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina20">00781</a> <span class="keywordtype">bool</span> Terrain::Write(<span class="keywordtype">char</span>* szCompiledMapFilename)
00782 {
00783   <span class="keywordtype">bool</span> bSuccess = <span class="keyword">false</span>;
00784   <span class="keywordflow">try</span>
00785     {
00786       <span class="keywordtype">char</span>* szFullFilename;
00787       <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szCompiledMapFilename,&amp;szFullFilename);
00788       FILE* file = fopen(szFullFilename,<span class="stringliteral">"wb"</span>);
00789       <span class="keyword">delete</span>[] szFullFilename;
00790       <span class="keywordtype">int</span> byteCount = 0;
00791       <span class="keywordflow">if</span> (file != NULL)
00792         {
00793           fwrite(&amp;m_VertexSpacing,<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),1,file);
00794           fwrite(&amp;m_WidthVertices,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00795           fwrite(&amp;m_HeightVertices,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00796           
00797           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_WidthVertices * m_HeightVertices; i++)
00798             {
00799               fwrite(&amp;m_pVertices[i].z,<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),1,file);
00800               byteCount += <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>);
00801             }   
00802           
00803           <span class="keywordtype">int</span> len = strlen(m_szTextureFilename);
00804           fwrite(&amp;len,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00805           byteCount += <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
00806           fwrite(m_szTextureFilename,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>),strlen(m_szTextureFilename),file);
00807           byteCount += <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * strlen(m_szTextureFilename);
00808           len = strlen(m_szDetailTextureFilename);
00809           fwrite(&amp;len,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00810           byteCount += <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
00811           fwrite(m_szDetailTextureFilename,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>),strlen(m_szDetailTextureFilename),file);
00812           byteCount += <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * strlen(m_szDetailTextureFilename);
00813           cout &lt;&lt; <span class="stringliteral">"TERRAIN: Size = "</span> &lt;&lt; byteCount &lt;&lt; endl;
00814           fclose(file);
00815           bSuccess = <span class="keyword">true</span>;
00816         }
00817       <span class="keywordflow">else</span>
00818         cout &lt;&lt; <span class="stringliteral">"TERRAIN: Unable to create output file = "</span> &lt;&lt; szCompiledMapFilename &lt;&lt; endl;
00819     }
00820   <span class="keywordflow">catch</span>(...)
00821     {           
00822     }
00823   <span class="keywordflow">return</span> bSuccess;
00824 }
00825 
00826 <span class="keywordtype">bool</span> Terrain::Read(<span class="keywordtype">char</span>* szCompiledMapFilename,<span class="keywordtype">bool</span> bUseBorders)
00827 {
00828   <span class="keywordtype">bool</span> bSuccess = <span class="keyword">false</span>;
00829   <span class="keywordtype">char</span>* szFullFilename;
00830   <span class="keywordflow">if</span> (szCompiledMapFilename[0] != <span class="charliteral">'/'</span>) <span class="comment">// not absolute path</span>
00831     <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szCompiledMapFilename,&amp;szFullFilename);
00832   <span class="keywordflow">else</span> {
00833     szFullFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szCompiledMapFilename)+1];
00834     strcpy(szFullFilename, szCompiledMapFilename);
00835   }
00836   FILE* file = fopen(szFullFilename,<span class="stringliteral">"rb"</span>);
00837   <span class="keywordflow">if</span> (file != NULL)
00838     {
00839       fread(&amp;m_VertexSpacing,<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),1,file);
00840       fread(&amp;m_WidthVertices,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00841       fread(&amp;m_HeightVertices,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00842       m_NumberOfVertices = m_WidthVertices * m_HeightVertices;
00843       <span class="keyword">delete</span>[] m_pVertices;
00844       m_pVertices = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Vector.html">Vector</a>[m_WidthVertices * m_HeightVertices];
00845       
00846       <span class="keywordtype">int</span> i = 0;
00847       
00848       m_MaxElevation = 0.0f;
00849       <span class="keywordflow">for</span> (i = 0; i &lt; m_NumberOfVertices; i++)
00850         {
00851           fread(&amp;m_pVertices[i].z,<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),1,file);
00852           <span class="keywordflow">if</span> (m_MaxElevation &lt; m_pVertices[i].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>)
00853             m_MaxElevation = m_pVertices[i].z;
00854         }
00855       
00856       <span class="keywordflow">for</span> (i = 0; i &lt; m_HeightVertices; i++)
00857         {
00858           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_WidthVertices; j++)
00859             {
00860               <span class="keywordtype">long</span> <span class="keywordtype">int</span> index = i * m_WidthVertices + j;
00861               <a class="code" href="base.html#a19">Assert</a>(index &lt; m_NumberOfVertices);
00862               m_pVertices[index].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = (<span class="keywordtype">float</span>)j * m_VertexSpacing;
00863               m_pVertices[index].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = (<span class="keywordtype">float</span>)i * m_VertexSpacing;
00864             }   
00865         }
00866       
00867       <span class="keywordtype">int</span> len;
00868       fread(&amp;len,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00869       m_szTextureFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[len + 1];
00870       fread(m_szTextureFilename,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>),len,file);
00871       m_szTextureFilename[len] = <span class="charliteral">'\0'</span>;
00872       
00873       fread(&amp;len,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),1,file);
00874       m_szDetailTextureFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[len + 1];
00875       fread(m_szDetailTextureFilename,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>),len,file);
00876       m_szDetailTextureFilename[len] = <span class="charliteral">'\0'</span>;
00877       
00878       <span class="keyword">delete</span> m_pVertexStatus;
00879       m_pVertexStatus = <span class="keyword">new</span> <a class="code" href="classbase_1_1BitArray.html">base::BitArray</a>(m_WidthVertices * m_HeightVertices);
00880       <span class="keyword">delete</span> m_pRootBlock;
00881       BuildBlocks();
00882       <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina27">SetTexture</a>(m_szTextureFilename,bUseBorders))
00883         {               
00884           <span class="keywordflow">if</span> (strcmp(m_szDetailTextureFilename,<span class="stringliteral">"none"</span>) != 0)
00885             bSuccess = <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina28">SetCommonTexture</a>(m_szDetailTextureFilename);
00886           <span class="keywordflow">else</span>
00887             bSuccess = <span class="keyword">true</span>;
00888         }
00889       fclose(file);
00890     }
00891   <span class="keywordflow">else</span>
00892     {
00893       string msg(<span class="stringliteral">"Compiled map file '"</span>);
00894       msg += szFullFilename;
00895       msg += <span class="stringliteral">"' not found."</span>;
00896       <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
00897     }
00898   <span class="keyword">delete</span>[] szFullFilename;
00899   <span class="keywordflow">return</span> bSuccess;
00900 }
00901 
00902 <span class="keywordtype">void</span> Terrain::UpdateNeighbor(Terrain* pTerrain,Terrain::DIRECTION direction)
00903 {
00904   <span class="keywordtype">int</span> thisVertex,otherVertex;
00905   <span class="keywordflow">if</span> (direction == Terrain::DIR_SOUTH)
00906     {
00907       <span class="keywordflow">for</span> (thisVertex = 0,otherVertex = m_NumberOfVertices - m_WidthVertices; thisVertex &lt; m_WidthVertices; thisVertex++,otherVertex++)
00908         {
00909           <span class="keywordflow">if</span> (GetVertexStatus(thisVertex))
00910             pTerrain-&gt;SetVertexStatus(otherVertex,<span class="keyword">true</span>);
00911         }
00912     }
00913   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_NORTH)
00914     {
00915       <span class="keywordflow">for</span> (thisVertex = m_NumberOfVertices - m_WidthVertices,otherVertex = 0; thisVertex &lt; m_NumberOfVertices; thisVertex++,otherVertex++)
00916         {
00917           <span class="keywordflow">if</span> (GetVertexStatus(thisVertex))
00918             pTerrain-&gt;SetVertexStatus(otherVertex,<span class="keyword">true</span>);
00919         }
00920     }
00921   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_WEST)
00922     {
00923       <span class="keywordflow">for</span> (thisVertex = 0,otherVertex = m_WidthVertices - 1; thisVertex &lt; m_NumberOfVertices; thisVertex += m_WidthVertices,otherVertex += m_WidthVertices)
00924         <span class="keywordflow">if</span> (GetVertexStatus(thisVertex))
00925           pTerrain-&gt;SetVertexStatus(otherVertex,<span class="keyword">true</span>);
00926     }
00927   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_EAST)
00928     {
00929       <span class="keywordflow">for</span> (thisVertex = m_WidthVertices - 1,otherVertex = 0; thisVertex &lt; m_NumberOfVertices; thisVertex += m_WidthVertices,otherVertex += m_WidthVertices)
00930         <span class="keywordflow">if</span> (GetVertexStatus(thisVertex))
00931           pTerrain-&gt;SetVertexStatus(otherVertex,<span class="keyword">true</span>);
00932     }
00933   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_NORTHWEST)
00934     {
00935       <span class="keywordflow">if</span> (GetVertexStatus(m_NumberOfVertices - m_WidthVertices))
00936         pTerrain-&gt;SetVertexStatus(m_WidthVertices - 1,<span class="keyword">true</span>);
00937     }
00938   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_NORTHEAST)
00939     {
00940       <span class="keywordflow">if</span> (GetVertexStatus(m_NumberOfVertices - 1))
00941         pTerrain-&gt;SetVertexStatus(0,<span class="keyword">true</span>);
00942     }
00943   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_SOUTHEAST)
00944     {
00945       <span class="keywordflow">if</span> (GetVertexStatus(m_WidthVertices - 1))
00946         pTerrain-&gt;SetVertexStatus(m_NumberOfVertices - m_WidthVertices,<span class="keyword">true</span>);
00947     }
00948   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == Terrain::DIR_SOUTHWEST)
00949     {
00950       <span class="keywordflow">if</span> (GetVertexStatus(0))
00951         pTerrain-&gt;SetVertexStatus(m_NumberOfVertices - 1,<span class="keyword">true</span>);
00952     }
00953 }
00954 
<a name="l00955"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina15">00955</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> Terrain::GetElevation(<span class="keywordtype">int</span> index)
00956 {
00957   <span class="keywordflow">return</span> m_pVertices[index].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
00958 }
00959 
<a name="l00960"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina14">00960</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> Terrain::GetElevation(<span class="keywordtype">float</span> x,<span class="keywordtype">float</span> y)
00961 {
00962   <a class="code" href="classdemeter_1_1Plane.html">Plane</a> plane;
00963   <span class="keywordtype">int</span>   vertexID;
00964   <span class="keywordtype">float</span> elevation;
00965   
00966   x -= m_OffsetX;
00967   y -= m_OffsetY;
00968   
00969 <span class="preprocessor">#ifdef _PROTECT_ACCESS_</span>
00970 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (x &lt; 0.0f || y &lt; 0.0f || <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina11">GetWidth</a>() &lt; x || <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina12">GetHeight</a>() &lt; y)
00971     elevation = 0.0f;
00972   <span class="keywordflow">else</span>
00973     {
00974 <span class="preprocessor">#endif</span>
00975 <span class="preprocessor"></span>      vertexID = ((<span class="keywordtype">int</span>)(y / m_VertexSpacing)) * m_WidthVertices + ((<span class="keywordtype">int</span>)(x / m_VertexSpacing));
00976       
00977       <span class="keywordflow">if</span> ((fmod(y,m_VertexSpacing) + fmod(x,m_VertexSpacing)) &lt;= m_VertexSpacing)
00978         plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">defineFromPoints</a>(m_pVertices[vertexID],m_pVertices[vertexID + m_WidthVertices],m_pVertices[vertexID + 1]);
00979       <span class="keywordflow">else</span>
00980         plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">defineFromPoints</a>(m_pVertices[vertexID + 1],m_pVertices[vertexID + 1 + m_WidthVertices],m_pVertices[vertexID + m_WidthVertices]);
00981       
00982       elevation = -1.0f * ((plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo0">a</a> * x + plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo1">b</a> * y + plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo3">d</a>) / plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo2">c</a>);
00983 <span class="preprocessor">#ifdef _PROTECT_ACCESS_</span>
00984 <span class="preprocessor"></span>    }
00985 <span class="preprocessor">#endif</span>
00986 <span class="preprocessor"></span>  
00987   <span class="keywordflow">return</span> elevation;
00988 }
00989 
<a name="l00990"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina16">00990</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> Terrain::GetNormal(<span class="keywordtype">float</span> x,<span class="keywordtype">float</span> y,<span class="keywordtype">float</span>&amp; normalX,<span class="keywordtype">float</span>&amp; normalY,<span class="keywordtype">float</span>&amp; normalZ)
00991 {
00992   <a class="code" href="classdemeter_1_1Plane.html">Plane</a> plane;
00993   <span class="keywordtype">int</span>   vertexID;
00994 <span class="preprocessor">#ifdef _PROTECT_ACCESS_</span>
00995 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (x &lt; 0.0f || y &lt; 0.0f || <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina11">GetWidth</a>() &lt; x || <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina12">GetHeight</a>() &lt; y)
00996     {
00997       normalX = normalY = 0.0f;
00998       normalZ = 1.0f;
00999     }
01000   <span class="keywordflow">else</span>
01001     {
01002 <span class="preprocessor">#endif</span>
01003 <span class="preprocessor"></span>      vertexID = (<span class="keywordtype">int</span>)(y / m_VertexSpacing) * m_WidthVertices + (<span class="keywordtype">int</span>)(x / m_VertexSpacing);
01004       
01005       <span class="keywordflow">if</span> ((fmod(y,m_VertexSpacing) - fmod(x,m_VertexSpacing)) &gt;= 0.0f)
01006         plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">defineFromPoints</a>(m_pVertices[vertexID],m_pVertices[vertexID + 1],m_pVertices[vertexID + m_WidthVertices]);
01007       <span class="keywordflow">else</span>
01008         plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">defineFromPoints</a>(m_pVertices[vertexID + 1],m_pVertices[vertexID + 1 + m_WidthVertices],m_pVertices[vertexID + m_WidthVertices]);
01009 
01010       normalX = plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo0">a</a>;
01011       normalY = plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo1">b</a>;
01012       normalZ = plane.<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo2">c</a>;
01013 <span class="preprocessor">#ifdef _PROTECT_ACCESS_</span>
01014 <span class="preprocessor"></span>    }
01015 <span class="preprocessor">#endif</span>
01016 <span class="preprocessor"></span>}
01017 
<a name="l01018"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina6">01018</a> <span class="keywordtype">void</span> Terrain::SetDetailThreshold(<span class="keywordtype">float</span> threshold)
01019 {
01020   m_DetailThreshold = threshold;
01021 }
01022 
<a name="l01023"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina7">01023</a> <span class="keywordtype">float</span> Terrain::GetDetailThreshold()
01024 {
01025   <span class="keywordflow">return</span> m_DetailThreshold;
01026 }
01027 
<a name="l01028"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">01028</a> <span class="keywordtype">int</span> Terrain::GetWidthVertices()
01029 {
01030   <span class="keywordflow">return</span> m_WidthVertices;
01031 }
01032 
<a name="l01033"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina10">01033</a> <span class="keywordtype">int</span> Terrain::GetHeightVertices()
01034 {
01035   <span class="keywordflow">return</span> m_HeightVertices;
01036 }
01037 
<a name="l01038"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina11">01038</a> <span class="keywordtype">float</span> Terrain::GetWidth()<span class="keyword"> const</span>
01039 <span class="keyword"></span>{
01040   <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)(m_WidthVertices - 1) * m_VertexSpacing;
01041 }
01042 
<a name="l01043"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina12">01043</a> <span class="keywordtype">float</span> Terrain::GetHeight()<span class="keyword"> const</span>
01044 <span class="keyword"></span>{
01045   <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)(m_HeightVertices - 1) * m_VertexSpacing;
01046 }
01047 
<a name="l01048"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina17">01048</a> <span class="keywordtype">float</span> Terrain::GetMaxElevation()<span class="keyword"> const</span>
01049 <span class="keyword"></span>{
01050   <span class="keywordflow">return</span> m_MaxElevation;        
01051 }
01052 
<a name="l01053"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina18">01053</a> <span class="keywordtype">float</span> Terrain::GetVertexElevation(<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
01054 <span class="keyword"></span>{
01055 <span class="preprocessor">#ifdef _PROTECT_ACCESS_</span>
01056 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (index &lt; 0 || m_NumberOfVertices &lt;= index)
01057     <span class="keywordflow">return</span> 0.0f;
01058   <span class="keywordflow">else</span>
01059 <span class="preprocessor">#endif</span>
01060 <span class="preprocessor"></span>    <span class="keywordflow">return</span> m_pVertices[index].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
01061 }
01062 
<a name="l01063"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina19">01063</a> <span class="keywordtype">void</span> Terrain::SetVertexElevation(<span class="keywordtype">int</span> index,<span class="keywordtype">float</span> newElevation)
01064 {
01065 <span class="preprocessor">#ifdef _PROTECT_ACCESS_</span>
01066 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (0 &lt;= index &amp;&amp; index &lt; m_NumberOfVertices)
01067 <span class="preprocessor">#endif</span>
01068 <span class="preprocessor"></span>    m_pVertices[index].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = newElevation;        
01069 }
01070 
<a name="l01071"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina13">01071</a> <span class="keywordtype">float</span> Terrain::GetVertexSpacing()
01072 {
01073   <span class="keywordflow">return</span> m_VertexSpacing;
01074 }
01075 
01076 <span class="keywordtype">void</span> Terrain::BuildBlocks()
01077 {
01078   <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa19">IsHeadless</a>())
01079     <span class="keywordflow">return</span>;
01080   <a class="code" href="CLODTerrainRenderer_8cpp.html#a14">numLevels</a> = 0.0f;
01081   <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> = 0.0f;
01082   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = m_WidthVertices - 1; 2 &lt;= i; i /= 2)
01083     <a class="code" href="CLODTerrainRenderer_8cpp.html#a14">numLevels</a> += 1.0f;
01084   <span class="keywordflow">for</span> (<span class="keywordtype">double</span> j = 0.0f; j &lt; <a class="code" href="CLODTerrainRenderer_8cpp.html#a14">numLevels</a>; j += 1.0f)
01085     <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> += pow(4,j);
01086   <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01087     {
01088       cout &lt;&lt; <span class="stringliteral">"TERRAIN: Building "</span> &lt;&lt; <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> &lt;&lt; <span class="stringliteral">" blocks; please wait..."</span> &lt;&lt; endl;
01089 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
01090 <span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">"TERRAIN: Memory required at runtime for blocks = "</span> &lt;&lt; <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> * (<span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>) + 8 * <span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1Triangle.html">Triangle</a>)) &lt;&lt; <span class="stringliteral">" bytes"</span> &lt;&lt; endl;
01091 <span class="preprocessor">#else  </span>
01092 <span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">"TERRAIN: Memory required at runtime for blocks = "</span> &lt;&lt; <a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> * <span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1TerrainBlock.html">TerrainBlock</a>) &lt;&lt; <span class="stringliteral">" bytes"</span> &lt;&lt; endl;
01093 <span class="preprocessor">#endif</span>
01094 <span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">".............................."</span> &lt;&lt; endl;
01095       <a class="code" href="CLODTerrainRenderer_8cpp.html#a15">hashDelta</a> = (<span class="keywordtype">double</span>)<a class="code" href="CLODTerrainRenderer_8cpp.html#a13">numBlocks</a> / 30.0f;
01096       cout &lt;&lt; <span class="stringliteral">"#"</span> &lt;&lt; flush;
01097     }
01098   m_pVertexStatus = <span class="keyword">new</span> <a class="code" href="classbase_1_1BitArray.html">BitArray</a>(m_WidthVertices * m_HeightVertices);
01099   <span class="comment">// We assume that the terrain's width is always a power of 2 + 1!</span>
01100   m_pRootBlock = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainn2">TerrainBlock</a>(0,m_WidthVertices - 1,<span class="keyword">this</span>,NULL);
01101   <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01102     cout &lt;&lt; endl;
01103 }
01104 
01105 <span class="keyword">inline</span> <span class="keywordtype">void</span> Terrain::SetVertexStatus(<span class="keywordtype">int</span> vertexIndex,<span class="keywordtype">bool</span> status)
01106 {
01107   <span class="keywordflow">if</span> (status)
01108     m_pVertexStatus-&gt;<a class="code" href="classbase_1_1BitArray.html#base_1_1BitArraya13">SetBit</a>(vertexIndex);
01109   <span class="keywordflow">else</span>
01110     m_pVertexStatus-&gt;<a class="code" href="classbase_1_1BitArray.html#base_1_1BitArraya14">ClearBit</a>(vertexIndex);
01111 }
01112 
01113 <span class="keyword">inline</span> <span class="keywordtype">bool</span> Terrain::GetVertexStatus(<span class="keywordtype">int</span> vertexIndex)
01114 {
01115   <span class="keywordflow">return</span> m_pVertexStatus-&gt;<a class="code" href="classbase_1_1BitArray.html#base_1_1BitArraya17">IsBitSet</a>(vertexIndex);
01116 }
01117 
<a name="l01118"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina4">01118</a> <span class="keywordtype">int</span> Terrain::Tessellate()
01119 {
01120   <span class="keywordflow">if</span> (m_pTriangleStrips == NULL)
01121     {
01122       <span class="keywordtype">long</span> <span class="keywordtype">int</span> maxNumStrips = (<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina9">GetWidthVertices</a>() - 1) * (<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina10">GetHeightVertices</a>() - 1);
01123       <span class="keywordflow">try</span>
01124         {
01125           <span class="keywordflow">if</span> (m_MaxNumberOfPrimitives &lt; maxNumStrips)
01126             maxNumStrips = m_MaxNumberOfPrimitives;
01127           <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01128             cout &lt;&lt; <span class="stringliteral">"TERRAIN: Allocating "</span> &lt;&lt; maxNumStrips &lt;&lt; <span class="stringliteral">" triangle strips and fans ("</span> &lt;&lt; maxNumStrips * <span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1TriangleStrip.html">TriangleStrip</a>) + maxNumStrips * <span class="keyword">sizeof</span>(<a class="code" href="classdemeter_1_1TriangleFan.html">TriangleFan</a>) &lt;&lt; <span class="stringliteral">" bytes)\n"</span> &lt;&lt; endl;
01129           m_pTriangleStrips = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TriangleStrip.html">TriangleStrip</a>[maxNumStrips];
01130           m_pTriangleFans = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1TriangleFan.html">TriangleFan</a>[maxNumStrips];
01131           <span class="keywordflow">if</span> (m_pTriangleStrips == NULL || m_pTriangleFans == NULL)
01132             {
01133               cout &lt;&lt; <span class="stringliteral">"TERRAIN: "</span> &lt;&lt; <span class="stringliteral">"Not enough memory to build terrain triangles"</span> &lt;&lt; endl;
01134               exit(1);
01135             }
01136         }
01137       <span class="keywordflow">catch</span>(...)
01138         {
01139           cout &lt;&lt; <span class="stringliteral">"TERRAIN: "</span> &lt;&lt; <span class="stringliteral">"Not enough memory to build terrain triangles"</span> &lt;&lt; endl;
01140           exit(1);
01141         }
01142     }
01143   
01144   <span class="keywordtype">double</span> matModelview[16];
01145   <span class="keywordtype">double</span> matProjection[16];
01146   GLint viewport[4];
01147   glGetDoublev(GL_MODELVIEW_MATRIX, matModelview);
01148   glGetDoublev(GL_PROJECTION_MATRIX, matProjection);
01149   glGetIntegerv(GL_VIEWPORT,viewport);
01150   
01151   ExtractFrustum();
01152   
01153   m_pVertexStatus-&gt;<a class="code" href="classbase_1_1BitArray.html#base_1_1BitArraya12">Clear</a>();
01154   m_CountStrips = m_CountFans = 0;
01155   m_pRootBlock-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka3">Tessellate</a>(matModelview,matProjection,viewport,m_pTriangleStrips,m_pTriangleFans,&amp;m_CountStrips,&amp;m_CountFans,<span class="keyword">this</span>);
01156   <span class="keywordflow">return</span> m_CountStrips * 2 + m_CountFans * 6;
01157 }
01158 
<a name="l01159"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina28">01159</a> <span class="keywordtype">bool</span> Terrain::SetCommonTexture(<span class="keywordtype">char</span>* szFilename)
01160 {
01161   <span class="keywordtype">bool</span> bSuccess = <span class="keyword">false</span>;
01162   <span class="keywordflow">if</span> (m_szSourceURL != NULL)
01163     DownloadFile(szFilename);
01164   m_szDetailTextureFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szFilename) + 1];
01165   sprintf(m_szDetailTextureFilename,szFilename);
01166   <span class="keywordtype">char</span>* szFullFilename;
01167   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szFilename,&amp;szFullFilename);
01168   <span class="keywordflow">if</span> (!<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa12">IsCompilerOnly</a>())
01169     {
01170       <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01171         cout &lt;&lt; <span class="stringliteral">"TERRAIN: Setting common texture to "</span> &lt;&lt; szFilename &lt;&lt; endl;
01172       <span class="keywordtype">int</span> width,height;
01173       <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pBuffer;
01174       <a class="code" href="CLODTerrainRenderer_8cpp.html#a17">LoadImage</a>(szFullFilename,&amp;width,&amp;height,&amp;pBuffer);
01175       <span class="keywordflow">if</span> (width == 0)
01176         {
01177           string msg(<span class="stringliteral">"Failed to load detail texture image file '"</span>);
01178           msg += szFullFilename;
01179           msg += <span class="stringliteral">"'; This means that the file was not found or it is not an image type that Demeter can read."</span>;
01180           <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
01181         }
01182       <span class="keywordflow">else</span>
01183         {
01184           <span class="comment">// Test to see if the image is a power of 2 in both width and height.</span>
01185           <span class="keywordflow">if</span> (!<a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>(width) || !<a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>(height))
01186             {
01187               string msg(<span class="stringliteral">"The detail texture image file '"</span>);
01188               msg += szFullFilename;
01189               msg += <span class="stringliteral">"' is NOT a power of 2 in both width and height.\nTexture files must be a power of 2 in both width and height."</span>;
01190               <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
01191             }
01192           m_pCommonTexture = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Texture.html">Texture</a>(pBuffer,width,height,width,0,<span class="keyword">false</span>,Settings::GetInstance()-&gt;IsTextureCompression());
01193           <span class="keyword">delete</span>[] pBuffer;
01194           bSuccess = <span class="keyword">true</span>;
01195           <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01196             cout &lt;&lt; <span class="stringliteral">"TERRAIN: Common texture set with successfully"</span> &lt;&lt; endl;
01197         }
01198       <span class="keyword">delete</span>[] szFullFilename;
01199     }
01200   <span class="keywordflow">else</span>
01201     {
01202       FILE* testFile = fopen(szFullFilename,<span class="stringliteral">"rb"</span>);
01203       <span class="keywordflow">if</span> (testFile)
01204         {
01205           bSuccess = <span class="keyword">true</span>;
01206           fclose(testFile);     
01207         }
01208     }
01209   <span class="keywordflow">return</span> bSuccess;
01210 }
01211 
01212 <span class="keywordtype">bool</span> Terrain::DownloadFile(<span class="keywordtype">char</span>* szFilename)
01213 {
01214   <span class="keywordtype">char</span> szFullURLName[1024];
01215   <span class="keywordtype">char</span>* szTempFilename;
01216   <span class="keywordtype">char</span>* szLocalFilename;
01217   
01218   sprintf(szFullURLName,<span class="stringliteral">"%s/%s"</span>,m_szSourceURL,szFilename);
01219   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(<span class="stringliteral">"temp.bin"</span>,&amp;szTempFilename);
01220   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szFilename,&amp;szLocalFilename);
01221   <span class="keywordtype">bool</span> success = <span class="keyword">false</span>; <span class="comment">//download(szFullURLName,szTempFilename,szLocalFilename);</span>
01222   
01223   <span class="keyword">delete</span>[] szTempFilename;
01224   <span class="keyword">delete</span>[] szLocalFilename;
01225   
01226   <span class="keywordflow">return</span> success;
01227 }
01228 
<a name="l01229"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina27">01229</a> <span class="keywordtype">bool</span> Terrain::SetTexture(<span class="keywordtype">char</span>* szFilename,<span class="keywordtype">bool</span> bUseBorders)
01230 {
01231   <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa19">IsHeadless</a>())
01232     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01233   <span class="keywordtype">bool</span> bSuccess = <span class="keyword">false</span>;
01234   <span class="keywordflow">if</span> (m_szSourceURL != NULL)
01235     DownloadFile(m_szTextureFilename);
01236   m_szTextureFilename = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szFilename) + 1];
01237   sprintf(m_szTextureFilename,szFilename);
01238   <span class="keywordtype">char</span>* szFullFilename;
01239   <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szFilename,&amp;szFullFilename);
01240   <span class="keywordflow">if</span> (!<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa12">IsCompilerOnly</a>())
01241     {
01242       <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01243         cout &lt;&lt; <span class="stringliteral">"TERRAIN: Setting texture to '"</span> &lt;&lt; szFullFilename &lt;&lt; <span class="stringliteral">"'"</span> &lt;&lt; endl;
01244       <span class="keywordtype">int</span> width,height;
01245       <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pBuffer;
01246       <a class="code" href="CLODTerrainRenderer_8cpp.html#a17">LoadImage</a>(szFullFilename,&amp;width,&amp;height,&amp;pBuffer);
01247       <span class="keywordflow">if</span> (width == 0)
01248         {
01249           string msg(<span class="stringliteral">"Failed to load texture image file '"</span>);
01250           msg += szFullFilename;
01251           msg += <span class="stringliteral">"'; This means that the file was not found or it is not an image type that Demeter can read."</span>;
01252           <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
01253         }
01254       <span class="keywordflow">else</span>
01255         {
01256           <span class="comment">// Test to see if the image is a power of 2 in both width and height.</span>
01257           <span class="keywordflow">if</span> (!<a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>(width) || !<a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>(height))
01258             {
01259               string msg(<span class="stringliteral">"The texture image file '"</span>);
01260               msg += szFullFilename;
01261               msg += <span class="stringliteral">"' is NOT a power of 2 in both width and height.\nTexture files must be a power of 2 in both width and height."</span>;
01262               <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
01263             }
01264           ChopTexture(pBuffer,width,height,256,bUseBorders);
01265           <span class="keyword">delete</span>[] pBuffer;
01266           bSuccess = <span class="keyword">true</span>;
01267           <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">IsVerbose</a>())
01268             cout &lt;&lt; <span class="stringliteral">"TERRAIN: Texture set successfully"</span> &lt;&lt; endl;
01269         }
01270     }
01271   <span class="keywordflow">else</span>
01272     {
01273       FILE* fileTest = fopen(szFullFilename,<span class="stringliteral">"rb"</span>);
01274       <span class="keywordflow">if</span> (fileTest)
01275         {
01276           bSuccess = <span class="keyword">true</span>;
01277           fclose(fileTest);     
01278         }
01279     }
01280   <span class="keyword">delete</span>[] szFullFilename;
01281   <span class="keywordflow">return</span> bSuccess;
01282 }
01283 
01284 <span class="keywordtype">void</span> Terrain::ChopTexture(<a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImage,<span class="keywordtype">int</span> width,<span class="keywordtype">int</span> height,<span class="keywordtype">int</span> tileSize,<span class="keywordtype">bool</span> bUseBorders)
01285 {
01286   <span class="comment">// It is assumed that the image is in a 3-byte per pixel, RGB format, with no padding on the pixel rows</span>
01287   m_TextureTileWidth = (<span class="keywordtype">int</span>)(((<span class="keywordtype">float</span>)(m_WidthVertices / (width / tileSize))) * m_VertexSpacing);
01288   m_TextureTileHeight = (<span class="keywordtype">int</span>)(((<span class="keywordtype">float</span>)(m_HeightVertices / (height / tileSize))) * m_VertexSpacing);
01289   m_NumberOfTextureTilesWidth = width / tileSize;
01290   m_NumberOfTextureTilesHeight = height / tileSize;
01291   m_NumberOfTextureTiles = (width / tileSize) * (height / tileSize);
01292   m_TileSize = tileSize;
01293   
01294   <span class="keywordflow">if</span> (bUseBorders)
01295     {
01296       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pBorderedImage = <span class="keyword">new</span> <a class="code" href="namespacedemeter.html#a0">Uint8</a>[(width + 2) * (height + 2) * 3];
01297       
01298       <span class="keywordtype">int</span> i;
01299       <span class="comment">// Create a temporary version of the original texture that is surrounded by a 1-pixel border.</span>
01300       <span class="keywordflow">for</span> (i = 0; i &lt; height; i++)
01301         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; width * 3; j++)
01302           pBorderedImage[(i + 1) * (width + 2) * 3 + j + 3] = pImage[i * width * 3 + j];
01303       
01304       <span class="comment">// Create texture tiles by roaming across the bordered image.</span>
01305       <span class="comment">//      int k = 0;</span>
01306       <span class="keywordflow">for</span> (i = 0; i &lt; height; i += tileSize)
01307         {
01308           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; width; j += tileSize)
01309             {
01310               <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pTile = pBorderedImage + i * (width + 2) * 3 + j * 3;
01311 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
01312 <span class="preprocessor"></span>              <a class="code" href="classdemeter_1_1Texture.html">Texture</a>* pTexture = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Texture.html">Texture</a>(pTile,tileSize,tileSize,width + 2,1,<span class="keyword">false</span>,Settings::GetInstance()-&gt;IsTextureCompression());
01313               m_Textures.push_back(pTexture);
01314 <span class="preprocessor">#else</span>
01315 <span class="preprocessor"></span>              Texture* pTexture = <span class="keyword">new</span> Texture(pTile,tileSize,tileSize,width + 2,1,<span class="keyword">true</span>,Settings::GetInstance()-&gt;IsTextureCompression());
01316               m_Textures.push_back(pTexture);
01317 <span class="preprocessor">#endif</span>
01318 <span class="preprocessor"></span>            }
01319         }
01320       <span class="keyword">delete</span>[] pBorderedImage;
01321     }
01322   <span class="keywordflow">else</span>
01323     {
01324       <span class="comment">// Create texture tiles by roaming across the bordered image.</span>
01325       <span class="comment">//int k = 0;</span>
01326       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; height; i += tileSize)
01327         {
01328           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; width; j += tileSize)
01329             {
01330                 <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pTile = pImage + i * width * 3 + j * 3;
01331 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
01332 <span class="preprocessor"></span>                Texture* pTexture = <span class="keyword">new</span> Texture(pTile,tileSize,tileSize,width,0,<span class="keyword">false</span>,Settings::GetInstance()-&gt;IsTextureCompression());
01333                 m_Textures.push_back(pTexture);
01334 <span class="preprocessor">#else</span>
01335 <span class="preprocessor"></span>                Texture* pTexture = <span class="keyword">new</span> Texture(pTile,tileSize,tileSize,width,0,<span class="keyword">true</span>,Settings::GetInstance()-&gt;IsTextureCompression());
01336                 m_Textures.push_back(pTexture);
01337 <span class="preprocessor">#endif</span>
01338 <span class="preprocessor"></span>            }
01339         }
01340     }
01341 }
01342 
01343 <span class="comment">/*</span>
01344 <span class="comment">void Terrain::DrawTile(SDL_Surface* pSurface,int index,int width,int height)</span>
01345 <span class="comment">{</span>
01346 <span class="comment">  int texWidth = m_TileSize;</span>
01347 <span class="comment">  int texHeight = m_TileSize;</span>
01348 <span class="comment">  Uint8* pBuffer = m_pTiles[index];</span>
01349 <span class="comment">  if (0 &lt; texWidth)</span>
01350 <span class="comment">    {</span>
01351 <span class="comment">      if (SDL_LockSurface(pSurface) &lt; 0)</span>
01352 <span class="comment">        cout &lt;&lt; "TERRAIN: ERROR: Couldn't lock the display surface" &lt;&lt; endl;</span>
01353 <span class="comment">      Uint8* pTargetBuffer = (Uint8 *)pSurface-&gt;pixels;</span>
01354 <span class="comment">      </span>
01355 <span class="comment">      for (int i = 0; i &lt; height - 1; i++)</span>
01356 <span class="comment">        {</span>
01357 <span class="comment">          for (int j = 0; j &lt; width - 1; j++)</span>
01358 <span class="comment">            {</span>
01359 <span class="comment">              int texOffset = i * texWidth * 3 + j * 3;</span>
01360 <span class="comment">              int surfaceOffset = i * pSurface-&gt;pitch + j * pSurface-&gt;format-&gt;BytesPerPixel;</span>
01361 <span class="comment">              int red = pBuffer[texOffset];</span>
01362 <span class="comment">              int green = pBuffer[texOffset + 1];</span>
01363 <span class="comment">              int blue = pBuffer[texOffset + 2];</span>
01364 <span class="comment">              Uint32 pixel = SDL_MapRGB(pSurface-&gt;format,red,green,blue);</span>
01365 <span class="comment">              Uint32* pTargetPixel = (Uint32*)(pTargetBuffer + surfaceOffset);</span>
01366 <span class="comment">              *pTargetPixel = pixel;</span>
01367 <span class="comment">            }</span>
01368 <span class="comment">        }</span>
01369 <span class="comment">      </span>
01370 <span class="comment">      SDL_UnlockSurface(pSurface);</span>
01371 <span class="comment">      SDL_UpdateRect(pSurface,0,0,0,0);</span>
01372 <span class="comment">      delete[] pBuffer;</span>
01373 <span class="comment">    }</span>
01374 <span class="comment">}</span>
01375 <span class="comment"></span>
01376 <span class="comment">void Terrain::DrawTexture(SDL_Surface* pSurface,int width,int height)</span>
01377 <span class="comment">{</span>
01378 <span class="comment">  int texWidth,texHeight;</span>
01379 <span class="comment">  Uint8* pBuffer;</span>
01380 <span class="comment">  LoadImage(m_szTextureFilename,&amp;texWidth,&amp;texHeight,&amp;pBuffer);</span>
01381 <span class="comment">  if (0 &lt; texWidth)</span>
01382 <span class="comment">    {</span>
01383 <span class="comment">      if (SDL_LockSurface(pSurface) &lt; 0)</span>
01384 <span class="comment">        cout &lt;&lt; "TERRAIN: ERROR: Couldn't lock the display surface" &lt;&lt; endl;</span>
01385 <span class="comment">      Uint8* pTargetBuffer = (Uint8 *)pSurface-&gt;pixels;</span>
01386 <span class="comment">      </span>
01387 <span class="comment">      for (int i = 0; i &lt; height - 1; i++)</span>
01388 <span class="comment">        {</span>
01389 <span class="comment">          for (int j = 0; j &lt; width - 1; j++)</span>
01390 <span class="comment">            {</span>
01391 <span class="comment">              int texOffset = i * texWidth * 3 + j * 3;</span>
01392 <span class="comment">              int surfaceOffset = i * pSurface-&gt;pitch + j * pSurface-&gt;format-&gt;BytesPerPixel;</span>
01393 <span class="comment">              int red = pBuffer[texOffset];</span>
01394 <span class="comment">              int green = pBuffer[texOffset + 1];</span>
01395 <span class="comment">              int blue = pBuffer[texOffset + 2];</span>
01396 <span class="comment">              Uint32 pixel = SDL_MapRGB(pSurface-&gt;format,red,green,blue);</span>
01397 <span class="comment">              Uint32* pTargetPixel = (Uint32*)(pTargetBuffer + surfaceOffset);</span>
01398 <span class="comment">              *pTargetPixel = pixel;</span>
01399 <span class="comment">            }</span>
01400 <span class="comment">        }</span>
01401 <span class="comment">      </span>
01402 <span class="comment">      SDL_UnlockSurface(pSurface);</span>
01403 <span class="comment">      SDL_UpdateRect(pSurface,0,0,0,0);</span>
01404 <span class="comment">      delete[] pBuffer;</span>
01405 <span class="comment">    }</span>
01406 <span class="comment">}</span>
01407 <span class="comment">*/</span>
01408 
<a name="l01409"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina8">01409</a> <span class="keywordtype">void</span> Terrain::SetMaximumVisibleBlockSize(<span class="keywordtype">int</span> stride)
01410 {
01411   m_MaximumVisibleBlockSize = stride;
01412 }
01413 
<a name="l01414"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina30">01414</a> <span class="keywordtype">float</span> Terrain::GetCommonTextureRepeats()
01415 {
01416   <span class="keywordflow">return</span> m_CommonTextureRepeats;
01417 }
01418 
<a name="l01419"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina29">01419</a> <span class="keywordtype">void</span> Terrain::SetCommonTextureRepeats(<span class="keywordtype">float</span> commonTextureRepeats)
01420 {
01421   m_CommonTextureRepeats = commonTextureRepeats;
01422 }
01423 
<a name="l01424"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina34">01424</a> <span class="keywordtype">int</span> Terrain::ModelViewMatrixChanged()
01425 {
01426   <span class="keywordtype">int</span> count = <a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina4">Tessellate</a>();
01427   m_pRootBlock-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">RepairCracks</a>(<span class="keyword">this</span>,m_pTriangleStrips,m_pTriangleFans,&amp;m_CountStrips,&amp;m_CountFans);
01428   <span class="keywordflow">return</span> count;
01429 }
01430 
<a name="l01431"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina5">01431</a> <span class="keywordtype">void</span> Terrain::Render()
01432 {
01433   <span class="keywordtype">int</span> i,j;
01434   <span class="keywordtype">bool</span> bUseMultiTexture = (m_bMultiTextureSupported &amp;&amp; m_pCommonTexture != NULL);
01435   
01436   glFrontFace(GL_CW);
01437   glEnable(GL_CULL_FACE);
01438   glCullFace(GL_BACK);
01439   
01440   <span class="keywordflow">if</span> (bUseMultiTexture)
01441     {
01442       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a2">GL_TEXTURE0_ARB</a>);
01443       glEnable(GL_TEXTURE_2D);
01444       glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
01445       glTexEnvf(GL_TEXTURE_ENV, <a class="code" href="CLODTerrainRenderer_8cpp.html#a4">GL_COMBINE_RGB_EXT</a>, GL_REPLACE);
01446       
01447       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a3">GL_TEXTURE1_ARB</a>);
01448       glEnable(GL_TEXTURE_2D);
01449       glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE, GL_MODULATE);
01450       glTexEnvf(GL_TEXTURE_ENV,<a class="code" href="CLODTerrainRenderer_8cpp.html#a4">GL_COMBINE_RGB_EXT</a>,GL_ADD);
01451       glBindTexture(GL_TEXTURE_2D,m_pCommonTexture-&gt;<a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea2">UploadTexture</a>());
01452     }
01453   <span class="keywordflow">else</span>
01454     glEnable(GL_TEXTURE_2D);
01455   
01456   <span class="keywordflow">for</span> (i = 0; i &lt; m_CountStrips; i++)
01457     m_pTriangleStrips[i].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripa3">Setup</a>(<span class="keyword">this</span>);
01458   
01459   <span class="keywordflow">for</span> (i = 0; i &lt; m_CountFans; i++)
01460     m_pTriangleFans[i].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFana3">Setup</a>(<span class="keyword">this</span>);
01461   
01462   <span class="keywordflow">if</span> (bUseMultiTexture)
01463     <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a2">GL_TEXTURE0_ARB</a>);
01464   
01465   glNormal3f(0.0<a class="code" href="Makefile_8in.html#a5">f</a>,0.0<a class="code" href="Makefile_8in.html#a5">f</a>,1.0<a class="code" href="Makefile_8in.html#a5">f</a>);
01466   
01467   <span class="comment">// Prevent state thrashing by rendering one texture at a time...</span>
01468   <span class="keywordflow">for</span> (i = 0; i &lt; m_NumberOfTextureTiles; i++)
01469     {
01470       <span class="keywordtype">bool</span> firstTime = <span class="keyword">true</span>;
01471       <span class="keywordflow">for</span> (j = 0; j &lt; m_CountStrips; j++)
01472         {
01473           <span class="keywordflow">if</span> (m_pTriangleStrips[j].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripr4">textureId</a> == i)
01474             {
01475               <span class="keywordflow">if</span> (firstTime)
01476                 {
01477                   glBindTexture(GL_TEXTURE_2D,<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina26">GetTerrainTile</a>(i));
01478                   firstTime = <span class="keyword">false</span>;
01479                 }
01480               m_pTriangleStrips[j].<a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripa2">Render</a>(<span class="keyword">this</span>);
01481             }
01482         }
01483       <span class="keywordflow">for</span> (j = 0; j &lt; m_CountFans; j++)
01484         {
01485           <span class="keywordflow">if</span> (m_pTriangleFans[j].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFanr4">textureId</a> == i)
01486             {
01487               <span class="keywordflow">if</span> (firstTime)
01488                 {
01489                   glBindTexture(GL_TEXTURE_2D,<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina26">GetTerrainTile</a>(i));
01490                   firstTime = <span class="keyword">false</span>;
01491                 }
01492               m_pTriangleFans[j].<a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFana2">Render</a>(<span class="keyword">this</span>);
01493             }
01494         }
01495       <span class="keywordflow">if</span> (<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa15">UseDynamicTextures</a>() &amp;&amp; firstTime)
01496         {
01497           UnloadTerrainTile(i);
01498         }
01499     }
01500   glFrontFace(GL_CCW);
01501   <span class="comment">// Turn multi-texture back off again so the client application doesn't end up in an unexpected state.</span>
01502   <span class="comment">//    if (bUseMultiTexture)</span>
01503   <span class="comment">//    {</span>
01504   <span class="comment">//            glActiveTextureARB_ptr(GL_TEXTURE1_ARB);</span>
01505   <span class="comment">//            glDisable(GL_TEXTURE_2D);</span>
01506   <span class="comment">//            glActiveTextureARB_ptr(GL_TEXTURE0_ARB);</span>
01507   <span class="comment">//            glDisable(GL_TEXTURE_2D);</span>
01508   <span class="comment">//    }</span>
01509 }
01510 
<a name="l01511"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina37">01511</a> <span class="keywordtype">void</span> Terrain::DisableTextures()
01512 {
01513   <span class="keywordflow">if</span> (m_bMultiTextureSupported)
01514     {
01515       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a2">GL_TEXTURE0_ARB</a>);
01516       glDisable(GL_TEXTURE_2D);
01517       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a3">GL_TEXTURE1_ARB</a>);
01518       glDisable(GL_TEXTURE_2D);
01519     }
01520   <span class="keywordflow">else</span>
01521     glDisable(GL_TEXTURE_2D);
01522 }
01523 
<a name="l01524"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina38">01524</a> <span class="keywordtype">void</span> Terrain::EnableTextures()
01525 {
01526   <span class="keywordflow">if</span> (m_bMultiTextureSupported)
01527     {
01528       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a2">GL_TEXTURE0_ARB</a>);
01529       glEnable(GL_TEXTURE_2D);
01530       <a class="code" href="CLODTerrainRenderer_8cpp.html#a11">glActiveTextureARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a3">GL_TEXTURE1_ARB</a>);
01531       glEnable(GL_TEXTURE_2D);
01532     }
01533   <span class="keywordflow">else</span>
01534     glEnable(GL_TEXTURE_2D);
01535 }
01536 
<a name="l01537"></a><a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripa0">01537</a> TriangleStrip::TriangleStrip()
01538 {
01539 }
01540 
<a name="l01541"></a><a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripa1">01541</a> TriangleStrip::~TriangleStrip()
01542 {
01543 }
01544 
<a name="l01545"></a><a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripa3">01545</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> TriangleStrip::Setup(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
01546 {
01547   <span class="keywordflow">if</span> (m_bEnabled)
01548     {
01549       minX = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[0]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01550       minY = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[0]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01551       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; m_NumberOfVertices; i++)
01552         {
01553           <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &lt; minX)
01554             minX = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01555           <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &lt; minY)
01556             minY = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01557         }
01558       <span class="keywordtype">int</span> tileY = (<span class="keywordtype">int</span>)minY / pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina23">GetTextureTileHeight</a>();
01559       <span class="keywordtype">int</span> tileX = (<span class="keywordtype">int</span>)minX / pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina22">GetTextureTileWidth</a>();
01560       textureId = tileY * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina24">GetNumberOfTextureTilesWidth</a>() + tileX;
01561     }
01562 }
01563 
<a name="l01564"></a><a class="code" href="classdemeter_1_1TriangleStrip.html#demeter_1_1TriangleStripa2">01564</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> TriangleStrip::Render(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
01565 {
01566   <span class="keywordflow">if</span> (m_bEnabled)
01567     {
01568       <span class="comment">// IMPORTANT NOTE: Using glDrawElements() is a modest speed gain, but we lose multi-texturing and the use of different</span>
01569       <span class="comment">// texture coordinates for a single vertex! If there is some way to still have these features while using glDrawElements,</span>
01570       <span class="comment">// then re-enable this code in place of the rest of this method.</span>
01571 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
01572 <span class="preprocessor"></span>      glDrawElements(GL_TRIANGLE_STRIP,m_NumberOfVertices,GL_UNSIGNED_INT,m_pVertices);
01573 <span class="preprocessor">#else</span>
01574 <span class="preprocessor"></span>      <span class="keywordtype">float</span> texU,texV;
01575       glBegin(GL_TRIANGLE_STRIP);
01576       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_NumberOfVertices; i++)
01577         {
01578           texU = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> / (<span class="keywordtype">float</span>)pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina22">GetTextureTileWidth</a>();
01579           texV = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> / (<span class="keywordtype">float</span>)pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina23">GetTextureTileHeight</a>();
01580           <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)texU - (<span class="keywordtype">int</span>)texU &lt; <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01581             texU = 1.0f;
01582           <span class="keywordflow">else</span>
01583             texU = (<span class="keywordtype">float</span>)texU - (<span class="keywordtype">int</span>)texU;
01584           <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)texV - (<span class="keywordtype">int</span>)texV &lt; <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01585             texV = 1.0f;
01586           <span class="keywordflow">else</span>
01587             texV = (<span class="keywordtype">float</span>)texV - (<span class="keywordtype">int</span>)texV;
01588           <span class="keywordflow">if</span> (fabs(1.0<a class="code" href="Makefile_8in.html#a5">f</a> - texU) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a> &amp;&amp; fabs(minX - pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].x) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01589             texU = 0.0f;
01590           <span class="keywordflow">if</span> (fabs(1.0<a class="code" href="Makefile_8in.html#a5">f</a> - texV) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a> &amp;&amp; fabs(minY - pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].y) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01591             texV = 0.0f;
01592           <span class="keywordflow">if</span> (!pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr30">m_bMultiTextureSupported</a>)
01593             glTexCoord2f(texU,texV);
01594           <span class="keywordflow">else</span>
01595             {
01596               <a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a2">GL_TEXTURE0_ARB</a>,texU,texV);
01597               <a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a3">GL_TEXTURE1_ARB</a>,texU * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina30">GetCommonTextureRepeats</a>(),texV * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina30">GetCommonTextureRepeats</a>());
01598             }
01599           glVertex3f(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].x + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr34">m_OffsetX</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].y + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr35">m_OffsetY</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].z);
01600         }
01601       glEnd();
01602 <span class="preprocessor">#endif</span>
01603 <span class="preprocessor"></span>    }
01604 }
01605 
<a name="l01606"></a><a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFana0">01606</a> TriangleFan::TriangleFan()
01607 {
01608 }
01609 
<a name="l01610"></a><a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFana1">01610</a> TriangleFan::~TriangleFan()
01611 {
01612 }
01613 
<a name="l01614"></a><a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFana3">01614</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> TriangleFan::Setup(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
01615 {
01616   minX = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[0]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01617   minY = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[0]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01618   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; m_NumberOfVertices; i++)
01619     {
01620       <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &lt; minX)
01621         minX = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01622       <span class="keywordflow">if</span> (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &lt; minY)
01623         minY = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01624     }
01625   <span class="keywordtype">int</span> tileY = (<span class="keywordtype">int</span>)minY / pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina23">GetTextureTileHeight</a>();
01626   <span class="keywordtype">int</span> tileX = (<span class="keywordtype">int</span>)minX / pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina22">GetTextureTileWidth</a>();
01627   textureId = tileY * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina24">GetNumberOfTextureTilesWidth</a>() + tileX;
01628 }
01629 
<a name="l01630"></a><a class="code" href="classdemeter_1_1TriangleFan.html#demeter_1_1TriangleFana2">01630</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> TriangleFan::Render(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
01631 {
01632   <span class="comment">// IMPORTANT NOTE: Using glDrawElements() is a modest speed gain, but we lose multi-texturing and the use of different</span>
01633   <span class="comment">// texture coordinates for a single vertex! If there is some way to still have these features while using glDrawElements,</span>
01634   <span class="comment">// then re-enable this code in place of the rest of this method.</span>
01635 <span class="preprocessor">#ifdef _USE_VERTEX_ARRAYS_</span>
01636 <span class="preprocessor"></span>  glDrawElements(GL_TRIANGLE_FAN,m_NumberOfVertices,GL_UNSIGNED_INT,m_pVertices);
01637 <span class="preprocessor">#else</span>
01638 <span class="preprocessor"></span>  <span class="keywordtype">float</span> texU,texV;
01639   glBegin(GL_TRIANGLE_FAN);
01640   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_NumberOfVertices; i++)
01641     {
01642       texU = (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>) / (<span class="keywordtype">float</span>)pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina22">GetTextureTileWidth</a>();
01643       texV = (pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>) / (<span class="keywordtype">float</span>)pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina23">GetTextureTileHeight</a>();
01644       <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)texU - (<span class="keywordtype">int</span>)texU &lt; <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01645         texU = 1.0f;
01646       <span class="keywordflow">else</span>
01647         texU = (<span class="keywordtype">float</span>)texU - (<span class="keywordtype">int</span>)texU;
01648       <span class="keywordflow">if</span> ((<span class="keywordtype">float</span>)texV - (<span class="keywordtype">int</span>)texV &lt; <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01649         texV = 1.0f;
01650       <span class="keywordflow">else</span>
01651         texV = (<span class="keywordtype">float</span>)texV - (<span class="keywordtype">int</span>)texV;
01652       <span class="keywordflow">if</span> (fabs(1.0<a class="code" href="Makefile_8in.html#a5">f</a> - texU) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a> &amp;&amp; fabs(minX - pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].x) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01653         texU = 0.0f;
01654       <span class="keywordflow">if</span> (fabs(1.0<a class="code" href="Makefile_8in.html#a5">f</a> - texV) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a> &amp;&amp; fabs(minY - pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].y) &lt;= <a class="code" href="CLODTerrainRenderer.html#a2">EPSILON</a>)
01655         texV = 0.0f;
01656       <span class="keywordflow">if</span> (!pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr30">m_bMultiTextureSupported</a>)
01657         glTexCoord2f(texU,texV);
01658       <span class="keywordflow">else</span>
01659         {
01660           <a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a2">GL_TEXTURE0_ARB</a>,texU,texV);
01661           <a class="code" href="CLODTerrainRenderer_8cpp.html#a10">glMultiTexCoord2fARB_ptr</a>(<a class="code" href="CLODTerrainRenderer_8cpp.html#a3">GL_TEXTURE1_ARB</a>,texU * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina30">GetCommonTextureRepeats</a>(),texV * pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina30">GetCommonTextureRepeats</a>());
01662         }
01663       glVertex3f(pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].x + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr34">m_OffsetX</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].y + pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr35">m_OffsetY</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr22">m_pVertices</a>[m_pVertices[i]].z);
01664     }
01665   glEnd();
01666 <span class="preprocessor">#endif</span>
01667 <span class="preprocessor"></span>}
01668 
<a name="l01669"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina22">01669</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> Terrain::GetTextureTileWidth()
01670 {
01671   <span class="keywordflow">return</span> m_TextureTileWidth;
01672 }
01673 
<a name="l01674"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina23">01674</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> Terrain::GetTextureTileHeight()
01675 {
01676   <span class="keywordflow">return</span> m_TextureTileHeight;
01677 }
01678 
<a name="l01679"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina24">01679</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> Terrain::GetNumberOfTextureTilesWidth()
01680 {
01681   <span class="keywordflow">return</span> m_NumberOfTextureTilesWidth;
01682 }
01683 
<a name="l01684"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina25">01684</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> Terrain::GetNumberOfTextureTilesHeight()
01685 {
01686   <span class="keywordflow">return</span> m_NumberOfTextureTilesHeight;
01687 }
01688 
<a name="l01689"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina26">01689</a> <span class="keyword">inline</span> GLuint Terrain::GetTerrainTile(<span class="keywordtype">int</span> index)
01690 {
01691   Texture* pTexture = m_Textures[index];
01692   GLuint val = pTexture-&gt;<a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea2">UploadTexture</a>();
01693   <span class="keywordflow">return</span> val;
01694 }
01695 
01696 <span class="keyword">inline</span> <span class="keywordtype">void</span> Terrain::UnloadTerrainTile(<span class="keywordtype">int</span> index)
01697 {
01698   Texture* pTexture = m_Textures[index];
01699   pTexture-&gt;<a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea3">UnloadTexture</a>();
01700 }
01701 
01702 <span class="keyword">inline</span> <span class="keywordtype">void</span> Terrain::ExtractFrustum()
01703 {
01704   <span class="keywordtype">float</span> proj[16];
01705   <span class="keywordtype">float</span> modl[16];
01706   <span class="keywordtype">float</span> clip[16];
01707   <span class="keywordtype">float</span> t;
01708   <span class="comment">/* Get the current PROJECTION matrix from OpenGL */</span>
01709   glGetFloatv(GL_PROJECTION_MATRIX, proj);
01710   <span class="comment">/* Get the current MODELVIEW matrix from OpenGL */</span>
01711   glGetFloatv(GL_MODELVIEW_MATRIX, modl);
01712   <span class="comment">/* Combine the two matrices (multiply projection by modelview) */</span>
01713   clip[ 0] = modl[ 0] * proj[ 0] + modl[ 1] * proj[ 4] + modl[ 2] * proj[ 8] + modl[ 3] * proj[12];
01714   clip[ 1] = modl[ 0] * proj[ 1] + modl[ 1] * proj[ 5] + modl[ 2] * proj[ 9] + modl[ 3] * proj[13];
01715   clip[ 2] = modl[ 0] * proj[ 2] + modl[ 1] * proj[ 6] + modl[ 2] * proj[10] + modl[ 3] * proj[14];
01716   clip[ 3] = modl[ 0] * proj[ 3] + modl[ 1] * proj[ 7] + modl[ 2] * proj[11] + modl[ 3] * proj[15];
01717   clip[ 4] = modl[ 4] * proj[ 0] + modl[ 5] * proj[ 4] + modl[ 6] * proj[ 8] + modl[ 7] * proj[12];
01718   clip[ 5] = modl[ 4] * proj[ 1] + modl[ 5] * proj[ 5] + modl[ 6] * proj[ 9] + modl[ 7] * proj[13];
01719   clip[ 6] = modl[ 4] * proj[ 2] + modl[ 5] * proj[ 6] + modl[ 6] * proj[10] + modl[ 7] * proj[14];
01720   clip[ 7] = modl[ 4] * proj[ 3] + modl[ 5] * proj[ 7] + modl[ 6] * proj[11] + modl[ 7] * proj[15];
01721   clip[ 8] = modl[ 8] * proj[ 0] + modl[ 9] * proj[ 4] + modl[10] * proj[ 8] + modl[11] * proj[12];
01722   clip[ 9] = modl[ 8] * proj[ 1] + modl[ 9] * proj[ 5] + modl[10] * proj[ 9] + modl[11] * proj[13];
01723   clip[10] = modl[ 8] * proj[ 2] + modl[ 9] * proj[ 6] + modl[10] * proj[10] + modl[11] * proj[14];
01724   clip[11] = modl[ 8] * proj[ 3] + modl[ 9] * proj[ 7] + modl[10] * proj[11] + modl[11] * proj[15];
01725   clip[12] = modl[12] * proj[ 0] + modl[13] * proj[ 4] + modl[14] * proj[ 8] + modl[15] * proj[12];
01726   clip[13] = modl[12] * proj[ 1] + modl[13] * proj[ 5] + modl[14] * proj[ 9] + modl[15] * proj[13];
01727   clip[14] = modl[12] * proj[ 2] + modl[13] * proj[ 6] + modl[14] * proj[10] + modl[15] * proj[14];
01728   clip[15] = modl[12] * proj[ 3] + modl[13] * proj[ 7] + modl[14] * proj[11] + modl[15] * proj[15];
01729   <span class="comment">/* Extract the numbers for the RIGHT plane */</span>
01730   m_Frustum[0][0] = clip[ 3] - clip[ 0];
01731   m_Frustum[0][1] = clip[ 7] - clip[ 4];
01732   m_Frustum[0][2] = clip[11] - clip[ 8];
01733   m_Frustum[0][3] = clip[15] - clip[12];
01734   <span class="comment">/* Normalize the result */</span>
01735   t = sqrt(m_Frustum[0][0] * m_Frustum[0][0] + m_Frustum[0][1] * m_Frustum[0][1] + m_Frustum[0][2] * m_Frustum[0][2]);
01736   m_Frustum[0][0] /= t;
01737   m_Frustum[0][1] /= t;
01738   m_Frustum[0][2] /= t;
01739   m_Frustum[0][3] /= t;
01740   <span class="comment">/* Extract the numbers for the LEFT plane */</span>
01741   m_Frustum[1][0] = clip[ 3] + clip[ 0];
01742   m_Frustum[1][1] = clip[ 7] + clip[ 4];
01743   m_Frustum[1][2] = clip[11] + clip[ 8];
01744   m_Frustum[1][3] = clip[15] + clip[12];
01745   <span class="comment">/* Normalize the result */</span>
01746   t = sqrt(m_Frustum[1][0] * m_Frustum[1][0] + m_Frustum[1][1] * m_Frustum[1][1] + m_Frustum[1][2] * m_Frustum[1][2]);
01747   m_Frustum[1][0] /= t;
01748   m_Frustum[1][1] /= t;
01749   m_Frustum[1][2] /= t;
01750   m_Frustum[1][3] /= t;
01751   <span class="comment">/* Extract the BOTTOM plane */</span>
01752   m_Frustum[2][0] = clip[ 3] + clip[ 1];
01753   m_Frustum[2][1] = clip[ 7] + clip[ 5];
01754   m_Frustum[2][2] = clip[11] + clip[ 9];
01755   m_Frustum[2][3] = clip[15] + clip[13];
01756   <span class="comment">/* Normalize the result */</span>
01757   t = sqrt(m_Frustum[2][0] * m_Frustum[2][0] + m_Frustum[2][1] * m_Frustum[2][1] + m_Frustum[2][2] * m_Frustum[2][2]);
01758   m_Frustum[2][0] /= t;
01759   m_Frustum[2][1] /= t;
01760   m_Frustum[2][2] /= t;
01761   m_Frustum[2][3] /= t;
01762   <span class="comment">/* Extract the TOP plane */</span>
01763   m_Frustum[3][0] = clip[ 3] - clip[ 1];
01764   m_Frustum[3][1] = clip[ 7] - clip[ 5];
01765   m_Frustum[3][2] = clip[11] - clip[ 9];
01766   m_Frustum[3][3] = clip[15] - clip[13];
01767   <span class="comment">/* Normalize the result */</span>
01768   t = sqrt(m_Frustum[3][0] * m_Frustum[3][0] + m_Frustum[3][1] * m_Frustum[3][1] + m_Frustum[3][2] * m_Frustum[3][2]);
01769   m_Frustum[3][0] /= t;
01770   m_Frustum[3][1] /= t;
01771   m_Frustum[3][2] /= t;
01772   m_Frustum[3][3] /= t;
01773   <span class="comment">/* Extract the FAR plane */</span>
01774   m_Frustum[4][0] = clip[ 3] - clip[ 2];
01775   m_Frustum[4][1] = clip[ 7] - clip[ 6];
01776   m_Frustum[4][2] = clip[11] - clip[10];
01777   m_Frustum[4][3] = clip[15] - clip[14];
01778   <span class="comment">/* Normalize the result */</span>
01779   t = sqrt(m_Frustum[4][0] * m_Frustum[4][0] + m_Frustum[4][1] * m_Frustum[4][1] + m_Frustum[4][2] * m_Frustum[4][2]);
01780   m_Frustum[4][0] /= t;
01781   m_Frustum[4][1] /= t;
01782   m_Frustum[4][2] /= t;
01783   m_Frustum[4][3] /= t;
01784   <span class="comment">/* Extract the NEAR plane */</span>
01785   m_Frustum[5][0] = clip[ 3] + clip[ 2];
01786   m_Frustum[5][1] = clip[ 7] + clip[ 6];
01787   m_Frustum[5][2] = clip[11] + clip[10];
01788   m_Frustum[5][3] = clip[15] + clip[14];
01789   <span class="comment">/* Normalize the result */</span>
01790   t = sqrt(m_Frustum[5][0] * m_Frustum[5][0] + m_Frustum[5][1] * m_Frustum[5][1] + m_Frustum[5][2] * m_Frustum[5][2]);
01791   m_Frustum[5][0] /= t;
01792   m_Frustum[5][1] /= t;
01793   m_Frustum[5][2] /= t;
01794   m_Frustum[5][3] /= t;
01795 }
01796 
<a name="l01797"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina35">01797</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> Terrain::CubeInFrustum(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z, <span class="keywordtype">float</span> size)
01798 {
01799   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; 6; p++)
01800     {
01801       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x - size) + m_Frustum[p][1] * (y - size) + m_Frustum[p][2] * (z - size) + m_Frustum[p][3] &gt; 0)
01802         <span class="keywordflow">continue</span>;
01803       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x + size) + m_Frustum[p][1] * (y - size) + m_Frustum[p][2] * (z - size) + m_Frustum[p][3] &gt; 0)
01804         <span class="keywordflow">continue</span>;
01805       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x - size) + m_Frustum[p][1] * (y + size) + m_Frustum[p][2] * (z - size) + m_Frustum[p][3] &gt; 0)
01806         <span class="keywordflow">continue</span>;
01807       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x + size) + m_Frustum[p][1] * (y + size) + m_Frustum[p][2] * (z - size) + m_Frustum[p][3] &gt; 0)
01808         <span class="keywordflow">continue</span>;
01809       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x - size) + m_Frustum[p][1] * (y - size) + m_Frustum[p][2] * (z + size) + m_Frustum[p][3] &gt; 0)
01810         <span class="keywordflow">continue</span>;
01811       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x + size) + m_Frustum[p][1] * (y - size) + m_Frustum[p][2] * (z + size) + m_Frustum[p][3] &gt; 0)
01812         <span class="keywordflow">continue</span>;
01813       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x - size) + m_Frustum[p][1] * (y + size) + m_Frustum[p][2] * (z + size) + m_Frustum[p][3] &gt; 0)
01814         <span class="keywordflow">continue</span>;
01815       <span class="keywordflow">if</span>(m_Frustum[p][0] * (x + size) + m_Frustum[p][1] * (y + size) + m_Frustum[p][2] * (z + size) + m_Frustum[p][3] &gt; 0)
01816         <span class="keywordflow">continue</span>;
01817       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01818     }
01819   <span class="keywordflow">return</span> <span class="keyword">true</span>;
01820 }
01821 
01822 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
01823 <span class="preprocessor"></span><span class="keywordtype">float</span> Terrain::IntersectRay(<span class="keywordtype">float</span> startX,<span class="keywordtype">float</span> startY,<span class="keywordtype">float</span> startZ,<span class="keywordtype">float</span> dirX,<span class="keywordtype">float</span> dirY,<span class="keywordtype">float</span> dirZ,<span class="keywordtype">float</span>&amp; intersectX,<span class="keywordtype">float</span>&amp; intersectY,<span class="keywordtype">float</span>&amp; intersectZ)
01824 {
01825   <a class="code" href="classdemeter_1_1Ray.html">Ray</a> ray;
01826   <span class="keywordtype">float</span> distance = <a class="code" href="CLODTerrainRenderer.html#a3">INFINITY</a>;
01827   Vector point;
01828   point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = -1.0f;
01829   
01830   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = startX;
01831   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = startY;
01832   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = startZ;
01833   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = dirX;
01834   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = dirY;
01835   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = dirZ;
01836   ray.<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora3">Normalize</a>();
01837   m_pRootBlock-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka14">IntersectRay</a>(ray,point,distance,<span class="keyword">this</span>);
01838   intersectX = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01839   intersectY = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01840   intersectZ = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
01841   <span class="keywordflow">return</span> distance;
01842 }
01843 <span class="preprocessor">#endif</span>
01844 <span class="preprocessor"></span>
<a name="l01845"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina39">01845</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> Terrain::SetLatticePosition(<span class="keywordtype">int</span> x,<span class="keywordtype">int</span> y)
01846 {
01847   m_LatticePositionX = x;
01848   m_LatticePositionY = y;
01849 }
01850 
<a name="l01851"></a><a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina40">01851</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> Terrain::GetLatticePosition(<span class="keywordtype">int</span>&amp; x,<span class="keywordtype">int</span>&amp; y)
01852 {
01853   x = m_LatticePositionX;
01854   y = m_LatticePositionY;
01855 }
01856 
01857 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
01858 <span class="preprocessor"></span><span class="keywordtype">void</span> TerrainBlock::IntersectRay(<a class="code" href="classdemeter_1_1Ray.html">Ray</a>&amp; ray,Vector&amp; intersectionPoint,<span class="keywordtype">float</span>&amp; lowestDistance,<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain)
01859 {
01860   <span class="comment">// First test ray against this block's bounding box.</span>
01861   <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a19">RayBoxIntersect</a>(&amp;ray,&amp;m_BoundingBox,NULL,NULL))
01862     {
01863       <span class="keywordflow">if</span> (2 &lt; m_Stride)
01864         {
01865           m_pChildren[0]-&gt;IntersectRay(ray,intersectionPoint,lowestDistance,pTerrain);
01866           m_pChildren[1]-&gt;IntersectRay(ray,intersectionPoint,lowestDistance,pTerrain);
01867           m_pChildren[2]-&gt;IntersectRay(ray,intersectionPoint,lowestDistance,pTerrain);
01868           m_pChildren[3]-&gt;IntersectRay(ray,intersectionPoint,lowestDistance,pTerrain);
01869         }
01870       <span class="keywordflow">else</span>
01871         {
01872           <span class="keywordtype">float</span> distance;
01873           Vector point;
01874           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)
01875             {
01876               <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a18">RayPlaneIntersect</a>(&amp;ray,m_pTriangles[i].GetPlane(),&amp;point,&amp;distance) == 1)
01877                 {
01878                   <span class="keywordflow">if</span> (i == 0 || i == 2 || i == 4 || i == 6)
01879                     {
01880                       <span class="keywordflow">if</span> (m_pTriangles[i].GetVertex(0)-&gt;x &lt;= point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &amp;&amp;
01881                           m_pTriangles[i].GetVertex(0)-&gt;y &lt;= point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &amp;&amp;
01882                           point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &lt;= m_pTriangles[i].GetVertex(2)-&gt;x &amp;&amp;
01883                           point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &lt;= m_pTriangles[i].GetVertex(1)-&gt;y &amp;&amp;
01884                           ((fmod(point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr5">m_VertexSpacing</a>) + fmod(point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr5">m_VertexSpacing</a>)) &lt;= pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr5">m_VertexSpacing</a>))
01885                         {
01886                           <span class="keywordflow">if</span> (distance &lt; lowestDistance)
01887                             {
01888                               lowestDistance = distance;
01889                               intersectionPoint.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01890                               intersectionPoint.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01891                               intersectionPoint.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
01892                             }
01893                         }
01894                     }
01895                   <span class="keywordflow">else</span>
01896                     {
01897                       <span class="keywordflow">if</span> (m_pTriangles[i].GetVertex(1)-&gt;x &lt;= point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &amp;&amp;
01898                           m_pTriangles[i].GetVertex(0)-&gt;y &lt;= point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &amp;&amp;
01899                           point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &lt;= m_pTriangles[i].GetVertex(2)-&gt;x &amp;&amp;
01900                           point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &lt;= m_pTriangles[i].GetVertex(1)-&gt;y &amp;&amp;
01901                           ((fmod(point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr5">m_VertexSpacing</a>) + fmod(point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>,pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr5">m_VertexSpacing</a>)) &gt;= pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr5">m_VertexSpacing</a>))
01902                         {
01903                           <span class="keywordflow">if</span> (distance &lt; lowestDistance)
01904                             {
01905                               lowestDistance = distance;
01906                               intersectionPoint.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01907                               intersectionPoint.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01908                               intersectionPoint.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = point.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
01909                             }
01910                         }
01911                     }
01912                 }
01913             }
01914         }
01915     }
01916 }
01917 
01918 <span class="keywordtype">int</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a18">RayPlaneIntersect</a>(<a class="code" href="classdemeter_1_1Ray.html">Ray</a> *ray,<a class="code" href="classdemeter_1_1Plane.html">Plane</a> *plane,Vector* point,<span class="keywordtype">float</span> *distance)
01919 {
01920   <span class="keywordtype">float</span>                 vd,vo,PnDOTRo,t;
01921   
01922   vd = plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo0">a</a> * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo1">b</a> * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo2">c</a> * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
01923   <span class="keywordflow">if</span> (vd == 0.0)
01924     <span class="comment">// The plane is parallel to the ray. I've never seen this happen but someday it will . . .</span>
01925     <span class="keywordflow">return</span> -1;
01926   <span class="keywordflow">if</span> (vd &gt; 0.0)
01927     {
01928       <span class="comment">// The plane is facing away from the ray so no intersection occurs.</span>
01929       <span class="keywordflow">return</span> -2;
01930     }
01931   PnDOTRo = plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo0">a</a> * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo1">b</a> * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo2">c</a> * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
01932   vo = -1.0f * (PnDOTRo + plane-&gt;<a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo3">d</a>);
01933   t = vo / vd;
01934   <span class="keywordflow">if</span> (t &lt; 0.0f)
01935     <span class="comment">// The intersection occurs behind the ray's origin.</span>
01936     <span class="keywordflow">return</span> -3;
01937   point-&gt;<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> * t;
01938   point-&gt;<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> * t;
01939   point-&gt;<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> + ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> * t;
01940   <span class="keywordflow">if</span> (distance != NULL)
01941     *distance = t;
01942   <span class="keywordflow">return</span> 1;
01943 }
01944 
01945 <span class="keywordtype">int</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a19">RayBoxIntersect</a>(<a class="code" href="classdemeter_1_1Ray.html">Ray</a> *ray,Box *box,Vector *point,<span class="keywordtype">float</span> *distance)
01946 {
01947   <span class="keywordtype">float</span>         tnear,tfar,t1,t2;
01948   
01949   tnear = -<a class="code" href="CLODTerrainRenderer.html#a3">INFINITY</a>;
01950   tfar = <a class="code" href="CLODTerrainRenderer.html#a3">INFINITY</a>;
01951   
01952   <span class="comment">// Find intersection with x-aligned planes of box.</span>
01953   <span class="comment">// If the ray is parallel to the box and not within the planes of the box it misses.</span>
01954   <span class="keywordflow">if</span> (ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> == 0.0)
01955     <span class="keywordflow">if</span> ((ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &lt; box-&gt;m_Min.x) &amp;&amp; (ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> &gt; box-&gt;m_Max.x))
01956       <span class="keywordflow">return</span> 0;
01957   <span class="comment">// Calculate intersection distance with the box's planes.</span>
01958   t1 = (box-&gt;m_Min.x - ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>) / ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01959   t2 = (box-&gt;m_Max.x - ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>) / ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
01960   <span class="keywordflow">if</span> (t1 &gt; t2)
01961     {
01962       <span class="keywordtype">float</span> tmp = t1;
01963       t1 = t2;
01964       t2 = tmp;
01965     }
01966   <span class="keywordflow">if</span> (t1 &gt; tnear)
01967     tnear = t1;
01968   <span class="keywordflow">if</span> (t2 &lt; tfar)
01969     tfar = t2;
01970   <span class="keywordflow">if</span> (tnear &gt; tfar)
01971     <span class="keywordflow">return</span> 0;
01972   <span class="keywordflow">if</span> (tfar &lt; 0.0)
01973     <span class="keywordflow">return</span> 0;
01974   <span class="comment">// Find intersection with y-aligned planes of box.</span>
01975   <span class="comment">// If the ray is parallel to the box and not within the planes of the box it misses.</span>
01976   <span class="keywordflow">if</span> (ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> == 0.0)
01977     <span class="keywordflow">if</span> ((ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &lt; box-&gt;m_Min.y) &amp;&amp; (ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> &gt; box-&gt;m_Max.y))
01978       <span class="keywordflow">return</span> 0;
01979   <span class="comment">// Calculate intersection distance with the box's planes.</span>
01980   t1 = (box-&gt;m_Min.y - ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>) / ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01981   t2 = (box-&gt;m_Max.y - ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>) / ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
01982   <span class="keywordflow">if</span> (t1 &gt; t2)
01983     {
01984       <span class="keywordtype">float</span> tmp = t1;
01985       t1 = t2;
01986       t2 = tmp;
01987     }
01988   <span class="keywordflow">if</span> (t1 &gt; tnear)
01989     tnear = t1;
01990   <span class="keywordflow">if</span> (t2 &lt; tfar)
01991     tfar = t2;
01992   <span class="keywordflow">if</span> (tnear &gt; tfar)
01993     <span class="keywordflow">return</span> 0;
01994   <span class="keywordflow">if</span> (tfar &lt; 0.0)
01995     <span class="keywordflow">return</span> 0;
01996   <span class="comment">// Find intersection with z-aligned planes of box.</span>
01997   <span class="comment">// If the ray is parallel to the box and not within the planes of the box it misses.</span>
01998   <span class="keywordflow">if</span> (ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> == 0.0)
01999     <span class="keywordflow">if</span> ((ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> &lt; box-&gt;m_Min.z) &amp;&amp; (ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> &gt; box-&gt;m_Max.z))
02000       <span class="keywordflow">return</span> 0;
02001   <span class="comment">// Calculate intersection distance with the box's planes.</span>
02002   t1 = (box-&gt;m_Min.z - ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>) / ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02003   t2 = (box-&gt;m_Max.z - ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>) / ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02004   <span class="keywordflow">if</span> (t1 &gt; t2)
02005     {
02006       <span class="keywordtype">float</span> tmp = t1;
02007       t1 = t2;
02008       t2 = tmp;
02009     }
02010   <span class="keywordflow">if</span> (t1 &gt; tnear)
02011     tnear = t1;
02012   <span class="keywordflow">if</span> (t2 &lt; tfar)
02013     tfar = t2;
02014   <span class="keywordflow">if</span> (tnear &gt; tfar)
02015     <span class="keywordflow">return</span> 0;
02016   <span class="keywordflow">if</span> (tfar &lt; 0.0)
02017     <span class="keywordflow">return</span> 0;
02018   <span class="comment">// If we survived all of the tests, the box is hit.</span>
02019   <span class="keywordflow">if</span> (point != NULL)
02020     {
02021       point-&gt;<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + tnear * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02022       point-&gt;<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + tnear * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02023       point-&gt;<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo0">m_Origin</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> + tnear * ray-&gt;<a class="code" href="classdemeter_1_1Ray.html#demeter_1_1Rayo1">m_Direction</a>.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02024       *distance = tnear;
02025     }
02026   <span class="keywordflow">return</span> 1;
02027 }
02028 <span class="preprocessor">#endif</span>
02029 <span class="preprocessor"></span>
<a name="l02030"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a17">02030</a> <span class="keywordtype">void</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a17">LoadImage</a>(<span class="keywordtype">char</span>* szFilename,<span class="keywordtype">int</span>* pWidth,<span class="keywordtype">int</span>* pHeight,Uint8** pBuffer,<span class="keywordtype">bool</span> bColorKey)
02031 {
02032   osg::ref_ptr&lt;osg::Image&gt; pImage = osgDB::Registry::instance()-&gt;readImage(szFilename,<span class="keyword">true</span>).getImage();
02033   <span class="keywordflow">if</span> (pImage != NULL)
02034     {
02035       *pWidth = pImage-&gt;s();
02036       *pHeight = pImage-&gt;t();
02037       <span class="keywordtype">int</span> pitch = 3 * pImage-&gt;s(); <span class="comment">// why3?? !!!</span>
02038 
02039       <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pBufferTemp;
02040       <span class="keywordflow">if</span> (bColorKey)
02041         pBufferTemp = <span class="keyword">new</span> <a class="code" href="namespacedemeter.html#a0">Uint8</a>[*pWidth * *pHeight * 4];
02042       <span class="keywordflow">else</span>
02043         pBufferTemp = <span class="keyword">new</span> <a class="code" href="namespacedemeter.html#a0">Uint8</a>[*pWidth * *pHeight * 3];
02044       <span class="keywordtype">int</span> i,j;
02045       <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImagePixels = (<a class="code" href="namespacedemeter.html#a0">Uint8</a>*)pImage-&gt;data();
02046       <span class="keywordtype">int</span> bytesPerPixel = pImage-&gt;getPixelSizeInBits() / 8;
02047       <span class="keywordflow">for</span> (i = pImage-&gt;t() * pitch - pitch,j = 0; i &gt;= 0; i -= pitch)
02048         {
02049           <a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImageRow = pImagePixels + i;
02050           <span class="keywordflow">for</span> (<a class="code" href="namespacedemeter.html#a0">Uint8</a>* pImagePixel = pImageRow; pImagePixel &lt; pImageRow + pImage-&gt;s() * bytesPerPixel; pImagePixel += bytesPerPixel)
02051             {
02052               <a class="code" href="namespacedemeter.html#a0">Uint8</a> red,green,blue,alpha;
02053               <a class="code" href="namespacedemeter.html#a1">Uint32</a>* pCurrentPixel = (<a class="code" href="namespacedemeter.html#a1">Uint32</a>*)pImagePixel;
02054               <span class="keywordflow">if</span> (bColorKey) {
02055                 red   = (*pCurrentPixel) &amp; 0xff; <span class="comment">// !!!! check this is ok for Intel endian</span>
02056                 green = ((*pCurrentPixel) &amp; 0xff00) &gt;&gt; 8; <span class="comment">// (we should really use dataType intelligently!)</span>
02057                 blue  = ((*pCurrentPixel) &amp; 0xff0000) &gt;&gt; 16;
02058                 alpha = ((*pCurrentPixel) &amp; 0xff000000) &gt;&gt; 24;
02059                 <span class="comment">//              SDL_GetRGBA(*pCurrentPixel,pImage-&gt;format,&amp;red,&amp;green,&amp;blue,&amp;alpha);</span>
02060               }
02061               <span class="keywordflow">else</span> {
02062                 red   = (*pCurrentPixel) &amp; 0xff; <span class="comment">// !!!! check this is ok for Intel endian</span>
02063                 green = ((*pCurrentPixel) &amp; 0xff00) &gt;&gt; 8; <span class="comment">// (we should really use dataType intelligently!)</span>
02064                 blue  = ((*pCurrentPixel) &amp; 0xff0000) &gt;&gt; 16;
02065                 alpha = ((*pCurrentPixel) &amp; 0xff000000) &gt;&gt; 24;
02066                 <span class="comment">//              SDL_GetRGBA(*pCurrentPixel,pImage-&gt;format,&amp;red,&amp;green,&amp;blue,&amp;alpha);</span>
02067               }
02068               pBufferTemp[j++] = red;
02069               pBufferTemp[j++] = green;
02070               pBufferTemp[j++] = blue;
02071               <span class="keywordflow">if</span> (bColorKey)
02072                 {
02073                   pBufferTemp[j++] = alpha;
02074                 }
02075             }
02076         }
02077       *pBuffer = pBufferTemp;
02078       <span class="comment">//      SDL_FreeSurface(pImage);</span>
02079     }
02080   <span class="keywordflow">else</span>
02081     {
02082       *pWidth = 0;
02083       *pHeight = 0;
02084       *pBuffer = NULL;
02085     }
02086 }
02087 
<a name="l02088"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a16">02088</a> GLuint <a class="code" href="CLODTerrainRenderer_8cpp.html#a16">CreateTexture</a>(Uint8* pTexels,<span class="keywordtype">int</span> width,<span class="keywordtype">int</span> height,<span class="keywordtype">int</span> rowLength,<span class="keywordtype">int</span> border,<span class="keywordtype">int</span> internalFormat,<span class="keywordtype">bool</span> bClamp,<span class="keywordtype">bool</span> bColorKey)
02089 {
02090   GLuint texId;
02091   glGenTextures(1,&amp;texId);
02092   glBindTexture(GL_TEXTURE_2D,texId);
02093   <span class="keywordflow">if</span> (bClamp)
02094     {
02095       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
02096       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
02097     }
02098   <span class="keywordflow">else</span>
02099     {
02100       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
02101       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
02102     }
02103   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
02104   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
02105   glPixelStorei(GL_UNPACK_ROW_LENGTH,rowLength);
02106   glPixelStorei(GL_UNPACK_ALIGNMENT,1);
02107   <span class="keywordflow">if</span> (bColorKey)
02108     {
02109       glTexImage2D(GL_TEXTURE_2D,0,internalFormat,width + 2 * border,height + 2 * border,border,GL_RGBA,GL_UNSIGNED_BYTE,pTexels);
02110       gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA,width,height,GL_RGBA,GL_UNSIGNED_BYTE,pTexels);
02111     }
02112   <span class="keywordflow">else</span>
02113     {
02114       glTexImage2D(GL_TEXTURE_2D,0,internalFormat,width + 2 * border,height + 2 * border,border,GL_RGB,GL_UNSIGNED_BYTE,pTexels);
02115       gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGB,width,height,GL_RGB,GL_UNSIGNED_BYTE,pTexels);
02116     }
02117   glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
02118   <span class="keywordflow">return</span> texId;
02119 }
02120 
<a name="l02121"></a><a class="code" href="CLODTerrainRenderer_8cpp.html#a20">02121</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a20">IsPowerOf2</a>(<span class="keywordtype">double</span> number)
02122 {
02123   <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_POWER = 1024;
02124   <span class="keywordtype">bool</span> isPowerOf2 = <span class="keyword">false</span>;
02125   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; MAX_POWER &amp;&amp; !isPowerOf2; i++)
02126     {
02127       <span class="keywordflow">if</span> (pow(2.0,i) == number)
02128         isPowerOf2 = <span class="keyword">true</span>;
02129     }
02130   <span class="keywordflow">return</span> isPowerOf2;
02131 }
02132 
02133 Settings::Settings()
02134 {
02135   m_szMediaPath = NULL;
02136   m_bVerbose = <span class="keyword">false</span>;
02137   m_bIsCompilerOnly = <span class="keyword">false</span>;
02138   m_IsHeadless = <span class="keyword">false</span>;
02139   m_UseDynamicTextures = <span class="keyword">false</span>;
02140 }
02141 
<a name="l02142"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa0">02142</a> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa0">Settings::~Settings</a>()
02143 {
02144   <span class="keywordflow">if</span> (m_szMediaPath != NULL)
02145     <span class="keyword">delete</span>[] m_szMediaPath;
02146 }
02147 
<a name="l02148"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">02148</a> <a class="code" href="classdemeter_1_1Settings.html">Settings</a>* <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()
02149 {
02150   <span class="keywordflow">if</span> (<a class="code" href="CLODTerrainRenderer_8cpp.html#a12">pSettingsInstance</a> == NULL)
02151     <a class="code" href="CLODTerrainRenderer_8cpp.html#a12">pSettingsInstance</a> = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Settings.html">Settings</a>();
02152   <span class="keywordflow">return</span> <a class="code" href="CLODTerrainRenderer_8cpp.html#a12">pSettingsInstance</a>;
02153 }
02154 
<a name="l02155"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa10">02155</a> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa10">Settings::SetProperty</a>(<span class="keywordtype">char</span>* szProperty,<span class="keywordtype">char</span>* szValue)
02156 {
02157   <span class="keywordtype">bool</span> bSuccess = <span class="keyword">false</span>;
02158   
02159   <span class="keywordflow">if</span> (strcmp(szProperty,<span class="stringliteral">"verbose"</span>) == 0)
02160     {
02161       <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa4">SetVerbose</a>(strcmp(szValue,<span class="stringliteral">"true"</span>) == 0);
02162       bSuccess = <span class="keyword">true</span>;
02163     }
02164   
02165   <span class="keywordflow">return</span> bSuccess;
02166 }
02167 
<a name="l02168"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa11">02168</a> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa11">Settings::GetProperty</a>(<span class="keywordtype">char</span>* szProperty,<span class="keywordtype">char</span>* szValue)
02169 {
02170   <span class="keywordtype">bool</span> bSuccess = <span class="keyword">false</span>;
02171   
02172   <span class="keywordflow">if</span> (strcmp(szProperty,<span class="stringliteral">"verbose"</span>) == 0)
02173     {
02174       sprintf(szValue,m_bVerbose ? <span class="stringliteral">"true"</span> : <span class="stringliteral">"false"</span>);
02175       bSuccess = <span class="keyword">true</span>;
02176     }
02177   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(szProperty,<span class="stringliteral">"glinfo"</span>) == 0)
02178     {
02179       sprintf(szValue,<span class="stringliteral">"OpenGL Vendor: %s; OpenGL Extensions Supported: %s"</span>,glGetString(GL_VENDOR),glGetString(GL_EXTENSIONS));
02180       bSuccess = <span class="keyword">true</span>;
02181     }
02182   
02183   <span class="keywordflow">return</span> bSuccess;
02184 }
02185 
<a name="l02186"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa14">02186</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa14">Settings::SetUseDynamicTextures</a>(<span class="keywordtype">bool</span> use)
02187 {
02188   m_UseDynamicTextures = use;
02189 }
02190 
<a name="l02191"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa15">02191</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa15">Settings::UseDynamicTextures</a>()
02192 {
02193   <span class="keywordflow">return</span> m_UseDynamicTextures;
02194 }
02195 
<a name="l02196"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa1">02196</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa1">Settings::SetMediaPath</a>(<span class="keywordtype">char</span>* szPath)
02197 {
02198   <span class="keywordtype">char</span> separator = <span class="charliteral">'/'</span>;
02199 
02200   m_bCompressTextures = <span class="keyword">false</span>;
02201   <span class="keywordflow">if</span> (m_szMediaPath != NULL)
02202     <span class="keyword">delete</span>[] m_szMediaPath;
02203   <span class="keywordflow">if</span> (szPath[strlen(szPath) - 1] == separator)
02204     {
02205       m_szMediaPath = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szPath) + 1];
02206       sprintf(m_szMediaPath,szPath);
02207     }
02208   <span class="keywordflow">else</span>
02209     {
02210       m_szMediaPath = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szPath) + 2];
02211       sprintf(m_szMediaPath,<span class="stringliteral">"%s%c"</span>,szPath,separator);
02212     }
02213 }
02214 
<a name="l02215"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa2">02215</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa2">Settings::GetMediaPath</a>(<span class="keywordtype">char</span>** szPath)
02216 {
02217   <span class="keywordtype">char</span>* szOutput = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(m_szMediaPath) + 1];
02218   sprintf(szOutput,m_szMediaPath);
02219   *szPath = szOutput;
02220 }
02221 
<a name="l02222"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">02222</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">Settings::PrependMediaPath</a>(<span class="keywordtype">char</span>* szFilename,<span class="keywordtype">char</span>** pszFullFilename)
02223 {
02224   <span class="keywordtype">char</span>* szFull = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(szFilename) + strlen(m_szMediaPath) + 2];
02225   sprintf(szFull,<span class="stringliteral">"%s%s"</span>,m_szMediaPath,szFilename);
02226   *pszFullFilename = szFull;
02227 }
02228 
<a name="l02229"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa18">02229</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa18">Settings::SetHeadless</a>(<span class="keywordtype">bool</span> isHeadless)
02230 {
02231   m_IsHeadless = isHeadless;
02232 }
02233 
<a name="l02234"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa19">02234</a> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa19">Settings::IsHeadless</a>()
02235 {
02236   <span class="keywordflow">return</span> m_IsHeadless;
02237 }
02238 
<a name="l02239"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa4">02239</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa4">Settings::SetVerbose</a>(<span class="keywordtype">bool</span> bVerbose)
02240 {
02241   m_bVerbose = bVerbose;
02242 }
02243 
<a name="l02244"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">02244</a> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa5">Settings::IsVerbose</a>()
02245 {
02246   <span class="keywordflow">return</span> m_bVerbose;
02247 }
02248 
<a name="l02249"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa7">02249</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa7">Settings::GetScreenWidth</a>()
02250 {
02251   <span class="keywordflow">return</span> m_ScreenWidth;
02252 }
02253 
<a name="l02254"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa6">02254</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa6">Settings::SetScreenWidth</a>(<span class="keywordtype">int</span> width)
02255 {
02256   m_ScreenWidth = width;
02257 }
02258 
<a name="l02259"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa9">02259</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa9">Settings::GetScreenHeight</a>()
02260 {
02261   <span class="keywordflow">return</span> m_ScreenHeight;
02262 }
02263 
<a name="l02264"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa8">02264</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa8">Settings::SetScreenHeight</a>(<span class="keywordtype">int</span> height)
02265 {
02266   m_ScreenHeight = height;
02267 }
02268 
<a name="l02269"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa12">02269</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa12">Settings::IsCompilerOnly</a>()
02270 {
02271   <span class="keywordflow">return</span> m_bIsCompilerOnly;
02272 }
02273 
<a name="l02274"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa13">02274</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa13">Settings::SetCompilerOnly</a>(<span class="keywordtype">bool</span> bIsCompilerOnly)
02275 {
02276   m_bIsCompilerOnly = bIsCompilerOnly;
02277 }
02278 
<a name="l02279"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa17">02279</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa17">Settings::SetTextureCompression</a>(<span class="keywordtype">bool</span> bCompress)
02280 {
02281   m_bCompressTextures = bCompress;
02282 }
02283 
<a name="l02284"></a><a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa16">02284</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa16">Settings::IsTextureCompression</a>()
02285 {
02286   <span class="keywordflow">return</span> m_bCompressTextures;
02287 }
02288 
<a name="l02289"></a><a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora4">02289</a> Vector&amp; <a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora4">Vector::operator = </a>(<span class="keyword">const</span> Vector&amp; v)
02290 {
02291   x = v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02292   y = v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02293   z = v.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02294   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
02295 }
02296 
<a name="l02297"></a><a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora3">02297</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora3">Vector::Normalize</a>(<span class="keywordtype">float</span> tolerance)
02298 {
02299   <span class="keywordtype">float</span> length = <a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora2">GetLength</a>();
02300   
02301   <span class="keywordflow">if</span> (length &gt; tolerance)
02302     {
02303       <span class="keywordtype">float</span> invLength = 1.0f / length;
02304       x *= invLength;
02305       y *= invLength;
02306       z *= invLength;
02307     }
02308   <span class="keywordflow">else</span>
02309     {
02310       length = 0.0;
02311     }
02312   
02313   <span class="keywordflow">return</span> length;
02314 }
02315 
<a name="l02316"></a><a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora2">02316</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora2">Vector::GetLength</a>()
02317 {
02318   <span class="keywordflow">return</span> sqrt(x*x + y*y + z*z);
02319 }
02320 
<a name="l02321"></a><a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea1">02321</a> <a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea0">Plane::Plane</a>(Vector&amp; p1,Vector&amp; p2,Vector&amp; p3)
02322 {
02323   <a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">defineFromPoints</a>(p1,p2,p3);
02324 }
02325 
<a name="l02326"></a><a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">02326</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planea3">Plane::defineFromPoints</a>(Vector&amp; p1,Vector&amp; p2,Vector&amp; p3)
02327 {
02328   Vector v1,v2,normal;
02329   <span class="comment">// Find the normal of the polygon defined by the three points(cross product of 2 vertex vectors)</span>
02330   v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = p2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> - p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02331   v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = p2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> - p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02332   v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = p2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> - p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02333   
02334   v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = p3.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> - p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02335   v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = p3.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> - p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02336   v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = p3.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> - p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02337   
02338   v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora3">Normalize</a>();
02339   v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora3">Normalize</a>();
02340   <span class="comment">// Find surface normal based on cross product.</span>
02341   normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> * v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> - v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> * v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02342   normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> * v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> - v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> * v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02343   normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> * v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> - v2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> * v1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02344   normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectora3">Normalize</a>();
02345   <span class="comment">// This surface normal represents the a,b,c components of the plane equation.</span>
02346   a = normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02347   b = normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02348   c = normal.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02349   <span class="comment">// The d component is calculated from Ax + By + Cz + D = 0</span>
02350   <a class="code" href="classdemeter_1_1Plane.html#demeter_1_1Planeo3">d</a> = -(a * p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> + b * p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> + c * p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>);
02351 }
02352 
<a name="l02353"></a><a class="code" href="classdemeter_1_1Triangle.html#demeter_1_1Trianglea0">02353</a> Triangle::Triangle()
02354 {
02355 }
02356 
<a name="l02357"></a><a class="code" href="classdemeter_1_1Triangle.html#demeter_1_1Trianglea1">02357</a> Triangle::~Triangle()
02358 {
02359 }
02360 
<a name="l02361"></a><a class="code" href="classdemeter_1_1Triangle.html#demeter_1_1Trianglea2">02361</a> <span class="keywordtype">void</span> Triangle::DefineFromPoints(Vector&amp; p1,Vector&amp; p2,Vector&amp; p3)
02362 {
02363   m_pVertices[0].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02364   m_pVertices[0].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02365   m_pVertices[0].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = p1.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02366   m_pVertices[1].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = p2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02367   m_pVertices[1].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = p2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02368   m_pVertices[1].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = p2.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02369   m_pVertices[2].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a> = p3.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro0">x</a>;
02370   m_pVertices[2].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a> = p3.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro1">y</a>;
02371   m_pVertices[2].<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a> = p3.<a class="code" href="classdemeter_1_1Vector.html#demeter_1_1Vectoro2">z</a>;
02372 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
02373 <span class="preprocessor"></span>  m_Plane.defineFromPoints(p3,p2,p1);
02374 <span class="preprocessor">#endif</span>
02375 <span class="preprocessor"></span>}
02376 
<a name="l02377"></a><a class="code" href="classdemeter_1_1Triangle.html#demeter_1_1Trianglea3">02377</a> <span class="keyword">inline</span> Vector* Triangle::GetVertex(<span class="keywordtype">int</span> index)
02378 {
02379   <span class="keywordflow">return</span> &amp;m_pVertices[index];
02380 }
02381 
02382 <span class="preprocessor">#ifdef _USE_RAYTRACING_SUPPORT_</span>
02383 <span class="preprocessor"></span><a class="code" href="classdemeter_1_1Plane.html">Plane</a>* Triangle::GetPlane()
02384 {
02385   <span class="keywordflow">return</span> &amp;m_Plane;
02386 }
02387 <span class="preprocessor">#endif</span>
02388 <span class="preprocessor"></span>
02389 
<a name="l02390"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea0">02390</a> TerrainLattice::TerrainLattice(<span class="keywordtype">int</span> widthTerrains,<span class="keywordtype">int</span> heightTerrains,<span class="keywordtype">float</span> terrainWidth,<span class="keywordtype">float</span> terrainHeight)
02391 {
02392   m_WidthTerrains = widthTerrains;
02393   m_HeightTerrains = heightTerrains;
02394   m_TerrainWidth = terrainWidth;
02395   m_TerrainHeight = terrainHeight;
02396   m_pTerrains = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>*[widthTerrains * heightTerrains];
02397   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; widthTerrains * heightTerrains; i++)
02398     m_pTerrains[i] = NULL;
02399   m_WidthActiveTerrains = m_HeightActiveTerrains = 1;
02400 }
02401 
<a name="l02402"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea1">02402</a> TerrainLattice::~TerrainLattice()
02403 {
02404   <span class="keyword">delete</span>[] m_pTerrains;
02405 }
02406 
<a name="l02407"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea5">02407</a> <span class="keywordtype">void</span> TerrainLattice::AddTerrain(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain,<span class="keywordtype">int</span> positionX,<span class="keywordtype">int</span> positionY)
02408 {
02409   m_pTerrains[positionY * m_WidthTerrains + positionX] = pTerrain;
02410   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina39">SetLatticePosition</a>(positionX,positionY);
02411 }
02412 
<a name="l02413"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea6">02413</a> <a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* TerrainLattice::GetTerrain(<span class="keywordtype">int</span> positionX,<span class="keywordtype">int</span> positionY)
02414 {
02415   <span class="keywordflow">return</span> m_pTerrains[positionY * m_WidthTerrains + positionX];
02416 }
02417 
02418 <a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* TerrainLattice::GetTerrainRelative(<a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain,Terrain::DIRECTION direction)
02419 {
02420   <span class="keywordtype">int</span> offsetX,offsetY;
02421   <span class="keywordflow">switch</span> (direction)
02422     {
02423     <span class="keywordflow">case</span> Terrain::DIR_NORTH:
02424       offsetX = 0;
02425       offsetY = 1;
02426       <span class="keywordflow">break</span>;
02427     <span class="keywordflow">case</span> Terrain::DIR_NORTHEAST:
02428       offsetX = 1;
02429       offsetY = 1;
02430       <span class="keywordflow">break</span>;
02431     <span class="keywordflow">case</span> Terrain::DIR_EAST:
02432       offsetX = 1;
02433       offsetY = 0;
02434       <span class="keywordflow">break</span>;
02435     <span class="keywordflow">case</span> Terrain::DIR_SOUTHEAST:
02436       offsetX = 1;
02437       offsetY = -1;
02438       <span class="keywordflow">break</span>;
02439     <span class="keywordflow">case</span> Terrain::DIR_SOUTH:
02440       offsetX = 0;
02441       offsetY = -1;
02442       <span class="keywordflow">break</span>;
02443     <span class="keywordflow">case</span> Terrain::DIR_SOUTHWEST:
02444       offsetX = -1;
02445       offsetY = -1;
02446       <span class="keywordflow">break</span>;
02447     <span class="keywordflow">case</span> Terrain::DIR_WEST:
02448       offsetX = -1;
02449       offsetY = 0;
02450       <span class="keywordflow">break</span>;
02451     <span class="keywordflow">case</span> Terrain::DIR_NORTHWEST:
02452       offsetX = -1;
02453       offsetY = 1;
02454       <span class="keywordflow">break</span>;
02455     <span class="keywordflow">default</span>:
02456       offsetX=offsetY=0;
02457     }
02458   <span class="keywordflow">return</span> GetTerrainRelative(pTerrain,offsetX,offsetY);
02459 }
02460 
02461 
02462 Terrain* TerrainLattice::GetTerrainRelative(Terrain* pTerrain,<span class="keywordtype">int</span> positionX,<span class="keywordtype">int</span> positionY)
02463 {
02464   Terrain* pRequestedTerrain = NULL;
02465   <span class="keywordflow">if</span> (-1 &lt;= positionX &amp;&amp; positionX &lt;= 1 &amp;&amp; -1 &lt;= positionY &amp;&amp; positionY &lt;= 1)
02466     {
02467       <span class="keywordtype">int</span> x,y;
02468       pTerrain-&gt;GetLatticePosition(x,y);
02469       x += positionX;
02470       y += positionY;
02471       
02472       Terrain* pTerrainCenter = m_pTerrains[m_CurrentTerrainIndex[Terrain::DIR_CENTER]];
02473       <span class="keywordtype">int</span> centerX,centerY;
02474       pTerrainCenter-&gt;GetLatticePosition(centerX,centerY);
02475       <span class="keywordflow">if</span> (<a class="code" href="namespacebase.html#a62">abs</a>(x - centerX) &lt;= m_WidthActiveTerrains &amp;&amp; <a class="code" href="namespacebase.html#a62">abs</a>(y - centerY) &lt;= m_HeightActiveTerrains)
02476         {               
02477           <span class="keywordflow">if</span> (0 &lt;= x &amp;&amp; x &lt; m_WidthTerrains &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m_HeightTerrains)
02478             pRequestedTerrain = <a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea6">GetTerrain</a>(x,y);
02479         }
02480     }
02481   <span class="keywordflow">return</span> pRequestedTerrain;
02482 }
02483 
<a name="l02484"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea7">02484</a> <a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* TerrainLattice::GetTerrainAtPoint(<span class="keywordtype">float</span> x,<span class="keywordtype">float</span> y)
02485 {
02486   <span class="keywordtype">int</span> indexX = (<span class="keywordtype">int</span>)x / (<span class="keywordtype">int</span>)m_TerrainWidth;
02487   <span class="keywordtype">int</span> indexY = (<span class="keywordtype">int</span>)y / (<span class="keywordtype">int</span>)m_TerrainHeight;
02488   <span class="keywordflow">if</span> (0 &lt;= indexX &amp;&amp; indexX &lt; m_WidthTerrains &amp;&amp; 0 &lt;= indexY &amp;&amp; indexY &lt; m_HeightTerrains)
02489     <span class="keywordflow">return</span> <a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea6">GetTerrain</a>(indexX,indexY);
02490   <span class="keywordflow">else</span>
02491     <span class="keywordflow">return</span> NULL;
02492 }
02493 
<a name="l02494"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea8">02494</a> <span class="keywordtype">void</span> TerrainLattice::SetCameraPosition(<span class="keywordtype">float</span> x,<span class="keywordtype">float</span> y,<span class="keywordtype">float</span> z)
02495 {
02496   <span class="keywordtype">int</span> indexX = (<span class="keywordtype">int</span>)x / (<span class="keywordtype">int</span>)m_TerrainWidth;
02497   <span class="keywordtype">int</span> indexY = (<span class="keywordtype">int</span>)y / (<span class="keywordtype">int</span>)m_TerrainHeight;
02498   m_CurrentTerrainIndex[Terrain::DIR_CENTER] = indexY * m_WidthTerrains + indexX;
02499   m_CurrentTerrainIndex[Terrain::DIR_SOUTH] = 0 &lt; indexY ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] - m_WidthTerrains : -1;
02500   m_CurrentTerrainIndex[Terrain::DIR_SOUTHEAST] = (0 &lt; indexY &amp;&amp; indexX &lt; m_WidthTerrains - 1) ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] - m_WidthTerrains + 1 : -1;
02501   m_CurrentTerrainIndex[Terrain::DIR_SOUTHWEST] = 0 &lt; indexX &amp;&amp; 0 &lt; indexY ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] - m_WidthTerrains - 1 : -1;
02502   m_CurrentTerrainIndex[Terrain::DIR_EAST] = indexX &lt; m_WidthTerrains - 1 ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] + 1 : -1;
02503   m_CurrentTerrainIndex[Terrain::DIR_WEST] = 0 &lt; indexX ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] - 1 : -1;
02504   m_CurrentTerrainIndex[Terrain::DIR_NORTH] = indexY &lt; m_HeightTerrains - 1 ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] + m_WidthTerrains : -1;
02505   m_CurrentTerrainIndex[Terrain::DIR_NORTHEAST] = (indexX &lt; m_WidthTerrains - 1 &amp;&amp; indexY &lt; m_HeightTerrains - 1) ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] + m_WidthTerrains + 1 : -1;
02506   m_CurrentTerrainIndex[Terrain::DIR_NORTHWEST] = (indexY &lt; m_HeightTerrains - 1 &amp;&amp; 0 &lt; indexX) ? m_CurrentTerrainIndex[Terrain::DIR_CENTER] + m_WidthTerrains - 1 : -1;
02507   
02508   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_WidthTerrains * m_HeightTerrains; i++)
02509     {
02510       <span class="keywordtype">bool</span> active = <span class="keyword">false</span>;
02511       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dir = 0; dir &lt; 9 &amp;&amp; !active; dir++)
02512         active = (i == m_CurrentTerrainIndex[dir]);
02513       <span class="keywordflow">if</span> (!active &amp;&amp; m_pTerrains[i] != NULL)
02514         {
02515           vector&lt;TerrainLoadListener*&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> iter = m_TerrainLoadListeners.begin();
02516           <span class="keywordflow">while</span> (iter != m_TerrainLoadListeners.end())
02517             {
02518               <a class="code" href="classdemeter_1_1TerrainLoadListener.html">TerrainLoadListener</a>* pListener = *iter;
02519               pListener-&gt;<a class="code" href="classdemeter_1_1TerrainLoadListener.html#demeter_1_1TerrainLoadListenera1">TerrainUnloading</a>(m_pTerrains[i]);
02520               iter++;
02521             }
02522           <span class="keyword">delete</span> m_pTerrains[i];
02523           m_pTerrains[i] = NULL;
02524         }
02525       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (active &amp;&amp; m_pTerrains[i] == NULL)
02526         {
02527           LoadTerrain(i);
02528           vector&lt;TerrainLoadListener*&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> iter = m_TerrainLoadListeners.begin();
02529           <span class="keywordflow">while</span> (iter != m_TerrainLoadListeners.end())
02530             {
02531               <a class="code" href="classdemeter_1_1TerrainLoadListener.html">TerrainLoadListener</a>* pListener = *iter;
02532               pListener-&gt;<a class="code" href="classdemeter_1_1TerrainLoadListener.html#demeter_1_1TerrainLoadListenera0">TerrainLoaded</a>(m_pTerrains[i]);
02533               iter++;
02534             }
02535         }
02536     }
02537 }
02538 
02539 <span class="keywordtype">void</span> TerrainLattice::LoadTerrain(<span class="keywordtype">int</span> index)
02540 {
02541   <span class="keywordtype">int</span> indexX = index % m_WidthTerrains;
02542   <span class="keywordtype">int</span> indexY = index / m_WidthTerrains;
02543   <span class="keywordtype">char</span> szMapName[1024];
02544   sprintf(szMapName,<span class="stringliteral">"%d-%d-%s"</span>,indexX,indexY,m_BaseName.c_str());
02545   
02546   <a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>* pTerrain = <span class="keyword">new</span> <a class="code" href="classdemeter_1_1Terrain.html">Terrain</a>(szMapName,m_MaxNumTriangles,m_bUseBorders,(<span class="keywordtype">float</span>)indexX * m_TerrainWidth,(<span class="keywordtype">float</span>)indexY * m_TerrainHeight);
02547   <span class="keywordflow">if</span> (m_TerrainWidth == 0.0f)
02548     {
02549       m_TerrainWidth = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina11">GetWidth</a>();
02550       m_TerrainHeight = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina12">GetHeight</a>();
02551     }
02552   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina8">SetMaximumVisibleBlockSize</a>(m_MaxBlockSize);
02553   pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina29">SetCommonTextureRepeats</a>(m_CommonRepeats);
02554   <a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea5">AddTerrain</a>(pTerrain,indexX,indexY);
02555 }
02556 
<a name="l02557"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea9">02557</a> <span class="keywordtype">void</span> TerrainLattice::SetDetailThreshold(<span class="keywordtype">float</span> threshold)
02558 {
02559   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 9; i++)
02560     {
02561       <span class="keywordflow">if</span> (0 &lt;= m_CurrentTerrainIndex[i])
02562         m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina6">SetDetailThreshold</a>(threshold);
02563     }
02564 }
02565 
<a name="l02566"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea12">02566</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> TerrainLattice::GetElevation(<span class="keywordtype">float</span> x,<span class="keywordtype">float</span> y)
02567 {
02568   Terrain* pTerrain = <a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea7">GetTerrainAtPoint</a>(x,y);
02569   <span class="keywordflow">if</span> (pTerrain != NULL)
02570     <span class="keywordflow">return</span> pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina14">GetElevation</a>(x,y);
02571   <span class="keywordflow">else</span>
02572     <span class="keywordflow">return</span> 0.0f;
02573 }
02574 
02575 <span class="keyword">inline</span> Terrain::DIRECTION TerrainLattice::GetOppositeDirection(Terrain::DIRECTION direction)
02576 {
02577   Terrain::DIRECTION oppositeDirection;
02578   <span class="keywordflow">switch</span> (direction)
02579     {
02580     <span class="keywordflow">case</span> Terrain::DIR_NORTH:
02581       oppositeDirection = Terrain::DIR_SOUTH;
02582       <span class="keywordflow">break</span>;
02583     <span class="keywordflow">case</span> Terrain::DIR_NORTHEAST:
02584       oppositeDirection = Terrain::DIR_SOUTHWEST;
02585       <span class="keywordflow">break</span>;
02586     <span class="keywordflow">case</span> Terrain::DIR_EAST:
02587       oppositeDirection = Terrain::DIR_WEST;
02588       <span class="keywordflow">break</span>;
02589     <span class="keywordflow">case</span> Terrain::DIR_SOUTHEAST:
02590       oppositeDirection = Terrain::DIR_NORTHWEST;
02591       <span class="keywordflow">break</span>;
02592     <span class="keywordflow">case</span> Terrain::DIR_SOUTH:
02593       oppositeDirection = Terrain::DIR_NORTH;
02594       <span class="keywordflow">break</span>;
02595     <span class="keywordflow">case</span> Terrain::DIR_SOUTHWEST:
02596       oppositeDirection = Terrain::DIR_NORTHEAST;
02597       <span class="keywordflow">break</span>;
02598     <span class="keywordflow">case</span> Terrain::DIR_WEST:
02599       oppositeDirection = Terrain::DIR_EAST;
02600       <span class="keywordflow">break</span>;
02601     <span class="keywordflow">case</span> Terrain::DIR_NORTHWEST:
02602       oppositeDirection = Terrain::DIR_SOUTHEAST;
02603       <span class="keywordflow">break</span>;
02604     <span class="keywordflow">case</span> Terrain::DIR_CENTER:
02605       oppositeDirection = Terrain::DIR_CENTER;
02606       <span class="keywordflow">break</span>;
02607     <span class="keywordflow">default</span>:
02608       oppositeDirection = Terrain::DIR_CENTER;
02609     }
02610   <span class="keywordflow">return</span> oppositeDirection;
02611 }
02612 
<a name="l02613"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea10">02613</a> <span class="keywordtype">void</span> TerrainLattice::Tessellate()
02614 {
02615   <span class="keywordtype">int</span> i;
02616   <span class="keywordflow">for</span> (i = 0; i &lt; 9; i++)
02617     {
02618       <span class="keywordflow">if</span> (m_CurrentTerrainIndex[i] != -1)
02619         m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina4">Tessellate</a>();
02620     }
02621   
02622   <span class="keywordflow">for</span> (i = 0; i &lt; 9; i++)
02623     {
02624       <span class="keywordflow">if</span> (m_CurrentTerrainIndex[i] != -1)
02625         {
02626           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> direction = 0; direction &lt; 8; direction++)
02627             {
02628               <span class="keywordflow">if</span> (direction != Terrain::DIR_CENTER)
02629                 {
02630                   Terrain* pTerrain = GetTerrainRelative(m_pTerrains[m_CurrentTerrainIndex[i]],(Terrain::DIRECTION)direction);
02631                   <span class="keywordflow">if</span> (pTerrain != NULL)
02632                     {
02633                       m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind1">UpdateNeighbor</a>(pTerrain,(Terrain::DIRECTION)direction);
02634                       pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraind1">UpdateNeighbor</a>(m_pTerrains[m_CurrentTerrainIndex[i]],GetOppositeDirection((Terrain::DIRECTION)direction));
02635                     }
02636                 }
02637             }
02638         }
02639     }
02640   
02641   <span class="keywordflow">for</span> (i = 0; i &lt; 9; i++)
02642     {
02643       <span class="keywordflow">if</span> (m_CurrentTerrainIndex[i] != -1)
02644         m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terrainr6">m_pRootBlock</a>-&gt;<a class="code" href="classdemeter_1_1TerrainBlock.html#demeter_1_1TerrainBlocka8">RepairCracks</a>(m_pTerrains[m_CurrentTerrainIndex[i]],m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;m_pTriangleStrips,m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;m_pTriangleFans,&amp;m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;m_CountStrips,&amp;m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;m_CountFans);
02645     }
02646   
02647 }
02648 
<a name="l02649"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea11">02649</a> <span class="keywordtype">void</span> TerrainLattice::Render()
02650 {
02651   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 9; i++)
02652     {
02653       <span class="keywordflow">if</span> (m_CurrentTerrainIndex[i] != -1)
02654         m_pTerrains[m_CurrentTerrainIndex[i]]-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina5">Render</a>();
02655     }
02656 }
02657 
<a name="l02658"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea2">02658</a> <span class="keywordtype">void</span> TerrainLattice::Load(<span class="keywordtype">char</span>* szBaseName,<span class="keywordtype">int</span> maxNumTriangles,<span class="keywordtype">int</span> maxBlockSize,<span class="keywordtype">float</span> commonRepeats,<span class="keywordtype">bool</span> bUseBorders)
02659 {
02660   <span class="keywordtype">int</span> i,j;
02661   <span class="keywordtype">bool</span> horizontalExists,verticalExists,anyExist;
02662   
02663   i = j = 0;
02664   m_TerrainWidth = m_TerrainHeight = 0.0f;
02665   m_WidthTerrains = m_HeightTerrains = 0;
02666   verticalExists = <span class="keyword">true</span>;
02667   anyExist = <span class="keyword">false</span>;
02668   
02669   m_BaseName = szBaseName;
02670   m_MaxNumTriangles = maxNumTriangles;
02671   m_MaxBlockSize = maxBlockSize;
02672   m_CommonRepeats = commonRepeats;
02673   m_bUseBorders = bUseBorders;
02674   
02675   <span class="keywordflow">while</span>(verticalExists)
02676     {
02677       verticalExists = <span class="keyword">false</span>;
02678       horizontalExists = <span class="keyword">true</span>;
02679       <span class="keywordflow">while</span> (horizontalExists)
02680         {
02681           <span class="keywordtype">char</span> szMapName[1024];
02682           sprintf(szMapName,<span class="stringliteral">"%d-%d-%s"</span>,i,j,szBaseName);
02683           <span class="keywordtype">char</span>* szFullFilename;
02684           <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa3">PrependMediaPath</a>(szMapName,&amp;szFullFilename);
02685           FILE* file = fopen(szFullFilename,<span class="stringliteral">"rb"</span>);
02686           horizontalExists = (file != NULL);
02687           <span class="keywordflow">if</span> (horizontalExists)
02688             {
02689               fclose(file);
02690               verticalExists = <span class="keyword">true</span>;
02691               anyExist = <span class="keyword">true</span>;
02692               <span class="keywordflow">if</span> (i == 0 &amp;&amp; j == 0)
02693                 {
02694                   Terrain* pTerrain = <span class="keyword">new</span> Terrain(szMapName,maxNumTriangles,bUseBorders,(<span class="keywordtype">float</span>)i * m_TerrainWidth,(<span class="keywordtype">float</span>)j * m_TerrainHeight);
02695                   m_TerrainWidth = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina11">GetWidth</a>();
02696                   m_TerrainHeight = pTerrain-&gt;<a class="code" href="classdemeter_1_1Terrain.html#demeter_1_1Terraina12">GetHeight</a>();
02697                   <span class="keyword">delete</span> pTerrain;
02698                 }
02699               i++;
02700               <span class="keywordflow">if</span> (j == 0)
02701                 m_WidthTerrains++;
02702             }
02703           <span class="keywordflow">else</span>
02704             i = 0;
02705         }
02706       <span class="keywordflow">if</span> (verticalExists)
02707         {
02708           m_HeightTerrains++;
02709           j++;
02710         }
02711     }
02712   <span class="keywordflow">if</span> (!anyExist)
02713     {
02714       <span class="keywordtype">char</span>* szMediaPath;
02715       <a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingse0">Settings::GetInstance</a>()-&gt;<a class="code" href="classdemeter_1_1Settings.html#demeter_1_1Settingsa2">GetMediaPath</a>(&amp;szMediaPath);
02716       string msg = <span class="stringliteral">"Compiled map files for "</span>;
02717       msg += szBaseName;
02718       msg += <span class="stringliteral">" could not be found at "</span>;
02719       msg += szMediaPath;
02720       <span class="keyword">delete</span>[] szMediaPath;
02721       <span class="keywordflow">throw</span> <span class="keyword">new</span> std::invalid_argument(<a class="code" href="base.html#a15">Exception</a>(msg));
02722     }
02723 }
02724 
<a name="l02725"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea3">02725</a> <span class="keywordtype">void</span> TerrainLattice::AddTerrainLoadListener(<a class="code" href="classdemeter_1_1TerrainLoadListener.html">TerrainLoadListener</a>&amp; listener)
02726 {
02727   m_TerrainLoadListeners.push_back(&amp;listener);
02728 }
02729 
<a name="l02730"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea4">02730</a> <span class="keywordtype">void</span> TerrainLattice::RemoveTerrainLoadListener(<a class="code" href="classdemeter_1_1TerrainLoadListener.html">TerrainLoadListener</a>&amp; listener)
02731 {
02732   <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
02733   vector&lt;TerrainLoadListener*&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> iter = m_TerrainLoadListeners.begin();
02734   <span class="keywordflow">while</span> (iter != m_TerrainLoadListeners.end() &amp;&amp; !found)
02735     {
02736       <a class="code" href="classdemeter_1_1TerrainLoadListener.html">TerrainLoadListener</a>* pListener = *iter;
02737       <span class="keywordflow">if</span> (pListener == &amp;listener)
02738         {
02739           m_TerrainLoadListeners.erase(iter);
02740           found = <span class="keyword">true</span>;
02741         }
02742       <span class="keywordflow">else</span>
02743         iter++;
02744     }
02745 }
02746 
<a name="l02747"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea13">02747</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> TerrainLattice::GetWidth()
02748 {
02749   <span class="keywordflow">return</span> m_WidthTerrains * m_TerrainWidth;
02750 }
02751 
<a name="l02752"></a><a class="code" href="classdemeter_1_1TerrainLattice.html#demeter_1_1TerrainLatticea14">02752</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> TerrainLattice::GetHeight()
02753 {
02754   <span class="keywordflow">return</span> m_HeightTerrains * m_TerrainHeight;
02755 }
02756 
<a name="l02757"></a><a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea0">02757</a> <a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea0">Texture::Texture</a>(Uint8* pBuffer,<span class="keywordtype">int</span> width,<span class="keywordtype">int</span> height,<span class="keywordtype">int</span> rowLength,<span class="keywordtype">int</span> borderSize,<span class="keywordtype">bool</span> bClamp,<span class="keywordtype">bool</span> useCompression)
02758 {
02759   m_pBuffer = <span class="keyword">new</span> <a class="code" href="namespacedemeter.html#a0">Uint8</a>[height * width * 3];
02760   <span class="keywordtype">int</span> k = 0;
02761   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; height; i++)
02762     {
02763       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; width * 3; j++,k++)
02764         {
02765           m_pBuffer[k] = pBuffer[i * rowLength * 3 + j];
02766         }
02767     }
02768   m_Width = width;
02769   m_Height = height;
02770   m_UseCompression = useCompression;
02771   m_BorderSize = borderSize;
02772   m_TextureID = 0;
02773   m_bClamp = bClamp;
02774 }
02775 
<a name="l02776"></a><a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea1">02776</a> <a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea1">Texture::~Texture</a>()
02777 {
02778   <span class="keywordflow">if</span> (m_TextureID != 0)
02779     {
02780       glDeleteTextures(1,&amp;m_TextureID);
02781       m_TextureID = 0;
02782     }
02783   <span class="keywordflow">if</span> (m_pBuffer != NULL)
02784     {
02785       <span class="keyword">delete</span>[] m_pBuffer;
02786       m_pBuffer = NULL;
02787     }
02788 }
02789 
<a name="l02790"></a><a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea2">02790</a> GLuint <a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea2">Texture::UploadTexture</a>()
02791 {
02792   <span class="keywordflow">if</span> (m_TextureID == 0)
02793     {
02794       <span class="keywordtype">int</span> textureFormat;
02795       textureFormat = m_UseCompression ? <a class="code" href="CLODTerrainRenderer_8cpp.html#a7">COMPRESSED_RGB_S3TC_DXT1_EXT</a> : GL_RGB4;
02796       m_TextureID = <a class="code" href="CLODTerrainRenderer_8cpp.html#a16">CreateTexture</a>(m_pBuffer,m_Width,m_Height,m_Width,0,textureFormat,m_bClamp);
02797     }
02798   <span class="keywordflow">return</span> m_TextureID;
02799 }
02800 
<a name="l02801"></a><a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea3">02801</a> <span class="keywordtype">void</span> <a class="code" href="classdemeter_1_1Texture.html#demeter_1_1Texturea3">Texture::UnloadTexture</a>()
02802 {
02803   <span class="keywordflow">if</span> (m_TextureID != 0)
02804     {
02805       glDeleteTextures(1,&amp;m_TextureID);
02806       m_TextureID = 0;
02807     }
02808 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:18 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
