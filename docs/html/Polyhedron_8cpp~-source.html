<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>opensim/physics/Polyhedron.cpp~ Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>opensim/physics/Polyhedron.cpp~</h1><a href="Polyhedron_8cpp~.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/****************************************************************************</font>
00002 <font class="comment">  Copyright (C)1996 David Jung &lt;djung@pobox.com&gt;</font>
00003 <font class="comment"></font>
00004 <font class="comment">  This program/file is free software; you can redistribute it and/or modify</font>
00005 <font class="comment">  it under the terms of the GNU General Public License as published by</font>
00006 <font class="comment">  the Free Software Foundation; either version 2 of the License, or</font>
00007 <font class="comment">  (at your option) any later version.</font>
00008 <font class="comment">  </font>
00009 <font class="comment">  This program is distributed in the hope that it will be useful,</font>
00010 <font class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00011 <font class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
00012 <font class="comment">  GNU General Public License for more details. (http://www.gnu.org)</font>
00013 <font class="comment">  </font>
00014 <font class="comment">  You should have received a copy of the GNU General Public License</font>
00015 <font class="comment">  along with this program; if not, write to the Free Software</font>
00016 <font class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</font>
00017 <font class="comment">  </font>
00018 <font class="comment">  $Id: Polyhedron.cpp,v 1.1 2002/06/25 15:27:00 jungd Exp $</font>
00019 <font class="comment">  $Revision: 1.1 $</font>
00020 <font class="comment">  $Date: 2002/06/25 15:27:00 $</font>
00021 <font class="comment">  $Author: jungd $</font>
00022 <font class="comment"> </font>
00023 <font class="comment">****************************************************************************/</font>
00024 
00025 <font class="preprocessor">#include &lt;<a class="code" href="Polyhedron.html">physics/Polyhedron</a>&gt;</font>
00026 <font class="preprocessor">#include &lt;<a class="code" href="Material.html">physics/Material</a>&gt;</font>
00027 <font class="comment">//#include &lt;physics/OBBCollisionModel&gt;</font>
00028 <font class="preprocessor">#include &lt;<a class="code" href="GJKCollisionModel.html">physics/GJKCollisionModel</a>&gt;</font>
00029 <font class="preprocessor">#include &lt;<a class="code" href="VisualTriangles.html">gfx/VisualTriangles</a>&gt;</font>
00030 <font class="preprocessor">#include &lt;<a class="code" href="TriangleIterator.html">gfx/TriangleIterator</a>&gt;</font>
00031 <font class="preprocessor">#include &lt;<a class="code" href="Triangle3.html">gfx/Triangle3</a>&gt;</font>
00032 <font class="preprocessor">#include &lt;<a class="code" href="Application.html">base/Application</a>&gt;</font>
00033 <font class="preprocessor">#include &lt;<a class="code" href="File.html">base/File</a>&gt;</font>
00034 <font class="preprocessor">#include &lt;<a class="code" href="VDirectory.html">base/VDirectory</a>&gt;</font>
00035 <font class="preprocessor">#include &lt;<a class="code" href="BinarySerializer.html">base/BinarySerializer</a>&gt;</font>
00036 <font class="preprocessor">#include &lt;<a class="code" href="Cache.html">base/Cache</a>&gt;</font>
00037 <font class="preprocessor">#include &lt;<a class="code" href="Dimension3.html">base/Dimension3</a>&gt;</font>
00038 <font class="preprocessor">#include &lt;<a class="code" href="io__error.html">base/io_error</a>&gt;</font>
00039 
00040 
00041 <font class="preprocessor">#include &lt;osgDB/ReadFile&gt;</font>
00042 <font class="preprocessor">#include &lt;osgDB/WriteFile&gt;</font>
00043 <font class="preprocessor">#include &lt;osg/Group&gt;</font>
00044 <font class="preprocessor">#include &lt;osg/Geode&gt;</font>
00045 <font class="preprocessor">#include &lt;osg/GeoSet&gt;</font>
00046 
00047 <font class="keyword">using</font> <a class="code" href="classphysics_1_1Polyhedron.html">physics::Polyhedron</a>;
00048 <font class="keyword">using</font> <a class="code" href="classphysics_1_1BoundingBox.html">physics::BoundingBox</a>;
00049 <font class="keyword">using</font> <a class="code" href="classphysics_1_1BoundingSphere.html">physics::BoundingSphere</a>;
00050 <font class="keyword">using</font> <a class="code" href="classphysics_1_1MassProperties.html">physics::MassProperties</a>;
00051 <font class="keyword">using</font> <a class="code" href="classphysics_1_1Material.html">physics::Material</a>;
00052 <font class="keyword">using</font> <a class="code" href="classphysics_1_1CollisionModel.html">physics::CollisionModel</a>;
00053 <font class="keyword">using</font> <a class="code" href="classgfx_1_1VisualTriangles.html">gfx::VisualTriangles</a>;
00054 <font class="keyword">using</font> <a class="code" href="classbase_1_1Application.html">base::Application</a>;
00055 <font class="keyword">using</font> <a class="code" href="classbase_1_1File.html">base::File</a>;
00056 <font class="keyword">using</font> <a class="code" href="classbase_1_1VFile.html">base::VFile</a>;
00057 <font class="keyword">using</font> <a class="code" href="classbase_1_1VDirectory.html">base::VDirectory</a>;
00058 <font class="keyword">using</font> <a class="code" href="classbase_1_1Serializer.html">base::Serializer</a>;
00059 <font class="keyword">using</font> <a class="code" href="classbase_1_1BinarySerializer.html">base::BinarySerializer</a>;
00060 <font class="keyword">using</font> <a class="code" href="classbase_1_1Cache.html">base::Cache</a>;
00061 <font class="keyword">using</font> <a class="code" href="classbase_1_1reflist.html">base::reflist</a>;
00062 
00063 <font class="keyword">using</font> osg::Group;
00064 <font class="keyword">using</font> osg::Vec3;
00065 
00066 <font class="comment">//</font>
00067 <font class="comment">// !!! consider building the geometry on demand, rather than</font>
00068 <font class="comment">// always building and copying it around</font>
00069 
00070 Polyhedron::Polyhedron() 
00071   : boundsCached(false), massPropertiesCached(false),
00072     model(0), node(0), collisionModel(0) 
00073 {
00074 }
00075 
00076 Polyhedron::Polyhedron(ref&lt;base::VFile&gt; file) <font class="keywordflow">throw</font>(std::invalid_argument, <a class="code" href="classbase_1_1io__error.html">base::io_error</a>)
00077   : boundsCached(<font class="keyword">false</font>), massPropertiesCached(<font class="keyword">false</font>)<font class="keyword"></font>
00078 <font class="keyword"></font>{
00079   <font class="comment">// First see if the osg model &amp; polyhedron geometry data has</font>
00080   <font class="comment">//  been cached for this file</font>
00081   ref&lt;Cache&gt; cache = Application::getInstance()-&gt;universe()-&gt;cache();
00082   ref&lt;VDirectory&gt; d = cache-&gt;getCache(file-&gt;pathName());
00083   <font class="keywordflow">if</font> (d-&gt;contains(file-&gt;name())) { <font class="comment">// cached</font>
00084 
00085     <font class="comment">// Deserialize from cache file</font>
00086     BinarySerializer in(Serializer::Input, d-&gt;file(file-&gt;name()));
00087     in(*<font class="keyword">this</font>);
00088 
00089   }
00090   <font class="keywordflow">else</font> { <font class="comment">// not cached, build geometry &amp; cache it</font>
00091 
00092     <font class="comment">// Load OSG model</font>
00093     <font class="comment">//  OSG doesn't support reading from a stream, only a real file</font>
00094     <font class="keywordflow">if</font> (<a class="code" href="base.html#a22">instanceof</a>(*file,File)) {
00095       <font class="keywordflow">try</font> {
00096         model = osgDB::readNodeFile( file-&gt;pathName().c_str() );
00097       } <font class="keywordflow">catch</font> (std::exception&amp;) {
00098         model = 0;
00099       }
00100       <font class="keywordflow">if</font> (model==0)
00101         <font class="keywordflow">throw</font> std::runtime_error(<a class="code" href="base.html#a12">Exception</a>(<font class="stringliteral">"Error loading model file "</font>+file-&gt;pathName()));
00102 
00103       <font class="comment">// build geometry from OSG model's Visual</font>
00104       <a class="code" href="base.html#a3">Logln</a>(<font class="stringliteral">"Building Polyhedron data-structure from "</font> &lt;&lt; file-&gt;name());
00105       buildGeometry(VisualTriangles(*<font class="keyword">this</font>));
00106     }
00107     <font class="keywordflow">else</font>
00108       <font class="keywordflow">throw</font> std::invalid_argument(<a class="code" href="base.html#a12">Exception</a>(<font class="stringliteral">"Can only load from standard Unix files.  Sorry"</font>));
00109 
00110     <font class="comment">// Serialize to cache file</font>
00111     ref&lt;VFile&gt; cacheFile = d-&gt;createFile(file-&gt;name());
00112     BinarySerializer out(Serializer::Output, cacheFile);
00113     out(*<font class="keyword">this</font>);
00114     out.flush();
00115     cacheFile-&gt;close();
00116   }
00117 
00118 }
00119 
00120 Polyhedron::Polyhedron(<font class="keyword">const</font> <a class="code" href="classgfx_1_1TriangleContainer.html">gfx::TriangleContainer</a>&amp; tris)
00121   : boundsCached(false), massPropertiesCached(false), node(0)
00122 {
00123   <font class="comment">// Put triangles into a model (OSGVisual only for now)</font>
00124    osg::GeoSet* geoSet = <font class="keyword">new</font> osg::GeoSet();
00125    geoSet-&gt;setPrimType( osg::GeoSet::TRIANGLES );
00126 
00127    array&lt;Vec3&gt;&amp; coords = *<font class="keyword">new</font> array&lt;Vec3&gt;(0,128);
00128    array&lt;Vec3&gt;&amp; normals = *<font class="keyword">new</font> array&lt;Vec3&gt;(0,128);
00129    gfx::TriangleContainer::const_iterator i = tris.begin();
00130    gfx::TriangleContainer::const_iterator end = tris.end();
00131    <font class="keywordflow">while</font> (i != end) {
00132      <font class="keyword">const</font> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>&amp; t(*i);
00133      coords.push_back(t(1).toVec3());
00134      coords.push_back(t(2).toVec3());
00135      coords.push_back(t(3).toVec3());
00136      <a class="code" href="classbase_1_1Vector3.html">base::Vector3</a> n(t.<a class="code" href="classgfx_1_1Triangle3.html#a17">normal</a>());
00137      n.normalize();
00138      normals.push_back(n.toVec3());
00139      ++i;
00140    }
00141    coords.trim();
00142    normals.trim();
00143 
00144    geoSet-&gt;setNumPrims(coords.size()/3);
00145    geoSet-&gt;setCoords(coords.c_array());
00146    geoSet-&gt;setNormals(normals.c_array());
00147    geoSet-&gt;setNormalBinding(osg::GeoSet::BIND_PERPRIM);
00148    array&lt;int&gt;&amp; lengths = *<font class="keyword">new</font> array&lt;int&gt;(geoSet-&gt;getNumPrims());
00149    <font class="keywordflow">for</font> (Int i=0; i&lt;lengths.size(); i++)
00150      lengths[i]=3;
00151    geoSet-&gt;setPrimLengths(lengths.c_array());
00152 
00153    osg::Geode* geode = <font class="keyword">new</font> osg::Geode();
00154    geode-&gt;setName(<font class="stringliteral">"Polyhedron(TriangleContainer)"</font>);
00155    geode-&gt;addDrawable(geoSet);
00156    model = geode;
00157 
00158    <a class="code" href="classphysics_1_1Polyhedron.html#b2">buildGeometry</a>(tris);
00159 }
00160 
00161 Polyhedron::Polyhedron(osg::Node&amp; n)
00162   : boundsCached(false), massPropertiesCached(false)
00163 {
00164   model = &amp;n;
00165   <a class="code" href="classphysics_1_1Polyhedron.html#b2">buildGeometry</a>(VisualTriangles(*<font class="keyword">this</font>));
00166 }
00167 
00168 
00169 Polyhedron::Polyhedron(<font class="keyword">const</font> Polyhedron&amp; p)
00170   : boundsCached(false), massPropertiesCached(false), 
00171     verts(p.verts), edges(p.edges), polys(p.polys),
00172     model(model)
00173 {
00174 }
00175 
00176 
00177 Polyhedron::Polyhedron(<font class="keyword">const</font> Shape&amp; s)
00178   : boundsCached(true), 
00179   boundingBox(s.getBoundingBox()), boundingSphere(s.getBoundingSphere()),
00180   massPropertiesCached(false)
00181 {
00182   <font class="keywordflow">if</font> (s.visualTypeSupported(OSGVisual)) {
00183     model = s.createOSGVisual();
00184     <a class="code" href="classphysics_1_1Polyhedron.html#b2">buildGeometry</a>(VisualTriangles(*<font class="keyword">this</font>));
00185   }
00186   <font class="keywordflow">else</font>
00187     <font class="keywordflow">throw</font> std::invalid_argument(<a class="code" href="base.html#a12">Exception</a>(<font class="stringliteral">"Shape must support OSGVisual"</font>));
00188 }
00189 
00190 
00191 Polyhedron::~Polyhedron()<font class="keyword"></font>
00192 <font class="keyword"></font>{
00193   <font class="comment">// The geometry structures contain circular references, so we must</font>
00194   <font class="comment">//  break the links so that they will be reclaimed properly</font>
00195   VertexList::iterator v = verts.<a class="code" href="classbase_1_1reflist.html#a0">begin</a>();
00196   VertexList::iterator vend = verts.<a class="code" href="classbase_1_1reflist.html#a2">end</a>();
00197   <font class="keywordflow">while</font> (v != vend) {
00198     (*v)-&gt;edges.clear();
00199     ++v;
00200   }  
00201 
00202   EdgeList::iterator ei = edges.<a class="code" href="classbase_1_1reflist.html#a0">begin</a>();
00203   EdgeList::iterator eend = edges.<a class="code" href="classbase_1_1reflist.html#a2">end</a>();
00204   <font class="keywordflow">while</font> (ei != eend) {
00205     (*ei)-&gt;v1 = ref&lt;Vertex&gt;(0);
00206     (*ei)-&gt;v2 = ref&lt;Vertex&gt;(0);
00207     (*ei)-&gt;poly1 = ref&lt;Polygon&gt;(0);
00208     (*ei)-&gt;poly2 = ref&lt;Polygon&gt;(0);
00209     ++ei;
00210   }
00211 
00212   PolygonList::iterator p = polys.<a class="code" href="classbase_1_1reflist.html#a0">begin</a>();
00213   PolygonList::iterator pend = polys.<a class="code" href="classbase_1_1reflist.html#a0">begin</a>();
00214   <font class="keywordflow">while</font> (p != pend) {
00215     (*p)-&gt;edges.clear();
00216     ++p;
00217   }
00218 }
00219 
00220 
00221 <font class="keyword">const</font> MassProperties&amp; Polyhedron::getMassProperties(ref&lt;const Material&gt; material)<font class="keyword"> const</font>
00222 <font class="keyword"></font>{ 
00223   <font class="keywordflow">if</font> (massPropertiesCached &amp;&amp; (density == material-&gt;density()))
00224     <font class="keywordflow">return</font> massProperties;
00225 
00226   density = material-&gt;density();
00227   massProperties = MassProperties(VisualTriangles(*<font class="keyword">this</font>),material);
00228 
00229   massPropertiesCached = <font class="keyword">true</font>;
00230   <font class="keywordflow">return</font> massProperties;
00231 }
00232 
00233 <font class="comment">// CollisionModelProvider</font>
00234 <a class="code" href="classbase_1_1ref.html">base::ref&lt;CollisionModel&gt;</a> Polyhedron::getCollisionModel(CollisionModel::CollisionModelType modelType)<font class="keyword"> const</font>
00235 <font class="keyword"></font>{
00236   <font class="keywordflow">if</font> ((collisionModel!=0) &amp;&amp; 
00237       ((this-&gt;modelType==modelType) || (modelType==CollisionModel::AnyModel)))
00238     <font class="keywordflow">return</font> collisionModel;
00239   
00240   <font class="keywordflow">if</font> (modelType == CollisionModel::GJKModel) {
00241     ref&lt;const Shape&gt; self(<font class="keyword">this</font>);
00242     collisionModel = ref&lt;CollisionModel&gt;( <a class="code" href="MemoryTracer.html#a1">NewNamedObj</a>(<font class="stringliteral">"GJKCollisionModel"</font>) GJKCollisionModel(self));
00243   }
00244   <font class="keywordflow">else</font>
00245     collisionModel = <a class="code" href="classphysics_1_1Shape.html#b0">getCollisionModelFromVisual</a>(modelType);
00246   this-&gt;modelType=modelType;
00247 
00248   <font class="keywordflow">return</font> collisionModel;
00249 }
00250 
00251 
00252 
00253 
00254 
00255 
00256 
00257 
00258 
00259 osg::Node* Polyhedron::createOSGVisual(Attributes visualAttributes)<font class="keyword"> const</font>
00260 <font class="keyword"></font>{
00261   <font class="keywordflow">if</font> ((node!=0) &amp;&amp; (visualAttributes==attributes))
00262     <font class="keywordflow">return</font> &amp;(*node);
00263 
00264   <font class="keywordflow">if</font> (model==0) <font class="keywordflow">return</font> <font class="keyword">new</font> osg::Group(); <font class="comment">// empty</font>
00265 
00266   <font class="keywordflow">if</font> (!(visualAttributes &amp; Visual::ShowAxes)) 
00267     node = model;
00268   <font class="keywordflow">else</font> {
00269     <font class="comment">// create axes </font>
00270     Group* group = <font class="keyword">new</font> Group();
00271     group-&gt;addChild( &amp;(*model) );
00272     group-&gt;addChild( <a class="code" href="classphysics_1_1Shape.html#e0">createOSGAxes</a>(<a class="code" href="classphysics_1_1Polyhedron.html#a15">getBoundingBox</a>().getDimension()/2.0) );
00273     node = group;
00274   }
00275   <font class="keywordflow">return</font> &amp;(*node);
00276 }
00277 
00278 
00279 BoundingBox Polyhedron::getBoundingBox()<font class="keyword"> const</font>
00280 <font class="keyword"></font>{
00281   <font class="keywordflow">if</font> (!boundsCached)
00282     <a class="code" href="classphysics_1_1Polyhedron.html#b4">computeBounds</a>();
00283   <font class="keywordflow">return</font> boundingBox;
00284 }
00285 
00286 BoundingSphere Polyhedron::getBoundingSphere()<font class="keyword"> const</font>
00287 <font class="keyword"></font>{
00288   <font class="keywordflow">if</font> (!boundsCached)
00289     <a class="code" href="classphysics_1_1Polyhedron.html#b4">computeBounds</a>();
00290   <font class="keywordflow">return</font> boundingSphere;
00291 }
00292 
00293 
00294 <font class="keywordtype">void</font> Polyhedron::computeBounds()<font class="keyword"> const</font>
00295 <font class="keyword"></font>{
00296   <font class="comment">// Let OSG calculate the BoundingSphere of the visual</font>
00297   <font class="keyword">const</font> osg::BoundingSphere&amp; bs = <a class="code" href="classphysics_1_1Polyhedron.html#a20">createOSGVisual</a>(gfx::Visual::VerticesOnly)-&gt;getBound();
00298   Real radius = bs.radius();
00299 <a class="code" href="base~.html#a8">Debugln</a>(<font class="stringliteral">"c:"</font> &lt;&lt; bs.center() &lt;&lt; <font class="stringliteral">" r:"</font> &lt;&lt; radius);
00300   boundingSphere = BoundingSphere(bs.center(), radius);
00301   <font class="comment">// Now calculate bounding box to enclose the sphere</font>
00302   boundingBox.setCenter(bs.center());
00303   boundingBox.setDimension(<a class="code" href="classbase_1_1Vector3.html">base::Dimension3</a>(radius,radius,radius)*2.0);
00304 
00305   boundsCached=<font class="keyword">true</font>;
00306 }
00307 
00308 
00309 
00310 <font class="comment">// methods for building the geometric model</font>
00311 
00312 ref&lt;Polyhedron::Vertex&gt; Polyhedron::vertex(<font class="keyword">const</font> Point3&amp; p)<font class="keyword"></font>
00313 <font class="keyword"></font>{
00314   VertexList::iterator v = verts.<a class="code" href="classbase_1_1reflist.html#a0">begin</a>();
00315   VertexList::iterator end = verts.<a class="code" href="classbase_1_1reflist.html#a2">end</a>();
00316   <font class="keywordflow">while</font> (v != end) {
00317     <font class="keywordflow">if</font> ((*v)-&gt;coord.equals(p, coordEps))
00318       <font class="keywordflow">return</font> (*v);
00319     ++v;
00320   }
00321 
00322   ref&lt;Vertex&gt; vert(NewObj Vertex(p));
00323   verts.<a class="code" href="classbase_1_1reflist.html#a22">push_back</a>(vert);
00324   <font class="keywordflow">return</font> vert;
00325 }
00326 
00327 
00328 ref&lt;Polyhedron::Edge&gt; Polyhedron::edge(ref&lt;Vertex&gt; v1, ref&lt;Vertex&gt; v2)<font class="keyword"></font>
00329 <font class="keyword"></font>{
00330   EdgeList::reverse_iterator ei = edges.<a class="code" href="classbase_1_1reflist.html#a4">rbegin</a>();
00331   EdgeList::reverse_iterator end = edges.<a class="code" href="classbase_1_1reflist.html#a6">rend</a>();
00332   <font class="keywordflow">while</font> (ei != end) {
00333     ref&lt;Edge&gt; e(*ei);
00334     <font class="keywordflow">if</font> (   ((e-&gt;v1 == v1) &amp;&amp; (e-&gt;v2 == v2))
00335         || ((e-&gt;v1 == v2) &amp;&amp; (e-&gt;v2 == v1)) )
00336       <font class="keywordflow">return</font> e;
00337     ++ei;
00338   }
00339 
00340   ref&lt;Edge&gt; <a class="code" href="classphysics_1_1Polyhedron.html#b1">edge</a>(NewObj Edge(v1,v2));
00341   v1-&gt;edges.push_back(edge);
00342   v2-&gt;edges.push_back(edge);
00343   edges.<a class="code" href="classbase_1_1reflist.html#a22">push_back</a>(edge);
00344   <font class="keywordflow">return</font> edge;
00345 }
00346 
00347 
00348 
00349 <font class="keywordtype">void</font> Polyhedron::buildGeometry(<font class="keyword">const</font> <a class="code" href="classgfx_1_1TriangleContainer.html">gfx::TriangleContainer</a>&amp; tris)<font class="keyword"></font>
00350 <font class="keyword"></font>{
00351   gfx::TriangleContainer::const_iterator i = tris.<a class="code" href="classgfx_1_1TriangleContainer.html#a0">begin</a>();
00352   gfx::TriangleContainer::const_iterator end = tris.<a class="code" href="classgfx_1_1TriangleContainer.html#a1">end</a>();
00353 
00354   <font class="keywordflow">while</font> (i != end) {
00355     <font class="keyword">const</font> <a class="code" href="classgfx_1_1Triangle3.html">gfx::Triangle3</a>&amp; t(*i);
00356 
00357     ref&lt;Vertex&gt; v1 = <a class="code" href="classphysics_1_1Polyhedron.html#b0">vertex</a>(t[0]);
00358     ref&lt;Vertex&gt; v2 = <a class="code" href="classphysics_1_1Polyhedron.html#b0">vertex</a>(t[1]);
00359     ref&lt;Vertex&gt; v3 = <a class="code" href="classphysics_1_1Polyhedron.html#b0">vertex</a>(t[2]);
00360     
00361     ref&lt;Edge&gt; e1 = <a class="code" href="classphysics_1_1Polyhedron.html#b1">edge</a>(v1, v2);
00362     ref&lt;Edge&gt; e2 = <a class="code" href="classphysics_1_1Polyhedron.html#b1">edge</a>(v2, v3);
00363     ref&lt;Edge&gt; e3 = <a class="code" href="classphysics_1_1Polyhedron.html#b1">edge</a>(v3, v1);
00364     
00365     ref&lt;Polygon&gt; poly(NewObj Polygon());
00366     poly-&gt;addEdge(e1);
00367     poly-&gt;addEdge(e2);
00368     poly-&gt;addEdge(e3);
00369 
00370     e1-&gt;addPoly(poly);
00371     e2-&gt;addPoly(poly);
00372     e3-&gt;addPoly(poly);
00373     
00374     polys.<a class="code" href="classbase_1_1reflist.html#a22">push_back</a>(poly);
00375     
00376     ++i;
00377   }
00378   
00379 }
00380 
00381 
00382 <font class="keywordtype">void</font> Polyhedron::serialize(<a class="code" href="classbase_1_1Serializer.html">base::Serializer</a>&amp; s)<font class="keyword"></font>
00383 <font class="keyword"></font>{
00384   <font class="comment">// first serialize the OSG model</font>
00385   <font class="comment">//  (currently the only way to do that with OSG is to write it to</font>
00386   <font class="comment">//    a file, then copy the file to the serialization stream.</font>
00387   <font class="comment">//    The reverse for input)</font>
00388 
00389   <font class="keywordtype">bool</font> emptyModel = (model == 0);
00390   s(emptyModel);
00391 
00392   <font class="keywordflow">if</font> (!emptyModel) {
00393 
00394     ref&lt;VDirectory&gt; tempDir = Application::getInstance()-&gt;filesystem()-&gt;temp();
00395     <font class="comment">// create a file "polyhedronN.osg" where N is the first Int such that the</font>
00396     <font class="comment">//  name is available</font>
00397     Int pn = 0;
00398     ref&lt;VFile&gt; tempFile;
00399     String name;
00400     <font class="keywordflow">do</font> {
00401       name = String(<font class="stringliteral">"polyhedron"</font>)+<a class="code" href="namespace__base.html#a77">base::intToString</a>(pn)+<font class="stringliteral">".osg"</font>;
00402       <font class="keywordflow">try</font> {
00403         tempFile = tempDir-&gt;createFile( name );
00404       } <font class="keywordflow">catch</font> (<a class="code" href="classbase_1_1io__error.html">base::io_error</a>&amp;) {
00405         tempFile = ref&lt;VFile&gt;(0);
00406         pn++;
00407       }
00408     } <font class="keywordflow">while</font> (tempFile == 0);
00409 
00410     
00411     <font class="keywordflow">if</font> (s.<a class="code" href="classbase_1_1Serializer.html#a4">isOutput</a>()) { <font class="comment">// Output</font>
00412       <font class="comment">// write model to tmpFile</font>
00413       tempFile-&gt;close();
00414       osgDB::writeNodeFile( *model, tempFile-&gt;pathName().c_str() );
00415 
00416       <font class="comment">// copy all the bytes from tmpFile to a memory buffer (we need the size in advance)</font>
00417       array&lt;char&gt; mbuf(0,32768);
00418       std::istream&amp; in = tempFile-&gt;istream();
00419       <font class="keywordflow">while</font> (in.good()) {
00420         mbuf.at(mbuf.size()) = in.get();
00421       }
00422       tempFile-&gt;close();
00423       tempDir-&gt;deleteFile( name );
00424 
00425       <font class="comment">// output size to s</font>
00426       Int osgModelSize = mbuf.size()-1; <font class="comment">// size (bytes)</font>
00427       s(osgModelSize);
00428       <font class="comment">// an the buffer</font>
00429       <font class="keywordflow">for</font>(Int i=0; i&lt;osgModelSize; i++)
00430         s(mbuf[i]);
00431     }
00432     <font class="keywordflow">else</font> { <font class="comment">// Input</font>
00433       <font class="comment">// read osg data from s and write it to tmpFile</font>
00434       Int osgModelSize;
00435       s(osgModelSize); <font class="comment">// read size (bytes)</font>
00436 
00437       std::ostream&amp; out = tempFile-&gt;ostream();
00438       <font class="keywordtype">char</font> c;
00439       <font class="keywordflow">for</font>(Int i=0; i&lt;osgModelSize; i++) {
00440         s(c);
00441         out &lt;&lt; c;
00442       } 
00443       tempFile-&gt;close();
00444       
00445       <font class="comment">// now ask OSG to read tmpFile into a model</font>
00446       model = osgDB::readNodeFile( tempFile-&gt;pathName().c_str() );
00447 
00448       tempDir-&gt;deleteFile( name );
00449     }
00450 
00451   }
00452   <font class="keywordflow">else</font> { <font class="comment">// emptyModel</font>
00453     <font class="keywordflow">if</font> (s.<a class="code" href="classbase_1_1Serializer.html#a5">isInput</a>()) model = 0;
00454   }
00455 
00456   <font class="comment">// finally, now serialize the polyhedron geometry data</font>
00457   <font class="keywordtype">bool</font> follow = s.<a class="code" href="classbase_1_1Serializer.html#a6">followReferences</a>(<font class="keyword">false</font>);
00458   s(verts)(edges)(polys);
00459   s.<a class="code" href="classbase_1_1Serializer.html#a6">followReferences</a>(follow);
00460   
00461 
00462   <font class="comment">// zero out cached data</font>
00463   <font class="keywordflow">if</font> (s.<a class="code" href="classbase_1_1Serializer.html#a5">isInput</a>()) {
00464     boundsCached = massPropertiesCached = 0;
00465     node = 0;
00466     collisionModel = ref&lt;CollisionModel&gt;(0);
00467   }
00468 
00469 }
00470 
00471 
00472 
00473 
00474 <font class="keywordtype">void</font> Polyhedron::getAdjacentVertices(<font class="keyword">const</font> Point3&amp; v, array&lt;Point3&gt;&amp; adjacent)<font class="keyword"> const</font>
00475 <font class="keyword"></font>{
00476   <font class="comment">/*</font>
00477 <font class="comment">  adjacent.clear();</font>
00478 <font class="comment">  Int vi;</font>
00479 <font class="comment">  for(vi=0; vi&lt;verts.size(); vi++) {</font>
00480 <font class="comment">    if (verts[vi].coord.equals(v,coordEps)) </font>
00481 <font class="comment">      break;</font>
00482 <font class="comment">  }</font>
00483 <font class="comment">  if (vi==verts.size()) return;</font>
00484 <font class="comment"></font>
00485 <font class="comment">  // for each edge</font>
00486 <font class="comment">  array&lt;Int&gt;::const_iterator ei = verts[vi].edges.begin();</font>
00487 <font class="comment">  array&lt;Int&gt;::const_iterator end = verts[vi].edges.end();</font>
00488 <font class="comment">  while (ei != end) {</font>
00489 <font class="comment">    const Edge&amp; e(edges[*ei]);</font>
00490 <font class="comment">    if (e.vi1 != vi)</font>
00491 <font class="comment">      adjacent.push_back(verts[e.vi1].coord);</font>
00492 <font class="comment">    else</font>
00493 <font class="comment">      adjacent.push_back(verts[e.vi2].coord);</font>
00494 <font class="comment">    ++ei;</font>
00495 <font class="comment">  }</font>
00496 <font class="comment">  */</font>
00497   
00498 }
00499 
</pre></div><hr><address><small>Generated at Wed Aug 7 10:30:31 2002 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
