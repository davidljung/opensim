<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/array Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/array</h1><a href="array.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* **-*-c++-*-**************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: array 1029 2004-02-11 20:45:54Z jungd $</span>
00019 <span class="comment">  $Revision: 1.7 $</span>
00020 <span class="comment">  $Date: 2004-02-11 15:45:54 -0500 (Wed, 11 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#ifndef _BASE_ARRAY_</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#define _BASE_ARRAY_</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;iterator&gt;</span>
00029 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00030 
00031 
00032 <span class="keyword">namespace </span><a class="code" href="base_2Jamfile_8ft.html#a0">base</a> {
00033 
00034 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00035"></a><a class="code" href="classbase_1_1array.html">00035</a> <span class="keyword">class </span><a class="code" href="classbase_1_1array.html">array</a> 
00036 {
00037 <span class="keyword">public</span>:
<a name="l00038"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw0">00038</a>   <span class="keyword">typedef</span> T value_type;
<a name="l00039"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw1">00039</a>   <span class="keyword">typedef</span> value_type* pointer;
<a name="l00040"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw2">00040</a>   <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;
<a name="l00041"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw3">00041</a>   <span class="keyword">typedef</span> value_type* <a class="code" href="classstd_1_1iterator.html">iterator</a>;
<a name="l00042"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw4">00042</a>   <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;
<a name="l00043"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw5">00043</a>   <span class="keyword">typedef</span> value_type&amp; reference;
<a name="l00044"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw6">00044</a>   <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;
<a name="l00045"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw7">00045</a>   <span class="keyword">typedef</span> <a class="code" href="namespacebase.html#a2">Int</a> size_type;
<a name="l00046"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw8">00046</a>   <span class="keyword">typedef</span> <a class="code" href="namespacebase.html#a1">SInt</a> difference_type;
00047 
<a name="l00048"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw9">00048</a>   <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
<a name="l00049"></a><a class="code" href="classbase_1_1array.html#base_1_1arrayw10">00049</a>   <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt; reverse_iterator;
00050 
<a name="l00051"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya0">00051</a>   <a class="code" href="classbase_1_1array.html#base_1_1arraya0">array</a>() { init(0,1); }
<a name="l00052"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya1">00052</a>   <a class="code" href="classbase_1_1array.html#base_1_1arraya0">array</a>(size_type n) { init(n,n); }
<a name="l00053"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya2">00053</a>   <a class="code" href="classbase_1_1array.html#base_1_1arraya0">array</a>(size_type n, size_type initial_capacity) { init(n,initial_capacity); }
00054 
<a name="l00055"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya3">00055</a>   <a class="code" href="classbase_1_1array.html#base_1_1arraya0">array</a>(size_type n, T a[], <span class="keywordtype">bool</span> by_reference=<span class="keyword">true</span>) {
00056     <span class="keywordflow">if</span> (!by_reference) {
00057       init(n,n);
00058       <span class="keywordflow">for</span>(size_type e=0; e&lt;n; ++e) _a[e] = a[e];
00059     }
00060     <span class="keywordflow">else</span> {
00061       _size = _capacity = n;
00062       _a = a;
00063       _owner = <span class="keyword">false</span>;
00064     }
00065   }
00066   
<a name="l00067"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya4">00067</a>   <a class="code" href="classbase_1_1array.html#base_1_1arraya0">array</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1array.html">array</a>&amp; a) { 
00068     init(a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr1">_size</a>,a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr1">_size</a>);
00069     copy(a);
00070   }
00071   
<a name="l00072"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya5">00072</a>   <a class="code" href="classbase_1_1array.html#base_1_1arraya5">~array</a>() {
00073     <span class="keywordflow">if</span> (_owner) <span class="keyword">delete</span>[] _a;
00074   }
00075   
00076   
<a name="l00077"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya6">00077</a>   <a class="code" href="classbase_1_1array.html">array</a>&amp; <a class="code" href="classbase_1_1array.html#base_1_1arraya6">operator=</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1array.html">array</a>&amp; a)
00078   {
00079     copy(a);
00080     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00081   }
00082 
<a name="l00083"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya7">00083</a>   <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya7">operator==</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1array.html">array</a>&amp; a)<span class="keyword"> const</span>
00084 <span class="keyword">  </span>{
00085     <span class="keywordflow">if</span> (_size != a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr1">_size</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00086     <span class="keywordflow">for</span>(size_type e=0; e&lt;_size; ++e)
00087       <span class="keywordflow">if</span> (!(_a[e] == a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr0">_a</a>[e])) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00088     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00089   }
00090 
<a name="l00091"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya8">00091</a>   <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya8">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classbase_1_1array.html">array</a>&amp; a)<span class="keyword"> const</span>
00092 <span class="keyword">  </span>{
00093     <span class="keywordflow">if</span> (_size != a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr1">_size</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00094     <span class="keywordflow">for</span>(size_type e=0; e&lt;_size; ++e)
00095       <span class="keywordflow">if</span> (_a[e] != a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr0">_a</a>[e]) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00096     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00097   }
00098 
00099 
00100   <span class="comment">// 0-based indexing</span>
<a name="l00101"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya9">00101</a>   reference <a class="code" href="classbase_1_1array.html#base_1_1arraya9">operator[]</a>(difference_type i) {
00102 <span class="preprocessor">#ifdef DEBUG</span>
00103 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((<a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>(i) &gt;= _size) || (i&lt;0)) {
00104       <a class="code" href="base.html#a21">Assertm</a>( <span class="keyword">false</span>, <span class="stringliteral">"array index within bounds (debug only check)"</span>);
00105     }
00106 <span class="preprocessor">#endif</span>
00107 <span class="preprocessor"></span>    <span class="keywordflow">return</span> _a[i];
00108   }
00109   
<a name="l00110"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya10">00110</a>   const_reference <a class="code" href="classbase_1_1array.html#base_1_1arraya9">operator[]</a>(difference_type i)<span class="keyword"> const </span>{
00111 <span class="preprocessor">#ifdef DEBUG</span>
00112 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((<a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>(i) &gt;= _size) || (i&lt;0)) {
00113       <a class="code" href="base.html#a21">Assertm</a>( <span class="keyword">false</span>, <span class="stringliteral">"array index within bounds (debug only check)"</span>);
00114     }
00115 <span class="preprocessor">#endif</span>
00116 <span class="preprocessor"></span>    <span class="keywordflow">return</span> _a[i];
00117   }
00118 
00119   <span class="comment">// 1-based indexing</span>
<a name="l00120"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya11">00120</a>   reference <a class="code" href="classbase_1_1array.html#base_1_1arraya11">operator()</a>(difference_type i) {
00121 <span class="preprocessor">#ifdef DEBUG</span>
00122 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((<a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>(i) &gt; _size) || (i&lt;1)) {
00123       <a class="code" href="base.html#a21">Assertm</a>( <span class="keyword">false</span>, <span class="stringliteral">"array index within bounds (debug only check)"</span>);
00124     }
00125 <span class="preprocessor">#endif</span>
00126 <span class="preprocessor"></span>    <span class="keywordflow">return</span> _a[i-1];
00127   }
<a name="l00128"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya12">00128</a>   const_reference <a class="code" href="classbase_1_1array.html#base_1_1arraya11">operator()</a>(difference_type i)<span class="keyword"> const </span>{
00129 <span class="preprocessor">#ifdef DEBUG</span>
00130 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((<a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>(i) &gt; _size) || (i&lt;1)) {
00131       <a class="code" href="base.html#a21">Assertm</a>( <span class="keyword">false</span>, <span class="stringliteral">"array index within bounds (debug only check)"</span>);
00132     }
00133 <span class="preprocessor">#endif    </span>
00134 <span class="preprocessor"></span>    <span class="keywordflow">return</span> _a[i-1];
00135   }
00136 
00137   <span class="comment">// auto resize to index (0-based)</span>
<a name="l00138"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya13">00138</a>   reference <a class="code" href="classbase_1_1array.html#base_1_1arraya13">at</a>(difference_type i) <span class="keywordflow">throw</span>(std::out_of_range) {
00139     <span class="keywordflow">if</span> (<a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>(i) &gt;= _size) {
00140       <span class="keywordflow">if</span> (_owner) 
00141         <a class="code" href="classbase_1_1array.html#base_1_1arraya33">resize</a>(i+1);
00142       <span class="keywordflow">else</span>
00143         <span class="keywordflow">throw</span> std::out_of_range(<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"array index out of bounds"</span>));
00144     }
00145     <span class="keywordflow">return</span> _a[i];
00146   }
00147   
<a name="l00148"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya14">00148</a>   size_type <a class="code" href="classbase_1_1array.html#base_1_1arraya14">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _size; }
<a name="l00149"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya15">00149</a>   size_type <a class="code" href="classbase_1_1array.html#base_1_1arraya15">capacity</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _capacity; }
00150   
<a name="l00151"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya16">00151</a>   <a class="code" href="classbase_1_1array.html">array</a>&amp; <a class="code" href="classbase_1_1array.html#base_1_1arraya16">clear</a>() 
00152   {
00153     <span class="keywordflow">if</span> (_owner) <span class="keyword">delete</span>[] _a;
00154     init(0,1);
00155     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00156   }
00157   
<a name="l00158"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya17">00158</a>   <span class="keywordtype">bool</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya17">empty</a>() { <span class="keywordflow">return</span> _size == <a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>(0); }
00159 
00160   
00161   <span class="comment">// swap content of this with a</span>
<a name="l00162"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya18">00162</a>   <span class="keywordtype">void</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya18">swap</a>(<a class="code" href="classbase_1_1array.html">array</a>&amp; a) {
00163     T* tmp_a = _a;
00164     size_type tmp_size = _size;
00165     size_type tmp_capacity = _capacity;
00166     <span class="keywordtype">bool</span> tmp_owner = _owner;
00167     
00168     _a = a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr0">_a</a>;
00169     _size = a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr1">_size</a>;
00170     _capacity = a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr2">_capacity</a>;
00171     _owner = a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr3">_owner</a>;
00172 
00173     a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr0">_a</a> = tmp_a;
00174     a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr1">_size</a> = tmp_size;
00175     a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr2">_capacity</a> = tmp_capacity;
00176     a.<a class="code" href="classbase_1_1array.html#base_1_1arrayr3">_owner</a> = tmp_owner;
00177   }
00178 
00179   
00180   <span class="comment">// stack operations</span>
<a name="l00181"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya19">00181</a>   reference <a class="code" href="classbase_1_1array.html#base_1_1arraya19">front</a>() <span class="keywordflow">throw</span>(std::out_of_range) {
00182     <span class="keywordflow">if</span> (_size&gt;0)
00183       <span class="keywordflow">return</span> _a[0];
00184     <span class="keywordflow">else</span>
00185       <span class="keywordflow">throw</span> std::out_of_range((<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"array has no elements (no front)"</span>)));
00186   }
00187   
<a name="l00188"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya20">00188</a>   const_reference <a class="code" href="classbase_1_1array.html#base_1_1arraya19">front</a>() <span class="keyword">const</span> <span class="keywordflow">throw</span>(std::out_of_range) {
00189     <span class="keywordflow">if</span> (_size&gt;0)
00190       <span class="keywordflow">return</span> _a[0];
00191     <span class="keywordflow">else</span>
00192       <span class="keywordflow">throw</span> std::out_of_range((<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"array has no elements (no front)"</span>)));
00193   }
00194   
<a name="l00195"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya21">00195</a>   reference <a class="code" href="classbase_1_1array.html#base_1_1arraya21">back</a>() <span class="keywordflow">throw</span>(std::out_of_range) {
00196     <span class="keywordflow">if</span> (_size&gt;0)
00197       <span class="keywordflow">return</span> _a[_size-1];
00198     <span class="keywordflow">else</span>
00199       <span class="keywordflow">throw</span> std::out_of_range((<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"array has no elements (no back)"</span>)));
00200   }
00201 
<a name="l00202"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya22">00202</a>   const_reference <a class="code" href="classbase_1_1array.html#base_1_1arraya21">back</a>() <span class="keyword">const</span> <span class="keywordflow">throw</span>(std::out_of_range) {
00203     <span class="keywordflow">if</span> (_size&gt;0)
00204       <span class="keywordflow">return</span> _a[_size-1];
00205     <span class="keywordflow">else</span>
00206       <span class="keywordflow">throw</span> std::out_of_range((<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"array has no elements (no back)"</span>)));
00207   }
00208 
<a name="l00209"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya23">00209</a>   <span class="keywordtype">void</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya23">push_back</a>(<span class="keyword">const</span> T&amp; e) {
00210     <a class="code" href="classbase_1_1array.html#base_1_1arraya33">resize</a>(_size+1);
00211     _a[_size-1] = e;
00212   }
00213   
<a name="l00214"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya24">00214</a>   <span class="keywordtype">void</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya24">pop_back</a>() <span class="keywordflow">throw</span>(std::out_of_range) {
00215     <span class="keywordflow">if</span> (_size&gt;0)
00216       <a class="code" href="classbase_1_1array.html#base_1_1arraya33">resize</a>(_size-1);
00217     <span class="keywordflow">else</span>
00218       <span class="keywordflow">throw</span> std::out_of_range((<a class="code" href="base.html#a15">Exception</a>(<span class="stringliteral">"array has no elements (nothing to pop)"</span>)));
00219   }
00220 
00221 
<a name="l00222"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya25">00222</a>   <a class="code" href="classstd_1_1iterator.html">iterator</a> <a class="code" href="classbase_1_1array.html#base_1_1arraya25">begin</a>() { <span class="keywordflow">return</span> _a; }
<a name="l00223"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya26">00223</a>   const_iterator <a class="code" href="classbase_1_1array.html#base_1_1arraya25">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _a; }
00224   
<a name="l00225"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya27">00225</a>   <a class="code" href="classstd_1_1iterator.html">iterator</a> <a class="code" href="classbase_1_1array.html#base_1_1arraya27">end</a>() { <span class="keywordflow">return</span> _a + _size; }
<a name="l00226"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya28">00226</a>   const_iterator <a class="code" href="classbase_1_1array.html#base_1_1arraya27">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _a + _size; }
00227 
<a name="l00228"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya29">00228</a>   pointer <a class="code" href="classbase_1_1array.html#base_1_1arraya29">c_array</a>() { <span class="keywordflow">return</span> _a; }
<a name="l00229"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya30">00229</a>   const_pointer <a class="code" href="classbase_1_1array.html#base_1_1arraya29">c_array</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _a; }
00230   
00231   <span class="comment">//  operator T*() { return _a; }</span>
00232 
00233 
<a name="l00234"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya31">00234</a>   <span class="keywordtype">void</span> <a class="code" href="classbase_1_1array.html#base_1_1arraya31">extend</a>(size_type new_min_capacity)
00235   {
00236     size_type newcapacity = _capacity;
00237     <span class="keywordflow">while</span> (newcapacity &lt; new_min_capacity)
00238       newcapacity = <a class="code" href="classbase_1_1array.html#base_1_1arrayw7">size_type</a>((<a class="code" href="namespacebase.html#a5">Real</a>(newcapacity) * 1.5) +1);
00239     
00240     <span class="keywordflow">if</span> (newcapacity &gt; _capacity) {
00241       T *_olda = _a;
00242       _a = <span class="keyword">new</span> T[newcapacity];
00243       <span class="keywordflow">for</span>(size_type e=0; e&lt;_size; ++e)
00244         _a[e] = _olda[e];
00245       
00246       <span class="keywordflow">if</span> (_owner) <span class="keyword">delete</span>[] _olda;
00247       _capacity = newcapacity;
00248       _owner=<span class="keyword">true</span>;
00249     }
00250   }
00251 
00252 
<a name="l00253"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya32">00253</a>   <a class="code" href="classbase_1_1array.html">array</a>&amp; <a class="code" href="classbase_1_1array.html#base_1_1arraya32">trim</a>()
00254   {
00255     <span class="keywordflow">if</span> (!_owner) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00256     size_type newcapacity = _size;
00257     <span class="keywordflow">if</span> (newcapacity==0) newcapacity=1;
00258     T *_olda = _a;
00259     _a = <span class="keyword">new</span> T[newcapacity];
00260     <span class="keywordflow">for</span>(size_type e=0; e&lt;_size; ++e)
00261       _a[e] = _olda[e];
00262     <span class="keyword">delete</span>[] _olda;
00263     _capacity = newcapacity;
00264     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00265   }
00266 
00267   
<a name="l00268"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya33">00268</a>   <a class="code" href="classbase_1_1array.html">array</a>&amp; <a class="code" href="classbase_1_1array.html#base_1_1arraya33">resize</a>(size_type newsize)
00269   {
00270     <span class="keywordflow">if</span> (newsize &gt; _capacity) <a class="code" href="classbase_1_1array.html#base_1_1arraya31">extend</a>(newsize);
00271     _size = newsize;
00272     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00273   }
00274 
00275 
<a name="l00276"></a><a class="code" href="classbase_1_1array.html#base_1_1arraya34">00276</a>   <a class="code" href="classbase_1_1array.html">array</a>&amp; <a class="code" href="classbase_1_1array.html#base_1_1arraya34">destructive_resize</a>(size_type newsize)
00277   {
00278     <span class="keywordflow">if</span> (_owner) <span class="keyword">delete</span>[] _a;
00279     _size = _capacity = newsize;
00280     _a = <span class="keyword">new</span> T[_capacity];
00281     _owner = <span class="keyword">true</span>;
00282     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00283   }
00284 
00285   
00286 <span class="keyword">private</span>:
00287   T *_a;
00288   size_type _size;
00289   size_type _capacity;
00290   <span class="keywordtype">bool</span>      _owner;  <span class="comment">// true if we alloc'd _a, false is it was provided</span>
00291 
00292   <span class="keywordtype">void</span> init(size_type size, size_type cap) {
00293     <span class="keywordflow">if</span> (cap&lt;size) cap = size;
00294     <span class="keywordflow">if</span> (cap&lt;=0) cap=1;
00295     _size=size; _capacity=cap;
00296     _a = <span class="keyword">new</span> T[_capacity];
00297     _owner = <span class="keyword">true</span>;
00298   }
00299   
00300   <span class="keywordtype">void</span> copy(<span class="keyword">const</span> array&amp; a)
00301   {
00302     <span class="keywordflow">if</span> (_owner)
00303       <a class="code" href="classbase_1_1array.html#base_1_1arraya33">resize</a>(a._size);
00304     size_type minsize = (_size&lt;a._size)?_size:a._size;
00305     <span class="keywordflow">for</span>(size_type e=0; e&lt;minsize; ++e)
00306       _a[e] = a._a[e];
00307   }
00308 
00309 };
00310 
00311 } <span class="comment">// base</span>
00312 
00313 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:03 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
