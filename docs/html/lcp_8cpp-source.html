<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/lcp.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/lcp.cpp</h1><a href="lcp_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*************************************************************************</span>
00002 <span class="comment"> *                                                                       *</span>
00003 <span class="comment"> * Open Dynamics Engine, Copyright (C) 2001 Russell L. Smith.            *</span>
00004 <span class="comment"> *   Email: russ@q12.org   Web: www.q12.org                              *</span>
00005 <span class="comment"> *                                                                       *</span>
00006 <span class="comment"> * This library is free software; you can redistribute it and/or         *</span>
00007 <span class="comment"> * modify it under the terms of the GNU Lesser General Public            *</span>
00008 <span class="comment"> * License as published by the Free Software Foundation; either          *</span>
00009 <span class="comment"> * version 2.1 of the License, or (at your option) any later version.    *</span>
00010 <span class="comment"> *                                                                       *</span>
00011 <span class="comment"> * This library is distributed in the hope that it will be useful,       *</span>
00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of        *</span>
00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *</span>
00014 <span class="comment"> * Lesser General Public License for more details.                       *</span>
00015 <span class="comment"> *                                                                       *</span>
00016 <span class="comment"> * You should have received a copy of the GNU Lesser General Public      *</span>
00017 <span class="comment"> * License along with this library (see the file LICENSE.TXT); if not,   *</span>
00018 <span class="comment"> * write to the Free Software Foundation, Inc., 59 Temple Place,         *</span>
00019 <span class="comment"> * Suite 330, Boston, MA 02111-1307 USA.                                 *</span>
00020 <span class="comment"> *                                                                       *</span>
00021 <span class="comment"> *************************************************************************/</span>
00022 
00023 <span class="comment">/*</span>
00024 <span class="comment"></span>
00025 <span class="comment"></span>
00026 <span class="comment">THE ALGORITHM</span>
00027 <span class="comment">-------------</span>
00028 <span class="comment"></span>
00029 <span class="comment">solve A*x = b+w, with x and w subject to certain LCP conditions.</span>
00030 <span class="comment">each x(i),w(i) must lie on one of the three line segments in the following</span>
00031 <span class="comment">diagram. each line segment corresponds to one index set :</span>
00032 <span class="comment"></span>
00033 <span class="comment">     w(i)</span>
00034 <span class="comment">     /|\      |           :</span>
00035 <span class="comment">      |       |           :</span>
00036 <span class="comment">      |       |i in N     :</span>
00037 <span class="comment">  w&gt;0 |       |state[i]=0 :</span>
00038 <span class="comment">      |       |           :</span>
00039 <span class="comment">      |       |           :  i in C</span>
00040 <span class="comment">  w=0 +       +-----------------------+</span>
00041 <span class="comment">      |                   :           |</span>
00042 <span class="comment">      |                   :           |</span>
00043 <span class="comment">  w&lt;0 |                   :           |i in N</span>
00044 <span class="comment">      |                   :           |state[i]=1</span>
00045 <span class="comment">      |                   :           |</span>
00046 <span class="comment">      |                   :           |</span>
00047 <span class="comment">      +-------|-----------|-----------|----------&gt; x(i)</span>
00048 <span class="comment">             lo           0           hi</span>
00049 <span class="comment"></span>
00050 <span class="comment">the Dantzig algorithm proceeds as follows:</span>
00051 <span class="comment">  for i=1:n</span>
00052 <span class="comment">    * if (x(i),w(i)) is not on the line, push x(i) and w(i) positive or</span>
00053 <span class="comment">      negative towards the line. as this is done, the other (x(j),w(j))</span>
00054 <span class="comment">      for j&lt;i are constrained to be on the line. if any (x,w) reaches the</span>
00055 <span class="comment">      end of a line segment then it is switched between index sets.</span>
00056 <span class="comment">    * i is added to the appropriate index set depending on what line segment</span>
00057 <span class="comment">      it hits.</span>
00058 <span class="comment"></span>
00059 <span class="comment">we restrict lo(i) &lt;= 0 and hi(i) &gt;= 0. this makes the algorithm a bit</span>
00060 <span class="comment">simpler, because the starting point for x(i),w(i) is always on the dotted</span>
00061 <span class="comment">line x=0 and x will only ever increase in one direction, so it can only hit</span>
00062 <span class="comment">two out of the three line segments.</span>
00063 <span class="comment"></span>
00064 <span class="comment"></span>
00065 <span class="comment">NOTES</span>
00066 <span class="comment">-----</span>
00067 <span class="comment"></span>
00068 <span class="comment">this is an implementation of "lcp_dantzig2_ldlt.m" and "lcp_dantzig_lohi.m".</span>
00069 <span class="comment">the implementation is split into an LCP problem object (dLCP) and an LCP</span>
00070 <span class="comment">driver function. most optimization occurs in the dLCP object.</span>
00071 <span class="comment"></span>
00072 <span class="comment">a naive implementation of the algorithm requires either a lot of data motion</span>
00073 <span class="comment">or a lot of permutation-array lookup, because we are constantly re-ordering</span>
00074 <span class="comment">rows and columns. to avoid this and make a more optimized algorithm, a</span>
00075 <span class="comment">non-trivial data structure is used to represent the matrix A (this is</span>
00076 <span class="comment">implemented in the fast version of the dLCP object).</span>
00077 <span class="comment"></span>
00078 <span class="comment">during execution of this algorithm, some indexes in A are clamped (set C),</span>
00079 <span class="comment">some are non-clamped (set N), and some are "don't care" (where x=0).</span>
00080 <span class="comment">A,x,b,w (and other problem vectors) are permuted such that the clamped</span>
00081 <span class="comment">indexes are first, the unclamped indexes are next, and the don't-care</span>
00082 <span class="comment">indexes are last. this permutation is recorded in the array `p'.</span>
00083 <span class="comment">initially p = 0..n-1, and as the rows and columns of A,x,b,w are swapped,</span>
00084 <span class="comment">the corresponding elements of p are swapped.</span>
00085 <span class="comment"></span>
00086 <span class="comment">because the C and N elements are grouped together in the rows of A, we can do</span>
00087 <span class="comment">lots of work with a fast dot product function. if A,x,etc were not permuted</span>
00088 <span class="comment">and we only had a permutation array, then those dot products would be much</span>
00089 <span class="comment">slower as we would have a permutation array lookup in some inner loops.</span>
00090 <span class="comment"></span>
00091 <span class="comment">A is accessed through an array of row pointers, so that element (i,j) of the</span>
00092 <span class="comment">permuted matrix is A[i][j]. this makes row swapping fast. for column swapping</span>
00093 <span class="comment">we still have to actually move the data.</span>
00094 <span class="comment"></span>
00095 <span class="comment">during execution of this algorithm we maintain an L*D*L' factorization of</span>
00096 <span class="comment">the clamped submatrix of A (call it `AC') which is the top left nC*nC</span>
00097 <span class="comment">submatrix of A. there are two ways we could arrange the rows/columns in AC.</span>
00098 <span class="comment"></span>
00099 <span class="comment">(1) AC is always permuted such that L*D*L' = AC. this causes a problem</span>
00100 <span class="comment">    when a row/column is removed from C, because then all the rows/columns of A</span>
00101 <span class="comment">    between the deleted index and the end of C need to be rotated downward.</span>
00102 <span class="comment">    this results in a lot of data motion and slows things down.</span>
00103 <span class="comment">(2) L*D*L' is actually a factorization of a *permutation* of AC (which is</span>
00104 <span class="comment">    itself a permutation of the underlying A). this is what we do - the</span>
00105 <span class="comment">    permutation is recorded in the vector C. call this permutation A[C,C].</span>
00106 <span class="comment">    when a row/column is removed from C, all we have to do is swap two</span>
00107 <span class="comment">    rows/columns and manipulate C.</span>
00108 <span class="comment"></span>
00109 <span class="comment">*/</span>
00110 
00111 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00112 <span class="preprocessor">#include &lt;string.h&gt;</span>
00113 <span class="preprocessor">#include &lt;malloc.h&gt;</span>             <span class="comment">// for alloca under windows</span>
00114 <span class="preprocessor">#include &lt;math.h&gt;</span>
00115 <span class="preprocessor">#include "ode/common.h"</span>
00116 <span class="preprocessor">#include "lcp.h"</span>
00117 <span class="preprocessor">#include "ode/matrix.h"</span>
00118 <span class="preprocessor">#include "ode/misc.h"</span>
00119 <span class="preprocessor">#include "mat.h"</span>                <span class="comment">// for testing</span>
00120 <span class="preprocessor">#include "ode/timer.h"</span>          <span class="comment">// for testing</span>
00121 
00122 <span class="comment">//***************************************************************************</span>
00123 <span class="comment">// code generation parameters</span>
00124 
00125 <span class="comment">// LCP debugging (mosty for fast dLCP) - this slows things down a lot</span>
00126 <span class="comment">//#define DEBUG_LCP</span>
00127 
00128 <span class="comment">//#define dLCP_SLOW             // use slow dLCP object</span>
<a name="l00129"></a><a class="code" href="lcp_8cpp.html#a0">00129</a> <span class="preprocessor">#define dLCP_FAST               // use fast dLCP object</span>
00130 <span class="preprocessor"></span>
00131 <span class="comment">// option 1 : matrix row pointers (less data copying)</span>
<a name="l00132"></a><a class="code" href="lcp_8cpp.html#a1">00132</a> <span class="preprocessor">#define ROWPTRS</span>
<a name="l00133"></a><a class="code" href="lcp_8cpp.html#a2">00133</a> <span class="preprocessor"></span><span class="preprocessor">#define ATYPE dReal **</span>
<a name="l00134"></a><a class="code" href="lcp_8cpp.html#a3">00134</a> <span class="preprocessor"></span><span class="preprocessor">#define AROW(i) (A[i])</span>
00135 <span class="preprocessor"></span>
00136 <span class="comment">// option 2 : no matrix row pointers (slightly faster inner loops)</span>
00137 <span class="comment">//#define NOROWPTRS</span>
00138 <span class="comment">//#define ATYPE dReal *</span>
00139 <span class="comment">//#define AROW(i) (A+(i)*nskip)</span>
00140 
00141 <span class="comment">// misc defines</span>
<a name="l00142"></a><a class="code" href="lcp_8cpp.html#a4">00142</a> <span class="preprocessor">#define ALLOCA dALLOCA16</span>
00143 <span class="preprocessor"></span><span class="comment">//#define dDot myDot</span>
<a name="l00144"></a><a class="code" href="lcp_8cpp.html#a5">00144</a> <span class="preprocessor">#define NUB_OPTIMIZATIONS</span>
00145 <span class="preprocessor"></span>
00146 <span class="comment">//***************************************************************************</span>
00147 
00148 <span class="comment">// an alternative inline dot product, for speed comparisons</span>
00149 
00150 <span class="keyword">static</span> <span class="keyword">inline</span> dReal myDot (dReal *a, dReal *b, <span class="keywordtype">int</span> n)
00151 {
00152   dReal sum=0;
00153   <span class="keywordflow">while</span> (<a class="code" href="matrix_8c.html#a12">n</a> &gt; 0) {
00154     sum += (*a) * (*b);
00155     <a class="code" href="matrix_8c.html#a8">a</a>++;
00156     <a class="code" href="matrix_8c.html#a10">b</a>++;
00157     <a class="code" href="matrix_8c.html#a12">n</a>--;
00158   }
00159   <span class="keywordflow">return</span> sum;
00160 }
00161 
00162 
00163 <span class="comment">// swap row/column i1 with i2 in the n*n matrix A. the leading dimension of</span>
00164 <span class="comment">// A is nskip. this only references and swaps the lower triangle.</span>
00165 <span class="comment">// if `do_fast_row_swaps' is nonzero and row pointers are being used, then</span>
00166 <span class="comment">// rows will be swapped by exchanging row pointers. otherwise the data will</span>
00167 <span class="comment">// be copied.</span>
00168 
00169 <span class="keyword">static</span> <span class="keywordtype">void</span> swapRowsAndCols (ATYPE A, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2, <span class="keywordtype">int</span> nskip,
00170                              <span class="keywordtype">int</span> do_fast_row_swaps)
00171 {
00172   <span class="keywordtype">int</span> i;
00173   dIASSERT (A &amp;&amp; n &gt; 0 &amp;&amp; i1 &gt;= 0 &amp;&amp; i2 &gt;= 0 &amp;&amp; i1 &lt; n &amp;&amp; i2 &lt; n &amp;&amp;
00174             nskip &gt;= n &amp;&amp; i1 &lt; i2);
00175 
00176 <span class="preprocessor"># ifdef ROWPTRS</span>
00177 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=<a class="code" href="analytical_8c.html#a14">i1</a>+1; i&lt;i2; i++) A[<a class="code" href="analytical_8c.html#a14">i1</a>][i] = A[i][<a class="code" href="analytical_8c.html#a14">i1</a>];
00178   <span class="keywordflow">for</span> (i=<a class="code" href="analytical_8c.html#a14">i1</a>+1; i&lt;i2; i++) A[i][<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i2][i];
00179   A[<a class="code" href="analytical_8c.html#a14">i1</a>][i2] = A[<a class="code" href="analytical_8c.html#a14">i1</a>][<a class="code" href="analytical_8c.html#a14">i1</a>];
00180   A[<a class="code" href="analytical_8c.html#a14">i1</a>][<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i2][<a class="code" href="analytical_8c.html#a14">i1</a>];
00181   A[i2][<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i2][i2];
00182   <span class="comment">// swap rows, by swapping row pointers</span>
00183   <span class="keywordflow">if</span> (do_fast_row_swaps) {
00184     dReal *tmpp;
00185     tmpp = A[<a class="code" href="analytical_8c.html#a14">i1</a>];
00186     A[<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i2];
00187     A[i2] = tmpp;
00188   }
00189   <span class="keywordflow">else</span> {
00190     dReal *tmprow = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (n * <span class="keyword">sizeof</span>(dReal));
00191     memcpy (tmprow,A[i1],n * <span class="keyword">sizeof</span>(dReal));
00192     memcpy (A[i1],A[i2],n * <span class="keyword">sizeof</span>(dReal));
00193     memcpy (A[i2],tmprow,n * <span class="keyword">sizeof</span>(dReal));
00194   }
00195   <span class="comment">// swap columns the hard way</span>
00196   <span class="keywordflow">for</span> (i=i2+1; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
00197     dReal tmp = A[i][<a class="code" href="analytical_8c.html#a14">i1</a>];
00198     A[i][<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i][i2];
00199     A[i][i2] = tmp;
00200   }
00201 <span class="preprocessor"># else</span>
00202 <span class="preprocessor"></span>  dReal tmp,*tmprow = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (n * <span class="keyword">sizeof</span>(dReal));
00203   <span class="keywordflow">if</span> (<a class="code" href="analytical_8c.html#a14">i1</a> &gt; 0) {
00204     memcpy (tmprow,A+i1*nskip,i1*<span class="keyword">sizeof</span>(dReal));
00205     memcpy (A+i1*nskip,A+i2*nskip,i1*<span class="keyword">sizeof</span>(dReal));
00206     memcpy (A+i2*nskip,tmprow,i1*<span class="keyword">sizeof</span>(dReal));
00207   }
00208   <span class="keywordflow">for</span> (i=<a class="code" href="analytical_8c.html#a14">i1</a>+1; i&lt;i2; i++) {
00209     tmp = A[i2*nskip+i];
00210     A[i2*nskip+i] = A[i*nskip+<a class="code" href="analytical_8c.html#a14">i1</a>];
00211     A[i*nskip+<a class="code" href="analytical_8c.html#a14">i1</a>] = tmp;
00212   }
00213   tmp = A[<a class="code" href="analytical_8c.html#a14">i1</a>*nskip+<a class="code" href="analytical_8c.html#a14">i1</a>];
00214   A[<a class="code" href="analytical_8c.html#a14">i1</a>*nskip+<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i2*nskip+i2];
00215   A[i2*nskip+i2] = tmp;
00216   <span class="keywordflow">for</span> (i=i2+1; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
00217     tmp = A[i*nskip+<a class="code" href="analytical_8c.html#a14">i1</a>];
00218     A[i*nskip+<a class="code" href="analytical_8c.html#a14">i1</a>] = A[i*nskip+i2];
00219     A[i*nskip+i2] = tmp;
00220   }
00221 <span class="preprocessor"># endif</span>
00222 <span class="preprocessor"></span>}
00223 
00224 
00225 <span class="comment">// swap two indexes in the n*n LCP problem. i1 must be &lt;= i2.</span>
00226 
00227 <span class="keyword">static</span> <span class="keywordtype">void</span> swapProblem (ATYPE A, dReal *x, dReal *b, dReal *w, dReal *lo,
00228                          dReal *hi, <span class="keywordtype">int</span> *p, <span class="keywordtype">int</span> *state, <span class="keywordtype">int</span> *findex,
00229                          <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2, <span class="keywordtype">int</span> nskip,
00230                          <span class="keywordtype">int</span> do_fast_row_swaps)
00231 {
00232   dReal tmp;
00233   <span class="keywordtype">int</span> tmpi;
00234   dIASSERT (n&gt;0 &amp;&amp; i1 &gt;=0 &amp;&amp; i2 &gt;= 0 &amp;&amp; i1 &lt; n &amp;&amp; i2 &lt; n &amp;&amp; nskip &gt;= n &amp;&amp;
00235             i1 &lt;= i2);
00236   <span class="keywordflow">if</span> (<a class="code" href="analytical_8c.html#a14">i1</a>==i2) <span class="keywordflow">return</span>;
00237   swapRowsAndCols (A,n,i1,i2,nskip,do_fast_row_swaps);
00238   tmp = <a class="code" href="matrix_8c.html#a13">x</a>[<a class="code" href="analytical_8c.html#a14">i1</a>];
00239   <a class="code" href="matrix_8c.html#a13">x</a>[<a class="code" href="analytical_8c.html#a14">i1</a>] = <a class="code" href="matrix_8c.html#a13">x</a>[i2];
00240   <a class="code" href="matrix_8c.html#a13">x</a>[i2] = tmp;
00241   tmp = <a class="code" href="matrix_8c.html#a10">b</a>[<a class="code" href="analytical_8c.html#a14">i1</a>];
00242   <a class="code" href="matrix_8c.html#a10">b</a>[<a class="code" href="analytical_8c.html#a14">i1</a>] = <a class="code" href="matrix_8c.html#a10">b</a>[i2];
00243   <a class="code" href="matrix_8c.html#a10">b</a>[i2] = tmp;
00244   tmp = <a class="code" href="matrix_8c.html#a11">w</a>[<a class="code" href="analytical_8c.html#a14">i1</a>];
00245   <a class="code" href="matrix_8c.html#a11">w</a>[<a class="code" href="analytical_8c.html#a14">i1</a>] = <a class="code" href="matrix_8c.html#a11">w</a>[i2];
00246   <a class="code" href="matrix_8c.html#a11">w</a>[i2] = tmp;
00247   tmp = lo[<a class="code" href="analytical_8c.html#a14">i1</a>];
00248   lo[<a class="code" href="analytical_8c.html#a14">i1</a>] = lo[i2];
00249   lo[i2] = tmp;
00250   tmp = hi[<a class="code" href="analytical_8c.html#a14">i1</a>];
00251   hi[<a class="code" href="analytical_8c.html#a14">i1</a>] = hi[i2];
00252   hi[i2] = tmp;
00253   tmpi = p[<a class="code" href="analytical_8c.html#a14">i1</a>];
00254   p[<a class="code" href="analytical_8c.html#a14">i1</a>] = p[i2];
00255   p[i2] = tmpi;
00256   tmpi = state[<a class="code" href="analytical_8c.html#a14">i1</a>];
00257   state[<a class="code" href="analytical_8c.html#a14">i1</a>] = state[i2];
00258   state[i2] = tmpi;
00259   <span class="keywordflow">if</span> (findex) {
00260     tmpi = findex[<a class="code" href="analytical_8c.html#a14">i1</a>];
00261     findex[<a class="code" href="analytical_8c.html#a14">i1</a>] = findex[i2];
00262     findex[i2] = tmpi;
00263   }
00264 }
00265 
00266 
00267 <span class="comment">// for debugging - check that L,d is the factorization of A[C,C].</span>
00268 <span class="comment">// A[C,C] has size nC*nC and leading dimension nskip.</span>
00269 <span class="comment">// L has size nC*nC and leading dimension nskip.</span>
00270 <span class="comment">// d has size nC.</span>
00271 
00272 <span class="preprocessor">#ifdef DEBUG_LCP</span>
00273 <span class="preprocessor"></span>
00274 <span class="keyword">static</span> <span class="keywordtype">void</span> checkFactorization (ATYPE A, dReal *_L, dReal *_d,
00275                                 <span class="keywordtype">int</span> nC, <span class="keywordtype">int</span> *C, <span class="keywordtype">int</span> nskip)
00276 {
00277   <span class="keywordtype">int</span> i,j;
00278   <span class="keywordflow">if</span> (nC==0) <span class="keywordflow">return</span>;
00279 
00280   <span class="comment">// get A1=A, copy the lower triangle to the upper triangle, get A2=A[C,C]</span>
00281   dMatrix A1 (nC,nC);
00282   <span class="keywordflow">for</span> (i=0; i&lt;nC; i++) {
00283     <span class="keywordflow">for</span> (j=0; j&lt;=i; j++) A1(i,j) = A1(j,i) = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[j];
00284   }
00285   dMatrix A2 = A1.select (nC,C,nC,C);
00286 
00287   <span class="comment">// printf ("A1=\n"); A1.print(); printf ("\n");</span>
00288   <span class="comment">// printf ("A2=\n"); A2.print(); printf ("\n");</span>
00289 
00290   <span class="comment">// compute A3 = L*D*L'</span>
00291   dMatrix L (nC,nC,_L,nskip,1);
00292   dMatrix D (nC,nC);
00293   <span class="keywordflow">for</span> (i=0; i&lt;nC; i++) D(i,i) = 1/_d[i];
00294   L.clearUpperTriangle();
00295   <span class="keywordflow">for</span> (i=0; i&lt;nC; i++) L(i,i) = 1;
00296   dMatrix A3 = L * D * L.transpose();
00297 
00298   <span class="comment">// printf ("L=\n"); L.print(); printf ("\n");</span>
00299   <span class="comment">// printf ("D=\n"); D.print(); printf ("\n");</span>
00300   <span class="comment">// printf ("A3=\n"); A2.print(); printf ("\n");</span>
00301 
00302   <span class="comment">// compare A2 and A3</span>
00303   dReal diff = A2.maxDifference (A3);
00304   <span class="keywordflow">if</span> (diff &gt; 1e-8)
00305     dDebug (0,<span class="stringliteral">"L*D*L' check, maximum difference = %.6e\n"</span>,diff);
00306 }
00307 
00308 <span class="preprocessor">#endif</span>
00309 <span class="preprocessor"></span>
00310 
00311 <span class="comment">// for debugging</span>
00312 
00313 <span class="preprocessor">#ifdef DEBUG_LCP</span>
00314 <span class="preprocessor"></span>
00315 <span class="keyword">static</span> <span class="keywordtype">void</span> checkPermutations (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> nC, <span class="keywordtype">int</span> nN, <span class="keywordtype">int</span> *p, <span class="keywordtype">int</span> *C)
00316 {
00317   <span class="keywordtype">int</span> j,k;
00318   dIASSERT (nC&gt;=0 &amp;&amp; nN&gt;=0 &amp;&amp; (nC+nN)==i &amp;&amp; i &lt; n);
00319   <span class="keywordflow">for</span> (k=0; k&lt;i; k++) dIASSERT (p[k] &gt;= 0 &amp;&amp; p[k] &lt; i);
00320   <span class="keywordflow">for</span> (k=i; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) dIASSERT (p[k] == k);
00321   <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) {
00322     <span class="keywordtype">int</span> C_is_bad = 1;
00323     <span class="keywordflow">for</span> (k=0; k&lt;nC; k++) <span class="keywordflow">if</span> (C[k]==j) C_is_bad = 0;
00324     dIASSERT (C_is_bad==0);
00325   }
00326 }
00327 
00328 <span class="preprocessor">#endif</span>
00329 <span class="preprocessor"></span>
00330 <span class="comment">//***************************************************************************</span>
00331 <span class="comment">// dLCP manipulator object. this represents an n*n LCP problem.</span>
00332 <span class="comment">//</span>
00333 <span class="comment">// two index sets C and N are kept. each set holds a subset of</span>
00334 <span class="comment">// the variable indexes 0..n-1. an index can only be in one set.</span>
00335 <span class="comment">// initially both sets are empty.</span>
00336 <span class="comment">//</span>
00337 <span class="comment">// the index set C is special: solutions to A(C,C)\A(C,i) can be generated.</span>
00338 
00339 <span class="preprocessor">#ifdef dLCP_SLOW</span>
00340 <span class="preprocessor"></span>
00341 <span class="comment">// simple but slow implementation of dLCP, for testing the LCP drivers.</span>
00342 
00343 <span class="preprocessor">#include "array.h"</span>
00344 
00345 <span class="keyword">struct </span><a class="code" href="structdLCP.html">dLCP</a> {
00346   <span class="keywordtype">int</span> <a class="code" href="matrix_8c.html#a12">n</a>,<a class="code" href="structdLCP.html#dLCPo2">nub</a>,nskip;
00347   dReal *<a class="code" href="structdLCP.html#dLCPo4">Adata</a>,*<a class="code" href="structdLCP.html#dLCPo5">x</a>,*<a class="code" href="structdLCP.html#dLCPo6">b</a>,*<a class="code" href="structdLCP.html#dLCPo7">w</a>,*<a class="code" href="structdLCP.html#dLCPo8">lo</a>,*<a class="code" href="structdLCP.html#dLCPo9">hi</a>;        <span class="comment">// LCP problem data</span>
00348   <a class="code" href="lcp_8cpp.html#a2">ATYPE</a> A;                              <span class="comment">// A rows</span>
00349   dArray&lt;int&gt; C,<a class="code" href="general_8h.html#a53">N</a>;                      <span class="comment">// index sets</span>
00350   <span class="keywordtype">int</span> last_i_for_solve1;                <span class="comment">// last i value given to solve1</span>
00351 
00352   <a class="code" href="structdLCP.html#dLCPa0">dLCP</a> (<span class="keywordtype">int</span> _n, <span class="keywordtype">int</span> _nub, dReal *_Adata, dReal *_x, dReal *_b, dReal *_w,
00353         dReal *_lo, dReal *_hi, dReal *_L, dReal *_d,
00354         dReal *_Dell, dReal *_ell, dReal *_tmp,
00355         <span class="keywordtype">int</span> *_state, <span class="keywordtype">int</span> *_findex, <span class="keywordtype">int</span> *_p, <span class="keywordtype">int</span> *_C, dReal **Arows);
00356   <span class="comment">// the constructor is given an initial problem description (A,x,b,w) and</span>
00357   <span class="comment">// space for other working data (which the caller may allocate on the stack).</span>
00358   <span class="comment">// some of this data is specific to the fast dLCP implementation.</span>
00359   <span class="comment">// the matrices A and L have size n*n, vectors have size n*1.</span>
00360   <span class="comment">// A represents a symmetric matrix but only the lower triangle is valid.</span>
00361   <span class="comment">// `nub' is the number of unbounded indexes at the start. all the indexes</span>
00362   <span class="comment">// 0..nub-1 will be put into C.</span>
00363 
00364   ~<a class="code" href="structdLCP.html">dLCP</a>();
00365 
00366   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa1">getNub</a>() { <span class="keywordflow">return</span> <a class="code" href="structdLCP.html#dLCPo2">nub</a>; }
00367   <span class="comment">// return the value of `nub'. the constructor may want to change it,</span>
00368   <span class="comment">// so the caller should find out its new value.</span>
00369 
00370   <span class="comment">// transfer functions: transfer index i to the given set (C or N). indexes</span>
00371   <span class="comment">// less than `nub' can never be given. A,x,b,w,etc may be permuted by these</span>
00372   <span class="comment">// functions, the caller must be robust to this.</span>
00373 
00374   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa2">transfer_i_to_C</a> (<span class="keywordtype">int</span> i);
00375     <span class="comment">// this assumes C and N span 1:i-1. this also assumes that solve1() has</span>
00376     <span class="comment">// been recently called for the same i without any other transfer</span>
00377     <span class="comment">// functions in between (thereby allowing some data reuse for the fast</span>
00378     <span class="comment">// implementation).</span>
00379   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (<span class="keywordtype">int</span> i);
00380     <span class="comment">// this assumes C and N span 1:i-1.</span>
00381   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa4">transfer_i_from_N_to_C</a> (<span class="keywordtype">int</span> i);
00382   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa5">transfer_i_from_C_to_N</a> (<span class="keywordtype">int</span> i);
00383 
00384   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa6">numC</a>();
00385   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa7">numN</a>();
00386   <span class="comment">// return the number of indexes in set C/N</span>
00387 
00388   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa8">indexC</a> (<span class="keywordtype">int</span> i);
00389   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa9">indexN</a> (<span class="keywordtype">int</span> i);
00390   <span class="comment">// return index i in set C/N.</span>
00391 
00392   <span class="comment">// accessor and arithmetic functions. Aij translates as A(i,j), etc.</span>
00393   <span class="comment">// make sure that only the lower triangle of A is ever referenced.</span>
00394 
00395   dReal <a class="code" href="structdLCP.html#dLCPa10">Aii</a> (<span class="keywordtype">int</span> i);
00396   dReal <a class="code" href="structdLCP.html#dLCPa11">AiC_times_qC</a> (<span class="keywordtype">int</span> i, dReal *q);
00397   dReal <a class="code" href="structdLCP.html#dLCPa12">AiN_times_qN</a> (<span class="keywordtype">int</span> i, dReal *q);                 <span class="comment">// for all Nj</span>
00398   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa13">pN_equals_ANC_times_qC</a> (dReal *p, dReal *q);     <span class="comment">// for all Nj</span>
00399   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa14">pN_plusequals_ANi</a> (dReal *p, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> sign=1);
00400     <span class="comment">// for all Nj. sign = +1,-1. assumes i &gt; maximum index in N.</span>
00401   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa15">pC_plusequals_s_times_qC</a> (dReal *p, dReal s, dReal *q);
00402   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa16">pN_plusequals_s_times_qN</a> (dReal *p, dReal s, dReal *q); <span class="comment">// for all Nj</span>
00403   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa17">solve1</a> (dReal *a, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dir=1);
00404     <span class="comment">// get a(C) = - dir * A(C,C) \ A(C,i). dir must be +/- 1</span>
00405 
00406   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa18">unpermute</a>();
00407   <span class="comment">// call this at the end of the LCP function. if the x/w values have been</span>
00408   <span class="comment">// permuted then this will unscramble them.</span>
00409 };
00410 
00411 
00412 <a class="code" href="structdLCP.html#dLCPa0">dLCP::dLCP</a> (<span class="keywordtype">int</span> _n, <span class="keywordtype">int</span> _nub, dReal *_Adata, dReal *_x, dReal *_b, dReal *_w,
00413             dReal *_lo, dReal *_hi, dReal *_L, dReal *_d,
00414             dReal *_Dell, dReal *_ell, dReal *_tmp,
00415             <span class="keywordtype">int</span> *_state, <span class="keywordtype">int</span> *_findex, <span class="keywordtype">int</span> *_p, <span class="keywordtype">int</span> *_C, dReal **Arows)
00416 {
00417   dUASSERT (_findex==0,<span class="stringliteral">"slow dLCP object does not support findex array"</span>);
00418 
00419   <a class="code" href="matrix_8c.html#a12">n</a> = _n;
00420   <a class="code" href="structdLCP.html#dLCPo2">nub</a> = _nub;
00421   <a class="code" href="structdLCP.html#dLCPo4">Adata</a> = _Adata;
00422   A = 0;
00423   <a class="code" href="structdLCP.html#dLCPo5">x</a> = _x;
00424   <a class="code" href="structdLCP.html#dLCPo6">b</a> = _b;
00425   <a class="code" href="structdLCP.html#dLCPo7">w</a> = _w;
00426   <a class="code" href="structdLCP.html#dLCPo8">lo</a> = _lo;
00427   <a class="code" href="structdLCP.html#dLCPo9">hi</a> = _hi;
00428   nskip = dPAD(n);
00429   dSetZero (x,n);
00430   last_i_for_solve1 = -1;
00431 
00432   <span class="keywordtype">int</span> i,j;
00433   C.setSize (n);
00434   <a class="code" href="general_8h.html#a53">N</a>.setSize (n);
00435   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
00436     C[i] = 0;
00437     <a class="code" href="general_8h.html#a53">N</a>[i] = 0;
00438   }
00439 
00440 <span class="preprocessor"># ifdef ROWPTRS</span>
00441 <span class="preprocessor"></span>  <span class="comment">// make matrix row pointers</span>
00442   A = Arows;
00443   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) A[i] = <a class="code" href="structdLCP.html#dLCPo4">Adata</a> + i*nskip;
00444 <span class="preprocessor"># else</span>
00445 <span class="preprocessor"></span>  A = <a class="code" href="structdLCP.html#dLCPo4">Adata</a>;
00446 <span class="preprocessor"># endif</span>
00447 <span class="preprocessor"></span>
00448   <span class="comment">// lets make A symmetric</span>
00449   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
00450     <span class="keywordflow">for</span> (j=i+1; j&lt;<a class="code" href="matrix_8c.html#a12">n</a>; j++) <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[j] = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(j)[i];
00451   }
00452 
00453   <span class="comment">// if nub&gt;0, put all indexes 0..nub-1 into C and solve for x</span>
00454   <span class="keywordflow">if</span> (<a class="code" href="structdLCP.html#dLCPo2">nub</a> &gt; 0) {
00455     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="structdLCP.html#dLCPo2">nub</a>; i++) memcpy (_L+i*nskip,<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i),(i+1)*<span class="keyword">sizeof</span>(dReal));
00456     dFactorLDLT (_L,_d,nub,nskip);
00457     memcpy (x,b,nub*<span class="keyword">sizeof</span>(dReal));
00458     dSolveLDLT (_L,_d,x,nub,nskip);
00459     dSetZero (_w,nub);
00460     <span class="keywordflow">for</span> (i=0; i&lt;nub; i++) C[i] = 1;
00461   }
00462 }
00463 
00464 
00465 dLCP::~dLCP()
00466 {
00467 }
00468 
00469 
00470 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa2">dLCP::transfer_i_to_C</a> (<span class="keywordtype">int</span> i)
00471 {
00472   <span class="keywordflow">if</span> (i &lt; nub) dDebug (0,<span class="stringliteral">"bad i"</span>);
00473   <span class="keywordflow">if</span> (C[i]) dDebug (0,<span class="stringliteral">"i already in C"</span>);
00474   <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[i]) dDebug (0,<span class="stringliteral">"i already in N"</span>);
00475   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i; k++) {
00476     <span class="keywordflow">if</span> (!(C[k] ^ <a class="code" href="general_8h.html#a53">N</a>[k])) dDebug (0,<span class="stringliteral">"assumptions for C and N violated"</span>);
00477   }
00478   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=i; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++)
00479     <span class="keywordflow">if</span> (C[k] || <a class="code" href="general_8h.html#a53">N</a>[k]) dDebug (0,<span class="stringliteral">"assumptions for C and N violated"</span>);
00480   <span class="keywordflow">if</span> (i != last_i_for_solve1) dDebug (0,<span class="stringliteral">"assumptions for i violated"</span>);
00481   last_i_for_solve1 = -1;
00482   C[i] = 1;
00483 }
00484 
00485 
00486 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa3">dLCP::transfer_i_to_N</a> (<span class="keywordtype">int</span> i)
00487 {
00488   <span class="keywordflow">if</span> (i &lt; nub) dDebug (0,<span class="stringliteral">"bad i"</span>);
00489   <span class="keywordflow">if</span> (C[i]) dDebug (0,<span class="stringliteral">"i already in C"</span>);
00490   <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[i]) dDebug (0,<span class="stringliteral">"i already in N"</span>);
00491   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;i; k++)
00492     <span class="keywordflow">if</span> (!C[k] &amp;&amp; !<a class="code" href="general_8h.html#a53">N</a>[k]) dDebug (0,<span class="stringliteral">"assumptions for C and N violated"</span>);
00493   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=i; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++)
00494     <span class="keywordflow">if</span> (C[k] || <a class="code" href="general_8h.html#a53">N</a>[k]) dDebug (0,<span class="stringliteral">"assumptions for C and N violated"</span>);
00495   last_i_for_solve1 = -1;
00496   <a class="code" href="general_8h.html#a53">N</a>[i] = 1;
00497 }
00498 
00499 
00500 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa4">dLCP::transfer_i_from_N_to_C</a> (<span class="keywordtype">int</span> i)
00501 {
00502   <span class="keywordflow">if</span> (i &lt; nub) dDebug (0,<span class="stringliteral">"bad i"</span>);
00503   <span class="keywordflow">if</span> (C[i]) dDebug (0,<span class="stringliteral">"i already in C"</span>);
00504   <span class="keywordflow">if</span> (!<a class="code" href="general_8h.html#a53">N</a>[i]) dDebug (0,<span class="stringliteral">"i not in N"</span>);
00505   last_i_for_solve1 = -1;
00506   <a class="code" href="general_8h.html#a53">N</a>[i] = 0;
00507   C[i] = 1;
00508 }
00509 
00510 
00511 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa5">dLCP::transfer_i_from_C_to_N</a> (<span class="keywordtype">int</span> i)
00512 {
00513   <span class="keywordflow">if</span> (i &lt; nub) dDebug (0,<span class="stringliteral">"bad i"</span>);
00514   <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[i]) dDebug (0,<span class="stringliteral">"i already in N"</span>);
00515   <span class="keywordflow">if</span> (!C[i]) dDebug (0,<span class="stringliteral">"i not in C"</span>);
00516   last_i_for_solve1 = -1;
00517   C[i] = 0;
00518   <a class="code" href="general_8h.html#a53">N</a>[i] = 1;
00519 }
00520 
00521 
00522 <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa6">dLCP::numC</a>()
00523 {
00524   <span class="keywordtype">int</span> i,count=0;
00525   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) <span class="keywordflow">if</span> (C[i]) count++;
00526   <span class="keywordflow">return</span> count;
00527 }
00528 
00529 
00530 <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa7">dLCP::numN</a>()
00531 {
00532   <span class="keywordtype">int</span> i,count=0;
00533   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[i]) count++;
00534   <span class="keywordflow">return</span> count;
00535 }
00536 
00537 
00538 <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa8">dLCP::indexC</a> (<span class="keywordtype">int</span> i)
00539 {
00540   <span class="keywordtype">int</span> k,count=0;
00541   <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) {
00542     <span class="keywordflow">if</span> (C[k]) {
00543       <span class="keywordflow">if</span> (count==i) <span class="keywordflow">return</span> k;
00544       count++;
00545     }
00546   }
00547   dDebug (0,<span class="stringliteral">"bad index C (%d)"</span>,i);
00548   <span class="keywordflow">return</span> 0;
00549 }
00550 
00551 
00552 <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa9">dLCP::indexN</a> (<span class="keywordtype">int</span> i)
00553 {
00554   <span class="keywordtype">int</span> k,count=0;
00555   <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) {
00556     <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[k]) {
00557       <span class="keywordflow">if</span> (count==i) <span class="keywordflow">return</span> k;
00558       count++;
00559     }
00560   }
00561   dDebug (0,<span class="stringliteral">"bad index into N"</span>);
00562   <span class="keywordflow">return</span> 0;
00563 }
00564 
00565 
00566 dReal <a class="code" href="structdLCP.html#dLCPa10">dLCP::Aii</a> (<span class="keywordtype">int</span> i)
00567 {
00568   <span class="keywordflow">return</span> <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[i];
00569 }
00570 
00571 
00572 dReal <a class="code" href="structdLCP.html#dLCPa11">dLCP::AiC_times_qC</a> (<span class="keywordtype">int</span> i, dReal *q)
00573 {
00574   dReal sum = 0;
00575   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) <span class="keywordflow">if</span> (C[k]) sum += <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[k] * q[k];
00576   <span class="keywordflow">return</span> sum;
00577 }
00578 
00579 
00580 dReal <a class="code" href="structdLCP.html#dLCPa12">dLCP::AiN_times_qN</a> (<span class="keywordtype">int</span> i, dReal *q)
00581 {
00582   dReal sum = 0;
00583   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[k]) sum += <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[k] * q[k];
00584   <span class="keywordflow">return</span> sum;
00585 }
00586 
00587 
00588 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa13">dLCP::pN_equals_ANC_times_qC</a> (dReal *p, dReal *q)
00589 {
00590   dReal sum;
00591   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=0; ii&lt;<a class="code" href="matrix_8c.html#a12">n</a>; ii++) <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[ii]) {
00592     sum = 0;
00593     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj=0; jj&lt;<a class="code" href="matrix_8c.html#a12">n</a>; jj++) <span class="keywordflow">if</span> (C[jj]) sum += <a class="code" href="lcp_8cpp.html#a3">AROW</a>(ii)[jj] * q[jj];
00594     p[ii] = sum;
00595   }
00596 }
00597 
00598 
00599 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa14">dLCP::pN_plusequals_ANi</a> (dReal *p, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> sign)
00600 {
00601   <span class="keywordtype">int</span> k;
00602   <span class="keywordflow">for</span> (k=0; k&lt;n; k++) if (N[k] &amp;&amp; k &gt;= i) dDebug (0,<span class="stringliteral">"N assumption violated"</span>);
00603   <span class="keywordflow">if</span> (sign &gt; 0) {
00604     <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[k]) p[k] += <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[k];
00605   }
00606   <span class="keywordflow">else</span> {
00607     <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[k]) p[k] -= <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[k];
00608   }
00609 }
00610 
00611 
00612 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa15">dLCP::pC_plusequals_s_times_qC</a> (dReal *p, dReal s, dReal *q)
00613 {
00614   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) <span class="keywordflow">if</span> (C[k]) p[k] += s*q[k];
00615 }
00616 
00617 
00618 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa16">dLCP::pN_plusequals_s_times_qN</a> (dReal *p, dReal s, dReal *q)
00619 {
00620   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) <span class="keywordflow">if</span> (<a class="code" href="general_8h.html#a53">N</a>[k]) p[k] += s*q[k];
00621 }
00622 
00623 
00624 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa17">dLCP::solve1</a> (dReal *a, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dir)
00625 {
00626   dReal *AA = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (n*nskip*<span class="keyword">sizeof</span>(dReal));
00627   dReal *dd = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (n*<span class="keyword">sizeof</span>(dReal));
00628   dReal *bb = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (n*<span class="keyword">sizeof</span>(dReal));
00629   <span class="keywordtype">int</span> ii,jj,AAi,AAj;
00630 
00631   last_i_for_solve1 = i;
00632   AAi = 0;
00633   <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="matrix_8c.html#a12">n</a>; ii++) <span class="keywordflow">if</span> (C[ii]) {
00634     AAj = 0;
00635     <span class="keywordflow">for</span> (jj=0; jj&lt;<a class="code" href="matrix_8c.html#a12">n</a>; jj++) <span class="keywordflow">if</span> (C[jj]) {
00636       AA[AAi*nskip+AAj] = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(ii)[jj];
00637       AAj++;
00638     }
00639     bb[AAi] = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[ii];
00640     AAi++;
00641   }
00642   <span class="keywordflow">if</span> (AAi==0) <span class="keywordflow">return</span>;
00643 
00644   dFactorLDLT (AA,dd,AAi,nskip);
00645   dSolveLDLT (AA,dd,bb,AAi,nskip);
00646 
00647   AAi=0;
00648   <span class="keywordflow">if</span> (dir &gt; 0) {
00649     <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="matrix_8c.html#a12">n</a>; ii++) <span class="keywordflow">if</span> (C[ii]) <a class="code" href="matrix_8c.html#a8">a</a>[ii] = -bb[AAi++];
00650   }
00651   <span class="keywordflow">else</span> {
00652     <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="matrix_8c.html#a12">n</a>; ii++) <span class="keywordflow">if</span> (C[ii]) <a class="code" href="matrix_8c.html#a8">a</a>[ii] = bb[AAi++];
00653   }
00654 }
00655 
00656 
00657 <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa18">dLCP::unpermute</a>()
00658 {
00659 }
00660 
00661 <span class="preprocessor">#endif // dLCP_SLOW</span>
00662 <span class="preprocessor"></span>
00663 <span class="comment">//***************************************************************************</span>
00664 <span class="comment">// fast implementation of dLCP. see the above definition of dLCP for</span>
00665 <span class="comment">// interface comments.</span>
00666 <span class="comment">//</span>
00667 <span class="comment">// `p' records the permutation of A,x,b,w,etc. p is initially 1:n and is</span>
00668 <span class="comment">// permuted as the other vectors/matrices are permuted.</span>
00669 <span class="comment">//</span>
00670 <span class="comment">// A,x,b,w,lo,hi,state,findex,p,c are permuted such that sets C,N have</span>
00671 <span class="comment">// contiguous indexes. the don't-care indexes follow N.</span>
00672 <span class="comment">//</span>
00673 <span class="comment">// an L*D*L' factorization is maintained of A(C,C), and whenever indexes are</span>
00674 <span class="comment">// added or removed from the set C the factorization is updated.</span>
00675 <span class="comment">// thus L*D*L'=A[C,C], i.e. a permuted top left nC*nC submatrix of A.</span>
00676 <span class="comment">// the leading dimension of the matrix L is always `nskip'.</span>
00677 <span class="comment">//</span>
00678 <span class="comment">// at the start there may be other indexes that are unbounded but are not</span>
00679 <span class="comment">// included in `nub'. dLCP will permute the matrix so that absolutely all</span>
00680 <span class="comment">// unbounded vectors are at the start. thus there may be some initial</span>
00681 <span class="comment">// permutation.</span>
00682 <span class="comment">//</span>
00683 <span class="comment">// the algorithms here assume certain patterns, particularly with respect to</span>
00684 <span class="comment">// index transfer.</span>
00685 
00686 <span class="preprocessor">#ifdef dLCP_FAST</span>
00687 <span class="preprocessor"></span>
<a name="l00688"></a><a class="code" href="structdLCP.html">00688</a> <span class="keyword">struct </span><a class="code" href="structdLCP.html">dLCP</a> {
<a name="l00689"></a><a class="code" href="structdLCP.html#dLCPo2">00689</a>   <span class="keywordtype">int</span> <a class="code" href="matrix_8c.html#a12">n</a>,nskip,nub;
<a name="l00690"></a><a class="code" href="structdLCP.html#dLCPo3">00690</a>   <a class="code" href="lcp_8cpp.html#a2">ATYPE</a> A;                              <span class="comment">// A rows</span>
<a name="l00691"></a><a class="code" href="structdLCP.html#dLCPo5">00691</a>   dReal *Adata,*<a class="code" href="structdLCP.html#dLCPo5">x</a>,*<a class="code" href="structdLCP.html#dLCPo6">b</a>,*<a class="code" href="structdLCP.html#dLCPo7">w</a>,*<a class="code" href="structdLCP.html#dLCPo8">lo</a>,*<a class="code" href="structdLCP.html#dLCPo9">hi</a>;        <span class="comment">// permuted LCP problem data</span>
<a name="l00692"></a><a class="code" href="structdLCP.html#dLCPo10">00692</a>   dReal *<a class="code" href="structdLCP.html#dLCPo10">L</a>,*<a class="code" href="structdLCP.html#dLCPo11">d</a>;                          <span class="comment">// L*D*L' factorization of set C</span>
<a name="l00693"></a><a class="code" href="structdLCP.html#dLCPo14">00693</a>   dReal *<a class="code" href="structdLCP.html#dLCPo12">Dell</a>,*<a class="code" href="structdLCP.html#dLCPo13">ell</a>,*tmp;
<a name="l00694"></a><a class="code" href="structdLCP.html#dLCPo15">00694</a>   <span class="keywordtype">int</span> *<a class="code" href="structdLCP.html#dLCPo15">state</a>,*<a class="code" href="structdLCP.html#dLCPo16">findex</a>,*p,*C;
<a name="l00695"></a><a class="code" href="structdLCP.html#dLCPo20">00695</a>   <span class="keywordtype">int</span> nC,nN;                            <span class="comment">// size of each index set</span>
00696 
00697   <a class="code" href="structdLCP.html#dLCPa0">dLCP</a> (<span class="keywordtype">int</span> _n, <span class="keywordtype">int</span> _nub, dReal *_Adata, dReal *_x, dReal *_b, dReal *_w,
00698         dReal *_lo, dReal *_hi, dReal *_L, dReal *_d,
00699         dReal *_Dell, dReal *_ell, dReal *_tmp,
00700         <span class="keywordtype">int</span> *_state, <span class="keywordtype">int</span> *_findex, <span class="keywordtype">int</span> *_p, <span class="keywordtype">int</span> *_C, dReal **Arows);
<a name="l00701"></a><a class="code" href="structdLCP.html#dLCPa1">00701</a>   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa1">getNub</a>() { <span class="keywordflow">return</span> nub; }
00702   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa2">transfer_i_to_C</a> (<span class="keywordtype">int</span> i);
<a name="l00703"></a><a class="code" href="structdLCP.html#dLCPa3">00703</a>   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (<span class="keywordtype">int</span> i)
00704     { nN++; }                   <span class="comment">// because we can assume C and N span 1:i-1</span>
00705   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa4">transfer_i_from_N_to_C</a> (<span class="keywordtype">int</span> i);
00706   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa5">transfer_i_from_C_to_N</a> (<span class="keywordtype">int</span> i);
<a name="l00707"></a><a class="code" href="structdLCP.html#dLCPa6">00707</a>   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa6">numC</a>() { <span class="keywordflow">return</span> nC; }
<a name="l00708"></a><a class="code" href="structdLCP.html#dLCPa7">00708</a>   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa7">numN</a>() { <span class="keywordflow">return</span> nN; }
<a name="l00709"></a><a class="code" href="structdLCP.html#dLCPa8">00709</a>   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa8">indexC</a> (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i; }
<a name="l00710"></a><a class="code" href="structdLCP.html#dLCPa9">00710</a>   <span class="keywordtype">int</span> <a class="code" href="structdLCP.html#dLCPa9">indexN</a> (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i+nC; }
<a name="l00711"></a><a class="code" href="structdLCP.html#dLCPa10">00711</a>   dReal <a class="code" href="structdLCP.html#dLCPa10">Aii</a> (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[i]; }
<a name="l00712"></a><a class="code" href="structdLCP.html#dLCPa11">00712</a>   dReal <a class="code" href="structdLCP.html#dLCPa11">AiC_times_qC</a> (<span class="keywordtype">int</span> i, dReal *q) { <span class="keywordflow">return</span> dDot (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i),q,nC); }
<a name="l00713"></a><a class="code" href="structdLCP.html#dLCPa12">00713</a>   dReal <a class="code" href="structdLCP.html#dLCPa12">AiN_times_qN</a> (<span class="keywordtype">int</span> i, dReal *q) { <span class="keywordflow">return</span> dDot (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)+nC,q+nC,nN); }
00714   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa13">pN_equals_ANC_times_qC</a> (dReal *p, dReal *q);
00715   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa14">pN_plusequals_ANi</a> (dReal *p, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> sign=1);
<a name="l00716"></a><a class="code" href="structdLCP.html#dLCPa15">00716</a>   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa15">pC_plusequals_s_times_qC</a> (dReal *p, dReal s, dReal *q)
00717     { <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nC; i++) p[i] += s*q[i]; }
<a name="l00718"></a><a class="code" href="structdLCP.html#dLCPa16">00718</a>   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa16">pN_plusequals_s_times_qN</a> (dReal *p, dReal s, dReal *q)
00719     { <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nN; i++) p[i+nC] += s*q[i+nC]; }
00720   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa17">solve1</a> (dReal *a, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dir=1);
00721   <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa18">unpermute</a>();
00722 };
00723 
00724 
<a name="l00725"></a><a class="code" href="structdLCP.html#dLCPa0">00725</a> <a class="code" href="structdLCP.html#dLCPa0">dLCP::dLCP</a> (<span class="keywordtype">int</span> _n, <span class="keywordtype">int</span> _nub, dReal *_Adata, dReal *_x, dReal *_b, dReal *_w,
00726             dReal *_lo, dReal *_hi, dReal *_L, dReal *_d,
00727             dReal *_Dell, dReal *_ell, dReal *_tmp,
00728             <span class="keywordtype">int</span> *_state, <span class="keywordtype">int</span> *_findex, <span class="keywordtype">int</span> *_p, <span class="keywordtype">int</span> *_C, dReal **Arows)
00729 {
00730   <a class="code" href="matrix_8c.html#a12">n</a> = _n;
00731   nub = _nub;
00732   Adata = _Adata;
00733   A = 0;
00734   <a class="code" href="structdLCP.html#dLCPo5">x</a> = _x;
00735   <a class="code" href="structdLCP.html#dLCPo6">b</a> = _b;
00736   <a class="code" href="structdLCP.html#dLCPo7">w</a> = _w;
00737   <a class="code" href="structdLCP.html#dLCPo8">lo</a> = _lo;
00738   <a class="code" href="structdLCP.html#dLCPo9">hi</a> = _hi;
00739   <a class="code" href="structdLCP.html#dLCPo10">L</a> = _L;
00740   <a class="code" href="structdLCP.html#dLCPo11">d</a> = _d;
00741   <a class="code" href="structdLCP.html#dLCPo12">Dell</a> = _Dell;
00742   <a class="code" href="structdLCP.html#dLCPo13">ell</a> = _ell;
00743   tmp = _tmp;
00744   <a class="code" href="structdLCP.html#dLCPo15">state</a> = _state;
00745   <a class="code" href="structdLCP.html#dLCPo16">findex</a> = _findex;
00746   p = _p;
00747   C = _C;
00748   nskip = dPAD(<a class="code" href="matrix_8c.html#a12">n</a>);
00749   dSetZero (<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="matrix_8c.html#a12">n</a>);
00750 
00751   <span class="keywordtype">int</span> k;
00752 
00753 <span class="preprocessor"># ifdef ROWPTRS</span>
00754 <span class="preprocessor"></span>  <span class="comment">// make matrix row pointers</span>
00755   A = Arows;
00756   <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) A[k] = Adata + k*nskip;
00757 <span class="preprocessor"># else</span>
00758 <span class="preprocessor"></span>  A = Adata;
00759 <span class="preprocessor"># endif</span>
00760 <span class="preprocessor"></span>
00761   nC = 0;
00762   nN = 0;
00763   <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) p[k]=k;           <span class="comment">// initially unpermuted</span>
00764 
00765   <span class="comment">/*</span>
00766 <span class="comment">  // for testing, we can do some random swaps in the area i &gt; nub</span>
00767 <span class="comment">  if (nub &lt; n) {</span>
00768 <span class="comment">    for (k=0; k&lt;100; k++) {</span>
00769 <span class="comment">      int i1,i2;</span>
00770 <span class="comment">      do {</span>
00771 <span class="comment">        i1 = dRandInt(n-nub)+nub;</span>
00772 <span class="comment">        i2 = dRandInt(n-nub)+nub;</span>
00773 <span class="comment">      }</span>
00774 <span class="comment">      while (i1 &gt; i2); </span>
00775 <span class="comment">      //printf ("--&gt; %d %d\n",i1,i2);</span>
00776 <span class="comment">      swapProblem (A,x,b,w,lo,hi,p,state,findex,n,i1,i2,nskip,0);</span>
00777 <span class="comment">    }</span>
00778 <span class="comment">  }</span>
00779 <span class="comment">  */</span>
00780 
00781   <span class="comment">// permute the problem so that *all* the unbounded variables are at the</span>
00782   <span class="comment">// start, i.e. look for unbounded variables not included in `nub'. we can</span>
00783   <span class="comment">// potentially push up `nub' this way and get a bigger initial factorization.</span>
00784   <span class="comment">// note that when we swap rows/cols here we must not just swap row pointers,</span>
00785   <span class="comment">// as the initial factorization relies on the data being all in one chunk.</span>
00786   <span class="keywordflow">for</span> (k=nub; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) {
00787     <span class="keywordflow">if</span> (<a class="code" href="structdLCP.html#dLCPo8">lo</a>[k]==-dInfinity &amp;&amp; <a class="code" href="structdLCP.html#dLCPo9">hi</a>[k]==dInfinity) {
00788       swapProblem (A,<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="structdLCP.html#dLCPo6">b</a>,<a class="code" href="structdLCP.html#dLCPo7">w</a>,<a class="code" href="structdLCP.html#dLCPo8">lo</a>,hi,p,<a class="code" href="structdLCP.html#dLCPo15">state</a>,<a class="code" href="structdLCP.html#dLCPo16">findex</a>,<a class="code" href="matrix_8c.html#a12">n</a>,nub,k,nskip,0);
00789       nub++;
00790     }
00791   }
00792 
00793   <span class="comment">// if there are unbounded variables at the start, factorize A up to that</span>
00794   <span class="comment">// point and solve for x. this puts all indexes 0..nub-1 into C.</span>
00795   <span class="keywordflow">if</span> (nub &gt; 0) {
00796     <span class="keywordflow">for</span> (k=0; k&lt;nub; k++) memcpy (<a class="code" href="structdLCP.html#dLCPo10">L</a>+k*nskip,<a class="code" href="lcp_8cpp.html#a3">AROW</a>(k),(k+1)*<span class="keyword">sizeof</span>(dReal));
00797     dFactorLDLT (<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo11">d</a>,nub,nskip);
00798     memcpy (<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="structdLCP.html#dLCPo6">b</a>,nub*<span class="keyword">sizeof</span>(dReal));
00799     dSolveLDLT (<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo11">d</a>,<a class="code" href="structdLCP.html#dLCPo5">x</a>,nub,nskip);
00800     dSetZero (<a class="code" href="structdLCP.html#dLCPo7">w</a>,nub);
00801     <span class="keywordflow">for</span> (k=0; k&lt;nub; k++) C[k] = k;
00802     nC = nub;
00803   }
00804 
00805   <span class="comment">// permute the indexes &gt; nub such that all findex variables are at the end</span>
00806   <span class="keywordflow">if</span> (<a class="code" href="structdLCP.html#dLCPo16">findex</a>) {
00807     <span class="keywordtype">int</span> num_at_end = 0;
00808     <span class="keywordflow">for</span> (k=<a class="code" href="matrix_8c.html#a12">n</a>-1; k &gt;= nub; k--) {
00809       <span class="keywordflow">if</span> (<a class="code" href="structdLCP.html#dLCPo16">findex</a>[k] &gt;= 0) {
00810         swapProblem (A,<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="structdLCP.html#dLCPo6">b</a>,<a class="code" href="structdLCP.html#dLCPo7">w</a>,<a class="code" href="structdLCP.html#dLCPo8">lo</a>,<a class="code" href="structdLCP.html#dLCPo9">hi</a>,p,<a class="code" href="structdLCP.html#dLCPo15">state</a>,<a class="code" href="structdLCP.html#dLCPo16">findex</a>,<a class="code" href="matrix_8c.html#a12">n</a>,k,<a class="code" href="matrix_8c.html#a12">n</a>-1-num_at_end,nskip,1);
00811         num_at_end++;
00812       }
00813     }
00814   }
00815 
00816   <span class="comment">// print info about indexes</span>
00817   <span class="comment">/*</span>
00818 <span class="comment">  for (k=0; k&lt;n; k++) {</span>
00819 <span class="comment">    if (k&lt;nub) printf ("C");</span>
00820 <span class="comment">    else if (lo[k]==-dInfinity &amp;&amp; hi[k]==dInfinity) printf ("c");</span>
00821 <span class="comment">    else printf (".");</span>
00822 <span class="comment">  }</span>
00823 <span class="comment">  printf ("\n");</span>
00824 <span class="comment">  */</span>
00825 }
00826 
00827 
<a name="l00828"></a><a class="code" href="structdLCP.html#dLCPa2">00828</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa2">dLCP::transfer_i_to_C</a> (<span class="keywordtype">int</span> i)
00829 {
00830   <span class="keywordtype">int</span> j;
00831   <span class="keywordflow">if</span> (nC &gt; 0) {
00832     <span class="comment">// ell,Dell were computed by solve1(). note, ell = D \ L1solve (L,A(i,C))</span>
00833     <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo10">L</a>[nC*nskip+j] = <a class="code" href="structdLCP.html#dLCPo13">ell</a>[j];
00834     <a class="code" href="structdLCP.html#dLCPo11">d</a>[nC] = dRecip (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[i] - dDot(ell,<a class="code" href="structdLCP.html#dLCPo12">Dell</a>,nC));
00835   }
00836   <span class="keywordflow">else</span> {
00837     <a class="code" href="structdLCP.html#dLCPo11">d</a>[0] = dRecip (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[i]);
00838   }
00839   swapProblem (A,<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="structdLCP.html#dLCPo6">b</a>,<a class="code" href="structdLCP.html#dLCPo7">w</a>,<a class="code" href="structdLCP.html#dLCPo8">lo</a>,<a class="code" href="structdLCP.html#dLCPo9">hi</a>,p,<a class="code" href="structdLCP.html#dLCPo15">state</a>,<a class="code" href="structdLCP.html#dLCPo16">findex</a>,<a class="code" href="matrix_8c.html#a12">n</a>,nC,i,nskip,1);
00840   C[nC] = nC;
00841   nC++;
00842 
00843 <span class="preprocessor"># ifdef DEBUG_LCP</span>
00844 <span class="preprocessor"></span>  checkFactorization (A,<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo11">d</a>,nC,C,nskip);
00845   <span class="keywordflow">if</span> (i &lt; (<a class="code" href="matrix_8c.html#a12">n</a>-1)) checkPermutations (i+1,<a class="code" href="matrix_8c.html#a12">n</a>,nC,nN,p,C);
00846 <span class="preprocessor"># endif</span>
00847 <span class="preprocessor"></span>}
00848 
00849 
<a name="l00850"></a><a class="code" href="structdLCP.html#dLCPa4">00850</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa4">dLCP::transfer_i_from_N_to_C</a> (<span class="keywordtype">int</span> i)
00851 {
00852   <span class="keywordtype">int</span> j;
00853   <span class="keywordflow">if</span> (nC &gt; 0) {
00854     dReal *aptr = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i);
00855 <span class="preprocessor">#   ifdef NUB_OPTIMIZATIONS</span>
00856 <span class="preprocessor"></span>    <span class="comment">// if nub&gt;0, initial part of aptr unpermuted</span>
00857     <span class="keywordflow">for</span> (j=0; j&lt;nub; j++) <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] = aptr[j];
00858     <span class="keywordflow">for</span> (j=nub; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] = aptr[C[j]];
00859 <span class="preprocessor">#   else</span>
00860 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] = aptr[C[j]];
00861 <span class="preprocessor">#   endif</span>
00862 <span class="preprocessor"></span>    dSolveL1 (<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo12">Dell</a>,nC,nskip);
00863     <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo13">ell</a>[j] = <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] * <a class="code" href="structdLCP.html#dLCPo11">d</a>[j];
00864     <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo10">L</a>[nC*nskip+j] = <a class="code" href="structdLCP.html#dLCPo13">ell</a>[j];
00865     <a class="code" href="matrix_8c.html#a9">d</a>[nC] = dRecip (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[i] - dDot(ell,Dell,nC));
00866   }
00867   <span class="keywordflow">else</span> {
00868     <a class="code" href="structdLCP.html#dLCPo11">d</a>[0] = dRecip (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)[i]);
00869   }
00870   swapProblem (A,<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="structdLCP.html#dLCPo6">b</a>,<a class="code" href="structdLCP.html#dLCPo7">w</a>,<a class="code" href="structdLCP.html#dLCPo8">lo</a>,<a class="code" href="structdLCP.html#dLCPo9">hi</a>,p,<a class="code" href="structdLCP.html#dLCPo15">state</a>,<a class="code" href="structdLCP.html#dLCPo16">findex</a>,<a class="code" href="matrix_8c.html#a12">n</a>,nC,i,nskip,1);
00871   C[nC] = nC;
00872   nN--;
00873   nC++;
00874 
00875   <span class="comment">// @@@ TO DO LATER</span>
00876   <span class="comment">// if we just finish here then we'll go back and re-solve for</span>
00877   <span class="comment">// delta_x. but actually we can be more efficient and incrementally</span>
00878   <span class="comment">// update delta_x here. but if we do this, we wont have ell and Dell</span>
00879   <span class="comment">// to use in updating the factorization later.</span>
00880 
00881 <span class="preprocessor"># ifdef DEBUG_LCP</span>
00882 <span class="preprocessor"></span>  checkFactorization (A,<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo11">d</a>,nC,C,nskip);
00883 <span class="preprocessor"># endif</span>
00884 <span class="preprocessor"></span>}
00885 
00886 
<a name="l00887"></a><a class="code" href="structdLCP.html#dLCPa5">00887</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa5">dLCP::transfer_i_from_C_to_N</a> (<span class="keywordtype">int</span> i)
00888 {
00889   <span class="comment">// remove a row/column from the factorization, and adjust the</span>
00890   <span class="comment">// indexes (black magic!)</span>
00891   <span class="keywordtype">int</span> j,k;
00892   <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <span class="keywordflow">if</span> (C[j]==i) {
00893     dLDLTRemove (A,C,<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo11">d</a>,<a class="code" href="matrix_8c.html#a12">n</a>,nC,j,nskip);
00894     <span class="keywordflow">for</span> (k=0; k&lt;nC; k++) <span class="keywordflow">if</span> (C[k]==nC-1) {
00895       C[k] = C[j];
00896       <span class="keywordflow">if</span> (j &lt; (nC-1)) memmove (C+j,C+j+1,(nC-j-1)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00897       <span class="keywordflow">break</span>;
00898     }
00899     dIASSERT (k &lt; nC);
00900     <span class="keywordflow">break</span>;
00901   }
00902   dIASSERT (j &lt; nC);
00903   swapProblem (A,<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="structdLCP.html#dLCPo6">b</a>,<a class="code" href="structdLCP.html#dLCPo7">w</a>,<a class="code" href="structdLCP.html#dLCPo8">lo</a>,<a class="code" href="structdLCP.html#dLCPo9">hi</a>,p,<a class="code" href="structdLCP.html#dLCPo15">state</a>,<a class="code" href="structdLCP.html#dLCPo16">findex</a>,<a class="code" href="matrix_8c.html#a12">n</a>,i,nC-1,nskip,1);
00904   nC--;
00905   nN++;
00906 
00907 <span class="preprocessor"># ifdef DEBUG_LCP</span>
00908 <span class="preprocessor"></span>  checkFactorization (A,<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo11">d</a>,nC,C,nskip);
00909 <span class="preprocessor"># endif</span>
00910 <span class="preprocessor"></span>}
00911 
00912 
<a name="l00913"></a><a class="code" href="structdLCP.html#dLCPa13">00913</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa13">dLCP::pN_equals_ANC_times_qC</a> (dReal *p, dReal *q)
00914 {
00915   <span class="comment">// we could try to make this matrix-vector multiplication faster using</span>
00916   <span class="comment">// outer product matrix tricks, e.g. with the dMultidotX() functions.</span>
00917   <span class="comment">// but i tried it and it actually made things slower on random 100x100</span>
00918   <span class="comment">// problems because of the overhead involved. so we'll stick with the</span>
00919   <span class="comment">// simple method for now.</span>
00920   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nN; i++) p[i+nC] = dDot (<a class="code" href="lcp_8cpp.html#a3">AROW</a>(i+nC),q,nC);
00921 }
00922 
00923 
<a name="l00924"></a><a class="code" href="structdLCP.html#dLCPa14">00924</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa14">dLCP::pN_plusequals_ANi</a> (dReal *p, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> sign)
00925 {
00926   dReal *aptr = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i)+nC;
00927   <span class="keywordflow">if</span> (sign &gt; 0) {
00928     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nN; i++) p[i+nC] += aptr[i];
00929   }
00930   <span class="keywordflow">else</span> {
00931     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nN; i++) p[i+nC] -= aptr[i];
00932   }
00933 }
00934 
00935 
<a name="l00936"></a><a class="code" href="structdLCP.html#dLCPa17">00936</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa17">dLCP::solve1</a> (dReal *a, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dir)
00937 {
00938   <span class="comment">// the `Dell' and `ell' that are computed here are saved. if index i is</span>
00939   <span class="comment">// later added to the factorization then they can be reused.</span>
00940   <span class="comment">//</span>
00941   <span class="comment">// @@@ question: do we need to solve for entire delta_x??? yes, but</span>
00942   <span class="comment">//     only if an x goes below 0 during the step.</span>
00943 
00944   <span class="keywordtype">int</span> j;
00945   <span class="keywordflow">if</span> (nC &gt; 0) {
00946     dReal *aptr = <a class="code" href="lcp_8cpp.html#a3">AROW</a>(i);
00947 <span class="preprocessor">#   ifdef NUB_OPTIMIZATIONS</span>
00948 <span class="preprocessor"></span>    <span class="comment">// if nub&gt;0, initial part of aptr[] is guaranteed unpermuted</span>
00949     <span class="keywordflow">for</span> (j=0; j&lt;nub; j++) <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] = aptr[j];
00950     <span class="keywordflow">for</span> (j=nub; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] = aptr[C[j]];
00951 <span class="preprocessor">#   else</span>
00952 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] = aptr[C[j]];
00953 <span class="preprocessor">#   endif</span>
00954 <span class="preprocessor"></span>    dSolveL1 (<a class="code" href="structdLCP.html#dLCPo10">L</a>,<a class="code" href="structdLCP.html#dLCPo12">Dell</a>,nC,nskip);
00955     <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="structdLCP.html#dLCPo13">ell</a>[j] = <a class="code" href="structdLCP.html#dLCPo12">Dell</a>[j] * <a class="code" href="structdLCP.html#dLCPo11">d</a>[j];
00956     <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) tmp[j] = <a class="code" href="structdLCP.html#dLCPo13">ell</a>[j];
00957     dSolveL1T (<a class="code" href="structdLCP.html#dLCPo10">L</a>,tmp,nC,nskip);
00958     <span class="keywordflow">if</span> (dir &gt; 0) {
00959       <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="matrix_8c.html#a8">a</a>[C[j]] = -tmp[j];
00960     }
00961     <span class="keywordflow">else</span> {
00962       <span class="keywordflow">for</span> (j=0; j&lt;nC; j++) <a class="code" href="matrix_8c.html#a8">a</a>[C[j]] = tmp[j];
00963     }
00964   }
00965 }
00966 
00967 
<a name="l00968"></a><a class="code" href="structdLCP.html#dLCPa18">00968</a> <span class="keywordtype">void</span> <a class="code" href="structdLCP.html#dLCPa18">dLCP::unpermute</a>()
00969 {
00970   <span class="comment">// now we have to un-permute x and w</span>
00971   <span class="keywordtype">int</span> j;
00972   dReal *tmp = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00973   memcpy (tmp,<a class="code" href="structdLCP.html#dLCPo5">x</a>,<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00974   <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="matrix_8c.html#a12">n</a>; j++) <a class="code" href="structdLCP.html#dLCPo5">x</a>[p[j]] = tmp[j];
00975   memcpy (tmp,<a class="code" href="structdLCP.html#dLCPo7">w</a>,<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00976   <span class="keywordflow">for</span> (j=0; j&lt;<a class="code" href="matrix_8c.html#a12">n</a>; j++) <a class="code" href="structdLCP.html#dLCPo7">w</a>[p[j]] = tmp[j];
00977 }
00978 
00979 <span class="preprocessor">#endif // dLCP_FAST</span>
00980 <span class="preprocessor"></span>
00981 <span class="comment">//***************************************************************************</span>
00982 <span class="comment">// an unoptimized Dantzig LCP driver routine for the basic LCP problem.</span>
00983 <span class="comment">// must have lo=0, hi=dInfinity, and nub=0.</span>
00984 
<a name="l00985"></a><a class="code" href="lcp_8cpp.html#a9">00985</a> <span class="keywordtype">void</span> <a class="code" href="lcp_8cpp.html#a9">dSolveLCPBasic</a> (<span class="keywordtype">int</span> n, dReal *A, dReal *x, dReal *b,
00986                      dReal *w, <span class="keywordtype">int</span> nub, dReal *lo, dReal *hi)
00987 {
00988   dAASSERT (<a class="code" href="matrix_8c.html#a12">n</a>&gt;0 &amp;&amp; A &amp;&amp; <a class="code" href="matrix_8c.html#a13">x</a> &amp;&amp; <a class="code" href="matrix_8c.html#a10">b</a> &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a> &amp;&amp; nub == 0);
00989 
00990   <span class="keywordtype">int</span> i,k;
00991   <span class="keywordtype">int</span> nskip = dPAD(<a class="code" href="matrix_8c.html#a12">n</a>);
00992   dReal *L = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*nskip*<span class="keyword">sizeof</span>(dReal));
00993   dReal *<a class="code" href="matrix_8c.html#a9">d</a> = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00994   dReal *delta_x = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00995   dReal *delta_w = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00996   dReal *Dell = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00997   dReal *ell = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00998   dReal *tmp = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
00999   dReal **Arows = (dReal**) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal*));
01000   <span class="keywordtype">int</span> *p = (<span class="keywordtype">int</span>*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01001   <span class="keywordtype">int</span> *C = (<span class="keywordtype">int</span>*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01002   <span class="keywordtype">int</span> *dummy = (<span class="keywordtype">int</span>*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01003 
01004   <a class="code" href="structdLCP.html">dLCP</a> lcp (<a class="code" href="matrix_8c.html#a12">n</a>,0,A,<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a10">b</a>,<a class="code" href="matrix_8c.html#a11">w</a>,tmp,tmp,L,<a class="code" href="matrix_8c.html#a9">d</a>,Dell,ell,tmp,dummy,dummy,p,C,Arows);
01005   nub = lcp.<a class="code" href="structdLCP.html#dLCPa1">getNub</a>();
01006 
01007   <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
01008     <a class="code" href="matrix_8c.html#a11">w</a>[i] = lcp.<a class="code" href="structdLCP.html#dLCPa11">AiC_times_qC</a> (i,<a class="code" href="matrix_8c.html#a13">x</a>) - <a class="code" href="matrix_8c.html#a10">b</a>[i];
01009     <span class="keywordflow">if</span> (<a class="code" href="matrix_8c.html#a11">w</a>[i] &gt;= 0) {
01010       lcp.<a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (i);
01011     }
01012     <span class="keywordflow">else</span> {
01013       <span class="keywordflow">for</span> (;;) {
01014         <span class="comment">// compute: delta_x(C) = -A(C,C)\A(C,i)</span>
01015         dSetZero (delta_x,<a class="code" href="matrix_8c.html#a12">n</a>);
01016         lcp.<a class="code" href="structdLCP.html#dLCPa17">solve1</a> (delta_x,i);
01017         delta_x[i] = 1;
01018 
01019         <span class="comment">// compute: delta_w = A*delta_x</span>
01020         dSetZero (delta_w,<a class="code" href="matrix_8c.html#a12">n</a>);
01021         lcp.<a class="code" href="structdLCP.html#dLCPa13">pN_equals_ANC_times_qC</a> (delta_w,delta_x);
01022         lcp.<a class="code" href="structdLCP.html#dLCPa14">pN_plusequals_ANi</a> (delta_w,i);
01023         delta_w[i] = lcp.<a class="code" href="structdLCP.html#dLCPa11">AiC_times_qC</a> (i,delta_x) + lcp.<a class="code" href="structdLCP.html#dLCPa10">Aii</a>(i);
01024 
01025         <span class="comment">// find index to switch</span>
01026         <span class="keywordtype">int</span> si = i;             <span class="comment">// si = switch index</span>
01027         <span class="keywordtype">int</span> si_in_N = 0;        <span class="comment">// set to 1 if si in N</span>
01028         dReal s = -<a class="code" href="matrix_8c.html#a11">w</a>[i]/delta_w[i];
01029 
01030         <span class="keywordflow">if</span> (s &lt;= 0) {
01031           dMessage (d_ERR_LCP, <span class="stringliteral">"LCP internal error, s &lt;= 0 (s=%.4e)"</span>,s);
01032           <span class="keywordflow">if</span> (i &lt; (<a class="code" href="matrix_8c.html#a12">n</a>-1)) {
01033             dSetZero (<a class="code" href="matrix_8c.html#a13">x</a>+i,<a class="code" href="matrix_8c.html#a12">n</a>-i);
01034             dSetZero (<a class="code" href="matrix_8c.html#a11">w</a>+i,<a class="code" href="matrix_8c.html#a12">n</a>-i);
01035           }
01036           <span class="keywordflow">goto</span> done;
01037         }
01038 
01039         <span class="keywordflow">for</span> (k=0; k &lt; lcp.<a class="code" href="structdLCP.html#dLCPa7">numN</a>(); k++) {
01040           <span class="keywordflow">if</span> (delta_w[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] &lt; 0) {
01041             dReal s2 = -<a class="code" href="matrix_8c.html#a11">w</a>[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] / delta_w[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)];
01042             <span class="keywordflow">if</span> (s2 &lt; s) {
01043               s = s2;
01044               si = lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k);
01045               si_in_N = 1;
01046             }
01047           }
01048         }
01049         <span class="keywordflow">for</span> (k=0; k &lt; lcp.<a class="code" href="structdLCP.html#dLCPa6">numC</a>(); k++) {
01050           <span class="keywordflow">if</span> (delta_x[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)] &lt; 0) {
01051             dReal s2 = -<a class="code" href="matrix_8c.html#a13">x</a>[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)] / delta_x[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)];
01052             <span class="keywordflow">if</span> (s2 &lt; s) {
01053               s = s2;
01054               si = lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k);
01055               si_in_N = 0;
01056             }
01057           }
01058         }
01059 
01060         <span class="comment">// apply x = x + s * delta_x</span>
01061         lcp.<a class="code" href="structdLCP.html#dLCPa15">pC_plusequals_s_times_qC</a> (<a class="code" href="matrix_8c.html#a13">x</a>,s,delta_x);
01062         <a class="code" href="matrix_8c.html#a13">x</a>[i] += s;
01063         lcp.<a class="code" href="structdLCP.html#dLCPa16">pN_plusequals_s_times_qN</a> (<a class="code" href="matrix_8c.html#a11">w</a>,s,delta_w);
01064         <a class="code" href="matrix_8c.html#a11">w</a>[i] += s * delta_w[i];
01065 
01066         <span class="comment">// switch indexes between sets if necessary</span>
01067         <span class="keywordflow">if</span> (si==i) {
01068           <a class="code" href="matrix_8c.html#a11">w</a>[i] = 0;
01069           lcp.<a class="code" href="structdLCP.html#dLCPa2">transfer_i_to_C</a> (i);
01070           <span class="keywordflow">break</span>;
01071         }
01072         <span class="keywordflow">if</span> (si_in_N) {
01073           <a class="code" href="matrix_8c.html#a11">w</a>[si] = 0;
01074           lcp.<a class="code" href="structdLCP.html#dLCPa4">transfer_i_from_N_to_C</a> (si);
01075         }
01076         <span class="keywordflow">else</span> {
01077           <a class="code" href="matrix_8c.html#a13">x</a>[si] = 0;
01078           lcp.<a class="code" href="structdLCP.html#dLCPa5">transfer_i_from_C_to_N</a> (si);
01079         }
01080       }
01081     }
01082   }
01083 
01084  done:
01085   lcp.<a class="code" href="structdLCP.html#dLCPa18">unpermute</a>();
01086 }
01087 
01088 <span class="comment">//***************************************************************************</span>
01089 <span class="comment">// an optimized Dantzig LCP driver routine for the lo-hi LCP problem.</span>
01090 
<a name="l01091"></a><a class="code" href="lcp_8cpp.html#a10">01091</a> <span class="keywordtype">void</span> <a class="code" href="lcp_8cpp.html#a10">dSolveLCP</a> (<span class="keywordtype">int</span> n, dReal *A, dReal *x, dReal *b,
01092                 dReal *w, <span class="keywordtype">int</span> nub, dReal *lo, dReal *hi, <span class="keywordtype">int</span> *findex)
01093 {
01094   dAASSERT (<a class="code" href="matrix_8c.html#a12">n</a>&gt;0 &amp;&amp; A &amp;&amp; <a class="code" href="matrix_8c.html#a13">x</a> &amp;&amp; <a class="code" href="matrix_8c.html#a10">b</a> &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a> &amp;&amp; lo &amp;&amp; hi &amp;&amp; nub &gt;= 0 &amp;&amp; nub &lt;= <a class="code" href="matrix_8c.html#a12">n</a>);
01095   <span class="keywordtype">int</span> i,k,hit_first_friction_index = 0;
01096   <span class="keywordtype">int</span> nskip = dPAD(<a class="code" href="matrix_8c.html#a12">n</a>);
01097 
01098   <span class="comment">// if all the variables are unbounded then we can just factor, solve,</span>
01099   <span class="comment">// and return</span>
01100   <span class="keywordflow">if</span> (nub &gt;= <a class="code" href="matrix_8c.html#a12">n</a>) {
01101     dFactorLDLT (A,<a class="code" href="matrix_8c.html#a11">w</a>,<a class="code" href="matrix_8c.html#a12">n</a>,nskip);          <span class="comment">// use w for d</span>
01102     dSolveLDLT (A,<a class="code" href="matrix_8c.html#a11">w</a>,<a class="code" href="matrix_8c.html#a10">b</a>,<a class="code" href="matrix_8c.html#a12">n</a>,nskip);
01103     memcpy (<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a10">b</a>,<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01104     dSetZero (<a class="code" href="matrix_8c.html#a11">w</a>,<a class="code" href="matrix_8c.html#a12">n</a>);
01105     <span class="keywordflow">return</span>;
01106   }
01107 
01108 <span class="preprocessor"># ifndef dNODEBUG</span>
01109 <span class="preprocessor"></span>  <span class="comment">// check restrictions on lo and hi</span>
01110   <span class="keywordflow">for</span> (k=0; k&lt;n; k++) dIASSERT (lo[k] &lt;= 0 &amp;&amp; hi[k] &gt;= 0);
01111 <span class="preprocessor"># endif</span>
01112 <span class="preprocessor"></span>
01113   dReal *L = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*nskip*<span class="keyword">sizeof</span>(dReal));
01114   dReal *<a class="code" href="matrix_8c.html#a9">d</a> = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01115   dReal *delta_x = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01116   dReal *delta_w = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01117   dReal *Dell = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01118   dReal *ell = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01119   dReal **Arows = (dReal**) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal*));
01120   <span class="keywordtype">int</span> *p = (<span class="keywordtype">int</span>*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01121   <span class="keywordtype">int</span> *C = (<span class="keywordtype">int</span>*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01122   <span class="keywordtype">int</span> dir;
01123   dReal dirf;
01124 
01125   <span class="comment">// for i in N, state[i] is 0 if x(i)==lo(i) or 1 if x(i)==hi(i)</span>
01126   <span class="keywordtype">int</span> *state = (<span class="keywordtype">int</span>*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01127 
01128   <span class="comment">// create LCP object. note that tmp is set to delta_w to save space, this</span>
01129   <span class="comment">// optimization relies on knowledge of how tmp is used, so be careful!</span>
01130   <a class="code" href="structdLCP.html">dLCP</a> lcp (<a class="code" href="matrix_8c.html#a12">n</a>,nub,A,<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a10">b</a>,<a class="code" href="matrix_8c.html#a11">w</a>,lo,hi,L,<a class="code" href="matrix_8c.html#a9">d</a>,Dell,ell,delta_w,state,findex,p,C,Arows);
01131   nub = lcp.<a class="code" href="structdLCP.html#dLCPa1">getNub</a>();
01132 
01133   <span class="comment">// loop over all indexes nub..n-1. for index i, if x(i),w(i) satisfy the</span>
01134   <span class="comment">// LCP conditions then i is added to the appropriate index set. otherwise</span>
01135   <span class="comment">// x(i),w(i) is driven either +ve or -ve to force it to the valid region.</span>
01136   <span class="comment">// as we drive x(i), x(C) is also adjusted to keep w(C) at zero.</span>
01137   <span class="comment">// while driving x(i) we maintain the LCP conditions on the other variables</span>
01138   <span class="comment">// 0..i-1. we do this by watching out for other x(i),w(i) values going</span>
01139   <span class="comment">// outside the valid region, and then switching them between index sets</span>
01140   <span class="comment">// when that happens.</span>
01141 
01142   <span class="keywordflow">for</span> (i=nub; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
01143     <span class="comment">// the index i is the driving index and indexes i+1..n-1 are "dont care",</span>
01144     <span class="comment">// i.e. when we make changes to the system those x's will be zero and we</span>
01145     <span class="comment">// don't care what happens to those w's. in other words, we only consider</span>
01146     <span class="comment">// an (i+1)*(i+1) sub-problem of A*x=b+w.</span>
01147 
01148     <span class="comment">// if we've hit the first friction index, we have to compute the lo and</span>
01149     <span class="comment">// hi values based on the values of x already computed. we have been</span>
01150     <span class="comment">// permuting the indexes, so the values stored in the findex vector are</span>
01151     <span class="comment">// no longer valid. thus we have to temporarily unpermute the x vector. </span>
01152     <span class="keywordflow">if</span> (hit_first_friction_index == 0 &amp;&amp; findex &amp;&amp; findex[i] &gt;= 0) {
01153       <span class="comment">// un-permute x into delta_w, which is not being used at the moment</span>
01154       <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) delta_w[p[k]] = <a class="code" href="matrix_8c.html#a13">x</a>[k];
01155       <span class="comment">// set lo and hi values</span>
01156       <span class="keywordflow">for</span> (k=i; k&lt;<a class="code" href="matrix_8c.html#a12">n</a>; k++) {
01157         hi[k] = dFabs (hi[k] * delta_w[findex[k]]);
01158         lo[k] = -hi[k];
01159       }
01160       hit_first_friction_index = 1;
01161     }
01162 
01163     <span class="comment">// thus far we have not even been computing the w values for indexes</span>
01164     <span class="comment">// greater than i, so compute w[i] now.</span>
01165     <a class="code" href="matrix_8c.html#a11">w</a>[i] = lcp.<a class="code" href="structdLCP.html#dLCPa11">AiC_times_qC</a> (i,<a class="code" href="matrix_8c.html#a13">x</a>) + lcp.<a class="code" href="structdLCP.html#dLCPa12">AiN_times_qN</a> (i,<a class="code" href="matrix_8c.html#a13">x</a>) - <a class="code" href="matrix_8c.html#a10">b</a>[i];
01166 
01167     <span class="comment">// if lo=hi=0 (which can happen for tangential friction when normals are</span>
01168     <span class="comment">// 0) then the index will be assigned to set N with some state. however,</span>
01169     <span class="comment">// set C's line has zero size, so the index will always remain in set N.</span>
01170     <span class="comment">// with the "normal" switching logic, if w changed sign then the index</span>
01171     <span class="comment">// would have to switch to set C and then back to set N with an inverted</span>
01172     <span class="comment">// state. this is pointless, and also computationally expensive. to</span>
01173     <span class="comment">// prevent this from happening, we use the rule that indexes with lo=hi=0</span>
01174     <span class="comment">// will never be checked for set changes. this means that the state for</span>
01175     <span class="comment">// these indexes may be incorrect, but that doesn't matter.</span>
01176 
01177     <span class="comment">// see if x(i),w(i) is in a valid region</span>
01178     <span class="keywordflow">if</span> (lo[i]==0 &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a>[i] &gt;= 0) {
01179       lcp.<a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (i);
01180       state[i] = 0;
01181     }
01182     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hi[i]==0 &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a>[i] &lt;= 0) {
01183       lcp.<a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (i);
01184       state[i] = 1;
01185     }
01186     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="matrix_8c.html#a11">w</a>[i]==0) {
01187       <span class="comment">// this is a degenerate case. by the time we get to this test we know</span>
01188       <span class="comment">// that lo != 0, which means that lo &lt; 0 as lo is not allowed to be +ve,</span>
01189       <span class="comment">// and similarly that hi &gt; 0. this means that the line segment</span>
01190       <span class="comment">// corresponding to set C is at least finite in extent, and we are on it.</span>
01191       lcp.<a class="code" href="structdLCP.html#dLCPa2">transfer_i_to_C</a> (i);
01192     }
01193     <span class="keywordflow">else</span> {
01194       <span class="comment">// we must push x(i) and w(i)</span>
01195       <span class="keywordflow">for</span> (;;) {
01196         <span class="comment">// find direction to push on x(i)</span>
01197         <span class="keywordflow">if</span> (<a class="code" href="matrix_8c.html#a11">w</a>[i] &lt;= 0) {
01198           dir = 1;
01199           dirf = REAL(1.0);
01200         }
01201         <span class="keywordflow">else</span> {
01202           dir = -1;
01203           dirf = REAL(-1.0);
01204         }
01205 
01206         <span class="comment">// compute: delta_x(C) = -dir*A(C,C)\A(C,i)</span>
01207         lcp.<a class="code" href="structdLCP.html#dLCPa17">solve1</a> (delta_x,i,dir);
01208         <span class="comment">// note that delta_x[i] = dirf, but we wont bother to set it</span>
01209 
01210         <span class="comment">// compute: delta_w = A*delta_x ... note we only care about</span>
01211         <span class="comment">// delta_w(N) and delta_w(i), the rest is ignored</span>
01212         lcp.<a class="code" href="structdLCP.html#dLCPa13">pN_equals_ANC_times_qC</a> (delta_w,delta_x);
01213         lcp.<a class="code" href="structdLCP.html#dLCPa14">pN_plusequals_ANi</a> (delta_w,i,dir);
01214         delta_w[i] = lcp.<a class="code" href="structdLCP.html#dLCPa11">AiC_times_qC</a> (i,delta_x) + lcp.<a class="code" href="structdLCP.html#dLCPa10">Aii</a>(i)*dirf;
01215 
01216         <span class="comment">// find largest step we can take (size=s), either to drive x(i),w(i)</span>
01217         <span class="comment">// to the valid LCP region or to drive an already-valid variable</span>
01218         <span class="comment">// outside the valid region.</span>
01219 
01220         <span class="keywordtype">int</span> cmd = 1;            <span class="comment">// index switching command</span>
01221         <span class="keywordtype">int</span> si = 0;             <span class="comment">// si = index to switch if cmd&gt;3</span>
01222         dReal s = -<a class="code" href="matrix_8c.html#a11">w</a>[i]/delta_w[i];
01223         <span class="keywordflow">if</span> (dir &gt; 0) {
01224           <span class="keywordflow">if</span> (hi[i] &lt; dInfinity) {
01225             dReal s2 = (hi[i]-<a class="code" href="matrix_8c.html#a13">x</a>[i])/dirf;               <span class="comment">// step to x(i)=hi(i)</span>
01226             <span class="keywordflow">if</span> (s2 &lt; s) {
01227               s = s2;
01228               cmd = 3;
01229             }
01230           }
01231         }
01232         <span class="keywordflow">else</span> {
01233           <span class="keywordflow">if</span> (lo[i] &gt; -dInfinity) {
01234             dReal s2 = (lo[i]-<a class="code" href="matrix_8c.html#a13">x</a>[i])/dirf;               <span class="comment">// step to x(i)=lo(i)</span>
01235             <span class="keywordflow">if</span> (s2 &lt; s) {
01236               s = s2;
01237               cmd = 2;
01238             }
01239           }
01240         }
01241 
01242         <span class="keywordflow">for</span> (k=0; k &lt; lcp.<a class="code" href="structdLCP.html#dLCPa7">numN</a>(); k++) {
01243           <span class="keywordflow">if</span> ((state[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)]==0 &amp;&amp; delta_w[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] &lt; 0) ||
01244               (state[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)]!=0 &amp;&amp; delta_w[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] &gt; 0)) {
01245             <span class="comment">// don't bother checking if lo=hi=0</span>
01246             <span class="keywordflow">if</span> (lo[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] == 0 &amp;&amp; hi[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] == 0) <span class="keywordflow">continue</span>;
01247             dReal s2 = -<a class="code" href="matrix_8c.html#a11">w</a>[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)] / delta_w[lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k)];
01248             <span class="keywordflow">if</span> (s2 &lt; s) {
01249               s = s2;
01250               cmd = 4;
01251               si = lcp.<a class="code" href="structdLCP.html#dLCPa9">indexN</a>(k);
01252             }
01253           }
01254         }
01255 
01256         <span class="keywordflow">for</span> (k=nub; k &lt; lcp.<a class="code" href="structdLCP.html#dLCPa6">numC</a>(); k++) {
01257           <span class="keywordflow">if</span> (delta_x[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)] &lt; 0 &amp;&amp; lo[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)] &gt; -dInfinity) {
01258             dReal s2 = (lo[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)]-<a class="code" href="matrix_8c.html#a13">x</a>[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)]) /
01259               delta_x[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)];
01260             <span class="keywordflow">if</span> (s2 &lt; s) {
01261               s = s2;
01262               cmd = 5;
01263               si = lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k);
01264             }
01265           }
01266           <span class="keywordflow">if</span> (delta_x[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)] &gt; 0 &amp;&amp; hi[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)] &lt; dInfinity) {
01267             dReal s2 = (hi[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)]-<a class="code" href="matrix_8c.html#a13">x</a>[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)]) /
01268               delta_x[lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k)];
01269             <span class="keywordflow">if</span> (s2 &lt; s) {
01270               s = s2;
01271               cmd = 6;
01272               si = lcp.<a class="code" href="structdLCP.html#dLCPa8">indexC</a>(k);
01273             }
01274           }
01275         }
01276 
01277         <span class="comment">//static char* cmdstring[8] = {0,"-&gt;C","-&gt;NL","-&gt;NH","N-&gt;C",</span>
01278         <span class="comment">//                           "C-&gt;NL","C-&gt;NH"};</span>
01279         <span class="comment">//printf ("cmd=%d (%s), si=%d\n",cmd,cmdstring[cmd],(cmd&gt;3) ? si : i);</span>
01280 
01281         <span class="comment">// if s &lt;= 0 then we've got a problem. if we just keep going then</span>
01282         <span class="comment">// we're going to get stuck in an infinite loop. instead, just cross</span>
01283         <span class="comment">// our fingers and exit with the current solution.</span>
01284         <span class="keywordflow">if</span> (s &lt;= 0) {
01285           dMessage (d_ERR_LCP, <span class="stringliteral">"LCP internal error, s &lt;= 0 (s=%.4e)"</span>,s);
01286           <span class="keywordflow">if</span> (i &lt; (<a class="code" href="matrix_8c.html#a12">n</a>-1)) {
01287             dSetZero (<a class="code" href="matrix_8c.html#a13">x</a>+i,<a class="code" href="matrix_8c.html#a12">n</a>-i);
01288             dSetZero (<a class="code" href="matrix_8c.html#a11">w</a>+i,<a class="code" href="matrix_8c.html#a12">n</a>-i);
01289           }
01290           <span class="keywordflow">goto</span> done;
01291         }
01292 
01293         <span class="comment">// apply x = x + s * delta_x</span>
01294         lcp.<a class="code" href="structdLCP.html#dLCPa15">pC_plusequals_s_times_qC</a> (<a class="code" href="matrix_8c.html#a13">x</a>,s,delta_x);
01295         <a class="code" href="matrix_8c.html#a13">x</a>[i] += s * dirf;
01296 
01297         <span class="comment">// apply w = w + s * delta_w</span>
01298         lcp.<a class="code" href="structdLCP.html#dLCPa16">pN_plusequals_s_times_qN</a> (<a class="code" href="matrix_8c.html#a11">w</a>,s,delta_w);
01299         <a class="code" href="matrix_8c.html#a11">w</a>[i] += s * delta_w[i];
01300 
01301         <span class="comment">// switch indexes between sets if necessary</span>
01302         <span class="keywordflow">switch</span> (cmd) {
01303         <span class="keywordflow">case</span> 1:         <span class="comment">// done</span>
01304           <a class="code" href="matrix_8c.html#a11">w</a>[i] = 0;
01305           lcp.<a class="code" href="structdLCP.html#dLCPa2">transfer_i_to_C</a> (i);
01306           <span class="keywordflow">break</span>;
01307         <span class="keywordflow">case</span> 2:         <span class="comment">// done</span>
01308           <a class="code" href="matrix_8c.html#a13">x</a>[i] = lo[i];
01309           state[i] = 0;
01310           lcp.<a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (i);
01311           <span class="keywordflow">break</span>;
01312         <span class="keywordflow">case</span> 3:         <span class="comment">// done</span>
01313           <a class="code" href="matrix_8c.html#a13">x</a>[i] = hi[i];
01314           state[i] = 1;
01315           lcp.<a class="code" href="structdLCP.html#dLCPa3">transfer_i_to_N</a> (i);
01316           <span class="keywordflow">break</span>;
01317         <span class="keywordflow">case</span> 4:         <span class="comment">// keep going</span>
01318           <a class="code" href="matrix_8c.html#a11">w</a>[si] = 0;
01319           lcp.<a class="code" href="structdLCP.html#dLCPa4">transfer_i_from_N_to_C</a> (si);
01320           <span class="keywordflow">break</span>;
01321         <span class="keywordflow">case</span> 5:         <span class="comment">// keep going</span>
01322           <a class="code" href="matrix_8c.html#a13">x</a>[si] = lo[si];
01323           state[si] = 0;
01324           lcp.<a class="code" href="structdLCP.html#dLCPa5">transfer_i_from_C_to_N</a> (si);
01325           <span class="keywordflow">break</span>;
01326         <span class="keywordflow">case</span> 6:         <span class="comment">// keep going</span>
01327           <a class="code" href="matrix_8c.html#a13">x</a>[si] = hi[si];
01328           state[si] = 1;
01329           lcp.<a class="code" href="structdLCP.html#dLCPa5">transfer_i_from_C_to_N</a> (si);
01330           <span class="keywordflow">break</span>;
01331         }
01332 
01333         <span class="keywordflow">if</span> (cmd &lt;= 3) <span class="keywordflow">break</span>;
01334       }
01335     }
01336   }
01337 
01338  done:
01339   lcp.<a class="code" href="structdLCP.html#dLCPa18">unpermute</a>();
01340 }
01341 
01342 <span class="comment">//***************************************************************************</span>
01343 <span class="comment">// accuracy and timing test</span>
01344 
<a name="l01345"></a><a class="code" href="lcp_8cpp.html#a11">01345</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <span class="keywordtype">void</span> <a class="code" href="lcp_8cpp.html#a11">dTestSolveLCP</a>()
01346 {
01347   <span class="keywordtype">int</span> <a class="code" href="matrix_8c.html#a12">n</a> = 100;
01348   <span class="keywordtype">int</span> i,nskip = dPAD(<a class="code" href="matrix_8c.html#a12">n</a>);
01349   <span class="keyword">const</span> dReal tol = 1e-9;
01350   printf (<span class="stringliteral">"dTestSolveLCP()\n"</span>);
01351 
01352   dReal *A = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*nskip*<span class="keyword">sizeof</span>(dReal));
01353   dReal *<a class="code" href="matrix_8c.html#a13">x</a> = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01354   dReal *<a class="code" href="matrix_8c.html#a10">b</a> = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01355   dReal *<a class="code" href="matrix_8c.html#a11">w</a> = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01356   dReal *lo = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01357   dReal *hi = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01358 
01359   dReal *A2 = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*nskip*<span class="keyword">sizeof</span>(dReal));
01360   dReal *b2 = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01361   dReal *lo2 = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01362   dReal *hi2 = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01363   dReal *tmp1 = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01364   dReal *tmp2 = (dReal*) <a class="code" href="lcp_8cpp.html#a4">ALLOCA</a> (<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01365 
01366   <span class="keywordtype">double</span> total_time = 0;
01367   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> count=0; count &lt; 1000; count++) {
01368 
01369     <span class="comment">// form (A,b) = a random positive definite LCP problem</span>
01370     dMakeRandomMatrix (A2,<a class="code" href="matrix_8c.html#a12">n</a>,<a class="code" href="matrix_8c.html#a12">n</a>,1.0);
01371     dMultiply2 (A,A2,A2,<a class="code" href="matrix_8c.html#a12">n</a>,<a class="code" href="matrix_8c.html#a12">n</a>,<a class="code" href="matrix_8c.html#a12">n</a>);
01372     dMakeRandomMatrix (<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a12">n</a>,1,1.0);
01373     dMultiply0 (<a class="code" href="matrix_8c.html#a10">b</a>,A,<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a12">n</a>,<a class="code" href="matrix_8c.html#a12">n</a>,1);
01374     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) <a class="code" href="matrix_8c.html#a10">b</a>[i] += (dRandReal()*0.2)-0.1;
01375 
01376     <span class="comment">// choose `nub' in the range 0..n-1</span>
01377     <span class="keywordtype">int</span> nub = 50; <span class="comment">//dRandInt (n);</span>
01378 
01379     <span class="comment">// make limits</span>
01380     <span class="keywordflow">for</span> (i=0; i&lt;nub; i++) lo[i] = -dInfinity;
01381     <span class="keywordflow">for</span> (i=0; i&lt;nub; i++) hi[i] = dInfinity;
01382     <span class="comment">//for (i=nub; i&lt;n; i++) lo[i] = 0;</span>
01383     <span class="comment">//for (i=nub; i&lt;n; i++) hi[i] = dInfinity;</span>
01384     <span class="comment">//for (i=nub; i&lt;n; i++) lo[i] = -dInfinity;</span>
01385     <span class="comment">//for (i=nub; i&lt;n; i++) hi[i] = 0;</span>
01386     <span class="keywordflow">for</span> (i=nub; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) lo[i] = -(dRandReal()*1.0)-0.01;
01387     <span class="keywordflow">for</span> (i=nub; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) hi[i] =  (dRandReal()*1.0)+0.01;
01388 
01389     <span class="comment">// set a few limits to lo=hi=0</span>
01390     <span class="comment">/*</span>
01391 <span class="comment">    for (i=0; i&lt;10; i++) {</span>
01392 <span class="comment">      int j = dRandInt (n-nub) + nub;</span>
01393 <span class="comment">      lo[j] = 0;</span>
01394 <span class="comment">      hi[j] = 0;</span>
01395 <span class="comment">    }</span>
01396 <span class="comment">    */</span>
01397 
01398     <span class="comment">// solve the LCP. we must make copy of A,b,lo,hi (A2,b2,lo2,hi2) for</span>
01399     <span class="comment">// SolveLCP() to permute. also, we'll clear the upper triangle of A2 to</span>
01400     <span class="comment">// ensure that it doesn't get referenced (if it does, the answer will be</span>
01401     <span class="comment">// wrong).</span>
01402 
01403     memcpy (A2,A,<a class="code" href="matrix_8c.html#a12">n</a>*nskip*<span class="keyword">sizeof</span>(dReal));
01404     dClearUpperTriangle (A2,<a class="code" href="matrix_8c.html#a12">n</a>);
01405     memcpy (b2,<a class="code" href="matrix_8c.html#a10">b</a>,<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01406     memcpy (lo2,lo,<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01407     memcpy (hi2,hi,<a class="code" href="matrix_8c.html#a12">n</a>*<span class="keyword">sizeof</span>(dReal));
01408     dSetZero (<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a12">n</a>);
01409     dSetZero (<a class="code" href="matrix_8c.html#a11">w</a>,<a class="code" href="matrix_8c.html#a12">n</a>);
01410 
01411     dStopwatch sw;
01412     dStopwatchReset (&amp;sw);
01413     dStopwatchStart (&amp;sw);
01414 
01415     <a class="code" href="lcp_8cpp.html#a10">dSolveLCP</a> (<a class="code" href="matrix_8c.html#a12">n</a>,A2,<a class="code" href="matrix_8c.html#a13">x</a>,b2,<a class="code" href="matrix_8c.html#a11">w</a>,nub,lo2,hi2,0);
01416 
01417     dStopwatchStop (&amp;sw);
01418     <span class="keywordtype">double</span> time = dStopwatchTime(&amp;sw);
01419     total_time += time;
01420     <span class="keywordtype">double</span> average = total_time / double(count+1) * 1000.0;
01421 
01422     <span class="comment">// check the solution</span>
01423 
01424     dMultiply0 (tmp1,A,<a class="code" href="matrix_8c.html#a13">x</a>,<a class="code" href="matrix_8c.html#a12">n</a>,<a class="code" href="matrix_8c.html#a12">n</a>,1);
01425     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) tmp2[i] = <a class="code" href="matrix_8c.html#a10">b</a>[i] + <a class="code" href="matrix_8c.html#a11">w</a>[i];
01426     dReal diff = dMaxDifference (tmp1,tmp2,<a class="code" href="matrix_8c.html#a12">n</a>,1);
01427     <span class="comment">// printf ("\tA*x = b+w, maximum difference = %.6e - %s (1)\n",diff,</span>
01428     <span class="comment">//      diff &gt; tol ? "FAILED" : "passed");</span>
01429     <span class="keywordflow">if</span> (diff &gt; tol) dDebug (0,<span class="stringliteral">"A*x = b+w, maximum difference = %.6e"</span>,diff);
01430     <span class="keywordtype">int</span> n1=0,n2=0,n3=0;
01431     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="matrix_8c.html#a12">n</a>; i++) {
01432       <span class="keywordflow">if</span> (<a class="code" href="matrix_8c.html#a13">x</a>[i]==lo[i] &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a>[i] &gt;= 0) {
01433         n1++;   <span class="comment">// ok</span>
01434       }
01435       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="matrix_8c.html#a13">x</a>[i]==hi[i] &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a>[i] &lt;= 0) {
01436         n2++;   <span class="comment">// ok</span>
01437       }
01438       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="matrix_8c.html#a13">x</a>[i] &gt;= lo[i] &amp;&amp; <a class="code" href="matrix_8c.html#a13">x</a>[i] &lt;= hi[i] &amp;&amp; <a class="code" href="matrix_8c.html#a11">w</a>[i] == 0) {
01439         n3++;   <span class="comment">// ok</span>
01440       }
01441       <span class="keywordflow">else</span> {
01442         dDebug (0,<span class="stringliteral">"FAILED: i=%d x=%.4e w=%.4e lo=%.4e hi=%.4e"</span>,i,
01443                 <a class="code" href="matrix_8c.html#a13">x</a>[i],<a class="code" href="matrix_8c.html#a11">w</a>[i],lo[i],hi[i]);
01444       }
01445     }
01446 
01447     <span class="comment">// pacifier</span>
01448     printf (<span class="stringliteral">"passed: NL=%3d NH=%3d C=%3d   "</span>,n1,n2,n3);
01449     printf (<span class="stringliteral">"time=%10.3f ms  avg=%10.4f\n"</span>,time * 1000.0,average);
01450   }
01451 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jan 17 14:00:06 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
