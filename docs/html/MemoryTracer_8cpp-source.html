<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenSim: base/MemoryTracer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>base/MemoryTracer.cpp</h1><a href="MemoryTracer_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">  Copyright (C)1996 David Jung &lt;opensim@pobox.com&gt;</span>
00003 <span class="comment"></span>
00004 <span class="comment">  This program/file is free software; you can redistribute it and/or modify</span>
00005 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment">  (at your option) any later version.</span>
00008 <span class="comment">  </span>
00009 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment">  GNU General Public License for more details. (http://www.gnu.org)</span>
00013 <span class="comment">  </span>
00014 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment">  along with this program; if not, write to the Free Software</span>
00016 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00017 <span class="comment">  </span>
00018 <span class="comment">  $Id: MemoryTracer.cpp 1048 2004-02-27 19:22:02Z jungd $</span>
00019 <span class="comment">  $Revision: 1.4 $</span>
00020 <span class="comment">  $Date: 2004-02-27 14:22:02 -0500 (Fri, 27 Feb 2004) $</span>
00021 <span class="comment">  $Author: jungd $</span>
00022 <span class="comment"> </span>
00023 <span class="comment">****************************************************************************/</span>
00024 
00025 <span class="preprocessor">#include &lt;<a class="code" href="MemoryTracer.html">base/MemoryTracer</a>&gt;</span>
00026 
00027 <span class="preprocessor">#include &lt;string&gt;</span>
00028 <span class="preprocessor">#include &lt;iostream&gt;</span>
00029 
00030 <span class="keyword">using</span> std::string;
00031 
00032 <span class="keyword">using</span> <a class="code" href="classbase_1_1MemoryTracer.html">base::MemoryTracer</a>;
00033 
00034 
00035 
00036 <span class="comment">// if defined, will cause a menu to be displayed when a memory problem is</span>
00037 <span class="comment">//  detected (stopping the program)</span>
<a name="l00038"></a><a class="code" href="MemoryTracer_8cpp.html#a0">00038</a> <span class="preprocessor">#define _INTERACTIVE_ </span>
00039 <span class="preprocessor"></span>
00040 <span class="comment">// if defined and not _INTERACTIVE_, then a memory problem will throw a</span>
00041 <span class="comment">//  std::bad_alloc exception (possibly from within new or delete)</span>
<a name="l00042"></a><a class="code" href="MemoryTracer_8cpp.html#a1">00042</a> <span class="preprocessor">#define _THROWEXCEPTION_</span>
00043 <span class="preprocessor"></span>
00044 <span class="comment">// if defined, calls to allocate, validate, release &amp; invalidate will report arguments (on every call)</span>
00045 <span class="comment">//  (even more verbose that using _TRACEOUTPUT_ )</span>
00046 <span class="comment">//#define _MEMORYTRACEDEBUG_</span>
00047 
00048 
00049 
00050 <a class="code" href="namespacebase.html#a0">base::Byte</a> MemoryTracer::prefill[MemoryTracer::Filling]; <span class="comment">// Filler for integrity check</span>
00051 <a class="code" href="namespacebase.html#a0">base::Byte</a> MemoryTracer::initialized = 0;
00052 <span class="keywordtype">bool</span> MemoryTracer::cleanedUp = <span class="keyword">false</span>;
00053 Int MemoryTracer::entry = 0;
00054 Int MemoryTracer::fullCheckCounter = 0;
00055 <a class="code" href="namespacebase.html#a3">base::LInt</a> MemoryTracer::allocCount = 0;
00056 <a class="code" href="namespacebase.html#a3">base::LInt</a> MemoryTracer::deallocCount = 0;
00057 <a class="code" href="namespacebase.html#a3">base::LInt</a> MemoryTracer::checkCount = 0;
00058 MemoryTracer::AllocList MemoryTracer::mlist; <span class="comment">// the allocated memory list</span>
00059 MemoryTracer::AllocList MemoryTracer::dlist; <span class="comment">// list of memory allocated and then deallocated (so we can catch double delete's)</span>
00060 <a class="code" href="namespacebase.html#a0">base::Byte</a> MemoryTracer::postfill[Filling]; <span class="comment">// Filler for integrity check</span>
00061 
00062 <span class="keyword">const</span> <span class="keywordtype">int</span> MemoryTracer::IsArray = 0xabcd;
00063 <span class="keyword">const</span> <span class="keywordtype">int</span> MemoryTracer::IsNotArray = 0xfcad;
00064 
00065 <span class="keyword">inline</span> <span class="keywordtype">void</span> MemoryTracer::Logerr(<span class="keywordtype">char</span>* errstr) 
00066 {
00067   <span class="comment">// can't use base's Logln because that uses iostreams (which need new/delete)</span>
00068   <span class="keywordtype">char</span> str[256];
00069   sprintf(str,<span class="stringliteral">"MemoryTracer Log: %s\n"</span>,errstr);
00070   fprintf(stderr,str);
00071 }
00072 
00073 
00074 <span class="comment">// this is not meant to be an atomic lock, just something to help flag multiple thread entry</span>
00075 <span class="keyword">inline</span> <span class="keywordtype">void</span> MemoryTracer::entrylock() 
00076 {
00077   <span class="keywordflow">if</span> (entry != 0) {
00078     Logerr(<span class="stringliteral">"Multiple thread entry detected!  MemoryTracer is not threadsafe - please restrict use to a single thread at a time."</span>);
00079     handleError();
00080   }
00081   <span class="keywordflow">else</span>
00082     entry++;
00083 }
00084 
00085 <span class="keyword">inline</span> <span class="keywordtype">void</span> MemoryTracer::exitunlock()
00086 {
00087   entry--;
00088 }
00089 
00090 <span class="comment">//</span>
00091 <span class="comment">// Home grown doubly linked list</span>
00092 <span class="comment">//  (Unfortunately, MemoryTracer can't used STL because it must not call the global</span>
00093 <span class="comment">//   new or delete.  Using STL containers with malloc_alloc as their</span>
00094 <span class="comment">//   allocator should work - but, alas, it doesn't).</span>
00095 
00096 
00097 <span class="keywordtype">void</span> MemoryTracer::AllocList::push_front(AllocEntry* e)
00098 {
00099   <span class="keywordflow">if</span> (head == 0) {
00100     head = tail = e;
00101     e-&gt;next = e-&gt;prev = 0;
00102   }
00103   <span class="keywordflow">else</span> {
00104     AllocEntry* oldhead = head;
00105     head = e;
00106     head-&gt;next = oldhead;
00107     head-&gt;prev = 0;
00108     oldhead-&gt;prev = head;
00109   }
00110   len++;
00111 }
00112 
00113 
00114 <span class="keywordtype">void</span> MemoryTracer::AllocList::push_back(AllocEntry* e)
00115 {
00116   <span class="keywordflow">if</span> (head == 0) {
00117     head = tail = e;
00118     e-&gt;next = e-&gt;prev = 0;
00119   }
00120   <span class="keywordflow">else</span> {
00121     AllocEntry* oldtail = tail;
00122     tail = e;
00123     tail-&gt;next = 0;
00124     tail-&gt;prev = oldtail;
00125     oldtail-&gt;next = tail;
00126   }
00127   len++;
00128 }
00129 
00130 MemoryTracer::AllocEntry* MemoryTracer::AllocList::pop_front()
00131 {
00132   AllocEntry* oldhead = head;
00133   <span class="keywordflow">if</span> (head != 0) {
00134     head = head-&gt;next;
00135     <span class="keywordflow">if</span> (head)
00136       head-&gt;prev = 0;
00137     <span class="keywordflow">else</span>
00138       tail = 0;
00139     len--;
00140   }
00141   <span class="keywordflow">return</span> oldhead;
00142 }
00143 
00144 
00145 MemoryTracer::AllocEntry* MemoryTracer::AllocList::pop_back()
00146 {
00147   AllocEntry* oldtail = tail;
00148   <span class="keywordflow">if</span> (tail != 0) {
00149     tail = tail-&gt;prev;
00150     <span class="keywordflow">if</span> (tail)
00151       tail-&gt;next = 0;
00152     <span class="keywordflow">else</span>
00153       head = 0;
00154     len--;
00155   }
00156   <span class="keywordflow">return</span> oldtail;
00157 }
00158 
00159 
00160 <span class="keywordtype">void</span> MemoryTracer::AllocList::remove(AllocEntry* e)
00161 {
00162   <span class="keywordflow">if</span> (e == tail) {
00163     pop_back();
00164   }
00165   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e == head) {
00166     pop_front();
00167   }
00168   <span class="keywordflow">else</span> {
00169     e-&gt;next-&gt;prev = e-&gt;prev;
00170     e-&gt;prev-&gt;next = e-&gt;next;
00171     len--;
00172   }
00173 }
00174 
00175 
00176 MemoryTracer::AllocEntry* MemoryTracer::AllocList::find(<span class="keywordtype">void</span>* address, AllocEntry* from)<span class="keyword"> const</span>
00177 <span class="keyword"></span>{ 
00178   <a class="code" href="namespacebase.html#a0">Byte</a>* addr = (<a class="code" href="namespacebase.html#a0">Byte</a>*)address;
00179   AllocEntry* m = (from==0)?head:from;
00180   <span class="keywordflow">while</span> (m) {
00181     <span class="keywordflow">if</span> (!m-&gt;isExternal()) {
00182       <span class="keywordflow">if</span> (addr == m-&gt;address+Filling)
00183         <span class="keywordflow">return</span> m;
00184     }
00185     <span class="keywordflow">else</span>
00186       <span class="keywordflow">if</span> (addr == m-&gt;address)
00187         <span class="keywordflow">return</span> m;
00188     
00189     m = m-&gt;next;
00190   }
00191   <span class="keywordflow">return</span> 0;
00192 }
00193 
00194 
00195 
00196   <span class="keywordtype">void</span> MemoryTracer::menu() <span class="keywordflow">throw</span>(std::bad_alloc)
00197   {
00198     <span class="keywordtype">char</span> ans[32];
00199     <span class="keywordtype">bool</span> quit=<span class="keyword">false</span>;
00200     <span class="keywordflow">while</span> (!quit) {
00201       printf(<span class="stringliteral">"\n"</span>);
00202       printf(<span class="stringliteral">"Choose: (a)llocated memory list        (n)amed allocated memory\n"</span>);
00203       printf(<span class="stringliteral">"        (r)eciently deallocated memory (d)ivide by 0 crash (SIGFPE)\n"</span>);
00204       printf(<span class="stringliteral">"         e(x)it   (t)hrow bad_alloc    (c)continue? "</span>);
00205       scanf(<span class="stringliteral">"%s"</span>,ans);
00206       <span class="keywordflow">switch</span> (tolower(ans[0])) {
00207       <span class="keywordflow">case</span> <span class="charliteral">'a'</span>: dump(); <span class="keywordflow">break</span>;
00208       <span class="keywordflow">case</span> <span class="charliteral">'n'</span>: dumpNamed(); <span class="keywordflow">break</span>;
00209       <span class="keywordflow">case</span> <span class="charliteral">'r'</span>: dumpDeallocated(); <span class="keywordflow">break</span>;
00210       <span class="keywordflow">case</span> <span class="charliteral">'d'</span>: causefault(); <span class="keywordflow">break</span>;
00211       <span class="keywordflow">case</span> <span class="charliteral">'x'</span>: exit(-1); <span class="keywordflow">break</span>;
00212       <span class="keywordflow">case</span> <span class="charliteral">'t'</span>: <span class="keywordflow">throw</span> std::bad_alloc(); <span class="keywordflow">break</span>;
00213       <span class="keywordflow">case</span> <span class="charliteral">'c'</span>: quit=<span class="keyword">true</span>; <span class="keywordflow">break</span>;
00214       <span class="keywordflow">default</span>: ;
00215       }
00216     }
00217   }
00218 
00219 
00220   <span class="keywordtype">void</span> MemoryTracer::handleError() <span class="keywordflow">throw</span>(std::bad_alloc)
00221   {
00222 <span class="preprocessor">#ifdef _INTERACTIVE_</span>
00223 <span class="preprocessor"></span>    menu();
00224 <span class="preprocessor">#else</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#ifdef _THROWEXCEPTION_</span>
00226 <span class="preprocessor"></span>    <span class="keywordflow">throw</span> std::bad_alloc();
00227 <span class="preprocessor">#endif</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00229 <span class="preprocessor"></span>  }
00230 
00231 
00232   <span class="comment">// Does a dividie by zero - Debugger can catch this to provide a stack trace</span>
00233   <span class="keywordtype">int</span> MemoryTracer::causefault() 
00234   {
00235     <span class="keywordtype">int</span> i=5, j=5;
00236     <span class="comment">// try not to let compiler optimise this out of existance </span>
00237     j = i/(j-i); <span class="comment">// Divide by 0 to get debugger's attention</span>
00238     <span class="keywordflow">return</span> j;
00239   }
00240   
00241   
00242   <span class="comment">// Checks all currently allocated memory for overwrites</span>
00243   <span class="keywordtype">bool</span> MemoryTracer::checkAllMemory() <span class="keywordflow">throw</span>(std::bad_alloc)
00244   {
00245     <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>;
00246 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00247 <span class="preprocessor"></span>    checkCount++;
00248     AllocEntry* m = mlist.front();
00249     <span class="keywordtype">int</span> size, i,j;
00250     <span class="keywordtype">char</span> errstr[256];
00251     
00252     <span class="keywordflow">while</span> (m) {
00253       <span class="keywordflow">if</span> (!m-&gt;isOK()) {
00254         Logerr(<span class="stringliteral">"Memory allocation record has been corrupted (AllocEntry)."</span>);
00255         <span class="keywordtype">bool</span> prefillOK = <span class="keyword">true</span>;
00256         <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;Filling; i++) 
00257           <span class="keywordflow">if</span> (m-&gt;prefill[i] != Filler) prefillOK = <span class="keyword">false</span>;
00258         <span class="keywordtype">bool</span> postfillOK = <span class="keyword">true</span>;
00259         <span class="keywordflow">for</span>(<a class="code" href="namespacebase.html#a2">Int</a> i=0; i&lt;Filling; i++) 
00260           <span class="keywordflow">if</span> (m-&gt;postfill[i] != Filler) postfillOK = <span class="keyword">false</span>;
00261         sprintf(errstr,<span class="stringliteral">"Entry: prefill:%s postfill:%s size:%6d isMagic:%s"</span>,
00262                 prefillOK?<span class="stringliteral">"OK"</span>:<span class="stringliteral">"BAD"</span>, postfillOK?<span class="stringliteral">"OK"</span>:<span class="stringliteral">"BAD"</span>,m-&gt;size,m-&gt;isMagic()?<span class="stringliteral">"OK"</span>:<span class="stringliteral">"BAD"</span>);
00263         Logerr(errstr);
00264         m=0;
00265         ok=<span class="keyword">false</span>;
00266       } 
00267       <span class="keywordflow">else</span> {
00268         
00269         <span class="keywordflow">if</span> (!m-&gt;isExternal()) {
00270           <a class="code" href="namespacebase.html#a0">Byte</a>* mem = (<a class="code" href="namespacebase.html#a0">Byte</a>*)m-&gt;address;
00271           size = m-&gt;size;
00272           <span class="keywordflow">for</span>(i=0; (i&lt;Filling) &amp;&amp; ok; i++) {
00273             <span class="keywordflow">if</span> ( *(mem+i) != Filler ) {
00274               sprintf(errstr,<span class="stringliteral">"Memory before allocation %x (%s) has been overwritten"</span>,(Int)mem+Filling,m-&gt;name);
00275               <span class="keywordflow">for</span>(j=0; j&lt;Filling; j++) {
00276                 sprintf(errstr,<span class="stringliteral">"addr(m-%d) = %d (should be %d)"</span>,Filling-j,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)*(mem+i),Filler);
00277                 Logerr(errstr);
00278               }
00279               ok=<span class="keyword">false</span>;
00280             }
00281             <span class="keywordflow">if</span> ( *(mem+Filling+size+i) != Filler ) {
00282               sprintf(errstr,<span class="stringliteral">"Memory after allocation %x (%s) has been overwritten"</span>,(Int)mem+Filling,m-&gt;name);
00283               Logerr(errstr);
00284               <span class="keywordflow">for</span>(j=0; j&lt;Filling; j++) {
00285                 sprintf(errstr,<span class="stringliteral">"addr(m+size+%d) = %d (should be %d)"</span>,j,(Int)*(mem+size+Filling+i),Filler);
00286                 Logerr(errstr);
00287               }
00288               ok=<span class="keyword">false</span>;
00289             }
00290             
00291           }
00292         } 
00293         
00294         m = m-&gt;next;
00295       }
00296       
00297     }
00298     
00299     <span class="keywordflow">if</span> (!ok) handleError();
00300 <span class="preprocessor">#endif    </span>
00301 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ok;
00302   }
00303   
00304 
00305   <span class="comment">// allocate memory (returns 0 on error)</span>
00306   <span class="keywordtype">void</span>* MemoryTracer::allocate(<span class="keywordtype">int</span> size, <span class="keyword">const</span> string&amp; name, <span class="keywordtype">bool</span> isArray) <span class="keywordflow">throw</span>(std::bad_alloc)
00307   {
00308     entrylock();
00309     <span class="keywordflow">if</span> (!isOK()) {
00310       Logerr(<span class="stringliteral">"memory allocation records have been corrupted (MemoryTracer)."</span>);
00311       exitunlock();
00312       <span class="keywordflow">return</span> 0;
00313     }
00314 
00315     <span class="keywordtype">int</span> i;
00316     AllocEntry* ne;
00317     <span class="keywordflow">if</span> (size &lt;= 0) {
00318       Logerr(<span class="stringliteral">"passed size &lt;= 0."</span>);
00319       handleError();
00320       <span class="keywordflow">return</span> 0;
00321     }
00322     <span class="keywordtype">void</span>* mem = malloc(size + Filling*2);
00323     <span class="keywordflow">if</span> (mem == 0) <span class="keywordflow">return</span> 0;
00324 
00325 <span class="preprocessor">#if (_FULLCHECKFREQUENTY_ &gt; 0)</span>
00326 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((++fullCheckCounter % _FULLCHECKFREQUENTY_) == 0) {
00327       fullCheckCounter=0;
00328       checkAllMemory();
00329     }
00330 <span class="preprocessor">#endif</span>
00331 <span class="preprocessor"></span>
00332     ne = (AllocEntry*)malloc(<span class="keyword">sizeof</span>(AllocEntry));
00333     <span class="keywordflow">if</span> (ne == 0) {
00334       free(mem);
00335       Logerr(<span class="stringliteral">"no memory available to allocate (for entry)."</span>);
00336       <span class="keywordflow">return</span> 0;
00337     }
00338     ne-&gt;fill();
00339 
00340     <span class="comment">// fill 'Filling' bytes before and after returned memory area with 'Filler' byte </span>
00341     <span class="keywordflow">for</span>(i=0; i&lt; Filling; i++) {
00342       *(((<a class="code" href="namespacebase.html#a0">Byte</a>*)mem)+i) = Filler;
00343       *(((<a class="code" href="namespacebase.html#a0">Byte</a>*)mem)+size+Filling+i) = Filler;
00344     }
00345 
00346     ne-&gt;size = size;
00347     ne-&gt;name = 0;
00348     ne-&gt;setIsArray(isArray);
00349     
00350     <span class="keywordflow">if</span> (name.size() &gt; 0) {
00351       ne-&gt;name = (<span class="keywordtype">char</span>*)malloc(name.size()+1);
00352       <span class="keywordflow">if</span> (ne-&gt;name == 0) {
00353         Logerr(<span class="stringliteral">"no memory available to allocate name."</span>);
00354       }
00355       <span class="keywordflow">else</span>
00356         strcpy(ne-&gt;name, name.c_str());
00357     }
00358 
00359     ne-&gt;setMagic();
00360     ne-&gt;address = (<a class="code" href="namespacebase.html#a0">Byte</a>*)mem;
00361 
00362     mlist.push_front(ne);
00363     
00364     allocCount++;
00365     exitunlock();
00366     <span class="keywordtype">void</span>* addr = ((<a class="code" href="namespacebase.html#a0">Byte</a>*)mem)+Filling;
00367 <span class="preprocessor">#ifdef _MEMORYTRACEDEBUG_</span>
00368 <span class="preprocessor"></span>    <span class="keywordtype">char</span> logstr[80];
00369     sprintf(logstr, <span class="stringliteral">"allocated(size:%d, name:%s, isArray:%s) = %x"</span>, size, (name.size()&gt;0)?name.c_str():"&lt;unnamed&gt;",isArray?"<a class="code" href="general_8h.html#a17">TRUE</a>":"<a class="code" href="general_8h.html#a18">FALSE</a>",<a class="code" href="namespacebase.html#a2">Int</a>(addr));
00370     Logerr(logstr);
00371 <span class="preprocessor">#endif</span>
00372 <span class="preprocessor"></span>    <span class="keywordflow">return</span> addr;
00373   }
00374   
00375 
00376 
00377   <span class="comment">// registers an externally allocated region as valid (for Checks).</span>
00378   <span class="keywordtype">bool</span> MemoryTracer::validate(<span class="keywordtype">void</span>* address, <span class="keywordtype">int</span> size, <span class="keyword">const</span> string&amp; name) <span class="keywordflow">throw</span>(std::bad_alloc)
00379   {
00380     entrylock();
00381     <span class="keywordflow">if</span> (!isOK()) {
00382       Logerr(<span class="stringliteral">"memory allocation records have been corrupted."</span>);
00383       exitunlock();
00384       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00385     }
00386 
00387     AllocEntry* ne;
00388     <span class="keywordtype">char</span> errstr[256];
00389 
00390     <span class="keywordflow">if</span> (size &lt; 0) {
00391       Logerr(<span class="stringliteral">"passed size &lt; 0."</span>);
00392       exitunlock();
00393       handleError();
00394       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00395     }
00396     
00397 <span class="preprocessor">#if (_FULLCHECKFREQUENTY_ &gt; 0)</span>
00398 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((++fullCheckCounter % _FULLCHECKFREQUENTY_) == 0) {
00399       fullCheckCounter=0;
00400       checkAllMemory();
00401     }
00402 <span class="preprocessor">#endif</span>
00403 <span class="preprocessor"></span>    
00404     <span class="comment">// first look to see if this address is already registered as valid,</span>
00405     <span class="comment">// if so, return - nothing more to do </span>
00406     AllocEntry* m = mlist.find(address);
00407     <span class="keywordflow">if</span> (m) {
00408       <span class="keywordflow">if</span> (!m-&gt;isExternal()) {
00409         <span class="keywordflow">if</span> (address == m-&gt;address + Filling) {
00410           sprintf(errstr,<span class="stringliteral">"memory at address %x (%s) was allocated with allocate(), so cannot be validated with validate()\n"</span>,
00411                   <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling),(m-&gt;name==0)?<span class="stringliteral">"&lt;unnamed&gt;"</span>:m-&gt;name);
00412           Logerr(errstr);
00413           exitunlock();
00414           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00415         }
00416       }
00417       <span class="keywordflow">else</span>
00418         <span class="keywordflow">if</span> (address == m-&gt;address) {
00419           exitunlock();
00420           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00421         }
00422     }
00423     
00424     ne = (AllocEntry*)malloc(<span class="keyword">sizeof</span>(AllocEntry));
00425     <span class="keywordflow">if</span> (ne == 0) {
00426       Logerr(<span class="stringliteral">"no memory available to allocate (for entry)."</span>);
00427       exitunlock();
00428       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00429     }
00430     
00431     ne-&gt;size = size;
00432     ne-&gt;name = 0;
00433 
00434     <span class="keywordflow">if</span> (name.size() &gt; 0) {
00435       ne-&gt;name = (<span class="keywordtype">char</span>*)malloc(name.size()+1);
00436       <span class="keywordflow">if</span> (ne-&gt;name == 0) {
00437         Logerr(<span class="stringliteral">"no memory available to allocate (for name)."</span>);
00438       }
00439       <span class="keywordflow">else</span>
00440         strcpy(ne-&gt;name, name.c_str());
00441       
00442     }
00443     ne-&gt;setMagic();
00444     ne-&gt;setExternal();
00445     ne-&gt;setIsArray(<span class="keyword">false</span>);
00446     ne-&gt;address = (<a class="code" href="namespacebase.html#a0">Byte</a>*)address;
00447     
00448     mlist.push_front(ne);
00449 
00450     exitunlock();
00451 
00452 <span class="preprocessor">#ifdef _MEMORYTRACEDEBUG_</span>
00453 <span class="preprocessor"></span>    <span class="keywordtype">char</span> logstr[80];
00454     sprintf(logstr, <span class="stringliteral">"validated(address:%x, size:%d, name:%s)"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(address), size, (name.size()&gt;0)?name.c_str():"&lt;unnamed&gt;");
00455     Logerr(logstr);
00456 <span class="preprocessor">#endif</span>
00457 <span class="preprocessor"></span>
00458     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00459   }
00460   
00461   
00462 
00463   <span class="comment">// free allocated memory</span>
00464   <span class="keywordtype">bool</span> MemoryTracer::release(<span class="keywordtype">void</span>* address, <span class="keywordtype">bool</span> isArray, <span class="keywordtype">int</span> size) <span class="keywordflow">throw</span>(std::bad_alloc)
00465   {
00466     entrylock();
00467     <span class="keywordflow">if</span> (!isOK()) {
00468       Logerr(<span class="stringliteral">"memory allocation records have been corrupted."</span>);
00469       exitunlock();
00470       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00471     }
00472 
00473     <span class="keywordflow">if</span> (cleanedUp) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00474 
00475     <a class="code" href="namespacebase.html#a0">Byte</a>* addr = (<a class="code" href="namespacebase.html#a0">Byte</a>*)address;
00476     <span class="keywordtype">char</span> errstr[256];
00477 
00478 <span class="preprocessor">#if (_FULLCHECKFREQUENTY_ &gt; 0)</span>
00479 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((++fullCheckCounter % _FULLCHECKFREQUENTY_) == 0) {
00480       fullCheckCounter=0;
00481       checkAllMemory();
00482     }
00483 <span class="preprocessor">#endif</span>
00484 <span class="preprocessor"></span>    
00485     AllocEntry* m = mlist.find(address);
00486     <span class="keywordtype">bool</span> found = (m!=0);
00487     <span class="keywordtype">char</span> name[128];
00488     strcpy(name, <span class="stringliteral">"&lt;unknown&gt;"</span>);
00489 
00490     <span class="keywordflow">if</span> (found) {
00491       
00492       <span class="keywordflow">if</span> (addr == m-&gt;address+Filling) {
00493         <span class="keywordflow">if</span> ((size!=-1) &amp;&amp; (size!=m-&gt;size)) {
00494           sprintf(errstr,<span class="stringliteral">"size given (%d) for region at %x doesn't match that allocated (%d)"</span>,
00495                   size,<a class="code" href="namespacebase.html#a2">Int</a>(address),m-&gt;size);
00496           Logerr(errstr);
00497         }
00498         <span class="keywordflow">if</span> (m-&gt;isArray() != isArray) {
00499           <span class="keywordflow">if</span> (m-&gt;isArray()) {
00500             sprintf(errstr,<span class="stringliteral">"region at %x was allocated as an array but not free'd as one"</span>,
00501                     <a class="code" href="namespacebase.html#a2">Int</a>(address));
00502             Logerr(errstr);
00503             handleError();
00504           }
00505           <span class="keywordflow">else</span> {
00506             sprintf(errstr,<span class="stringliteral">"region at %x was free'd as an array but not allocated as one"</span>,
00507                     <a class="code" href="namespacebase.html#a2">Int</a>(address));
00508             Logerr(errstr);
00509             handleError();
00510           }
00511         }
00512         
00513 <span class="preprocessor">#ifdef _MEMORYTRACEDEBUG_</span>
00514 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m-&gt;name)
00515           strncpy(name, m-&gt;name, 127);
00516 <span class="preprocessor">#endif</span>
00517 <span class="preprocessor"></span>        
00518         <span class="comment">// remove from list </span>
00519         mlist.remove(m);
00520 
00521         free(m-&gt;address); <span class="comment">// free memory</span>
00522 
00523         dlist.push_front(m); <span class="comment">// add to deallocated list</span>
00524         <span class="keywordflow">if</span> (dlist.size() &gt; DList_Max) {
00525           AllocEntry* dm = dlist.pop_back();
00526           <span class="keywordflow">if</span> (dm-&gt;name!=0) 
00527             free(dm-&gt;name);
00528           free(dm);
00529         }
00530       }
00531       <span class="keywordflow">else</span> {
00532         <span class="keywordflow">if</span> ((addr == m-&gt;address) &amp;&amp; (m-&gt;isExternal())) {
00533           sprintf(errstr,<span class="stringliteral">"memory at address %x was not allocated with allocate(), but was validated with validate(). (will invalidate without freeing)."</span>,(Int)address);
00534           Logerr(errstr);
00535           exitunlock();
00536           invalidate(address,size);
00537           entrylock();
00538         }
00539       }
00540     }
00541     <span class="keywordflow">else</span> { <span class="comment">// not found</span>
00542       sprintf(errstr,<span class="stringliteral">"no memory allocated at address %x."</span>,(Int)address);
00543       Logerr(errstr);
00544 
00545       <span class="comment">// check to see if the memory was previously deallocated</span>
00546       AllocEntry* from = dlist.front();
00547       AllocEntry* dm;
00548       <span class="keywordflow">do</span> {
00549         dm = dlist.find(address,from);
00550         <span class="keywordflow">if</span> (dm) {
00551           <a class="code" href="namespacebase.html#a0">Byte</a>* addr = (dm-&gt;isExternal()?dm-&gt;address:dm-&gt;address+Filling);
00552           sprintf(errstr,<span class="stringliteral">"memory was previously allocated at address %x as %s (size %d) - but has since been deallocated."</span>,
00553                   <a class="code" href="namespacebase.html#a2">Int</a>(addr),((dm-&gt;name==0)?<span class="stringliteral">"&lt;unnamed&gt;"</span>:dm-&gt;name),dm-&gt;size);
00554           Logerr(errstr);
00555           from = dm-&gt;next;
00556           <span class="keywordflow">if</span> (from==0) from = dlist.back();
00557         }
00558       } <span class="keywordflow">while</span> (dm);
00559 
00560       <span class="comment">//dump();</span>
00561       checkAllMemory();
00562       exitunlock();
00563       handleError();
00564       <span class="keywordflow">return</span> found;
00565     }
00566 
00567     deallocCount++;
00568     exitunlock();
00569 
00570 <span class="preprocessor">#ifdef _MEMORYTRACEDEBUG_</span>
00571 <span class="preprocessor"></span>    <span class="keywordtype">char</span> logstr[80];
00572     sprintf(logstr, <span class="stringliteral">"released(address:%x, isArray:%s, size:%6d, name:%s)"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(address), isArray?<span class="stringliteral">"TRUE"</span>:<span class="stringliteral">"FALSE"</span>, size, name);
00573     Logerr(logstr);
00574 <span class="preprocessor">#endif</span>
00575 <span class="preprocessor"></span>
00576     <span class="keywordflow">return</span> found;
00577   }
00578   
00579 
00580 
00581   <span class="comment">// invalidate externally allocated region, previously registered</span>
00582   <span class="comment">//   with validate()</span>
00583   <span class="keywordtype">bool</span> MemoryTracer::invalidate(<span class="keywordtype">void</span>* address, <span class="keywordtype">int</span> size) <span class="keywordflow">throw</span>(std::bad_alloc)
00584   {
00585     entrylock();
00586     <span class="keywordflow">if</span> (!isOK()) {
00587       Logerr(<span class="stringliteral">"memory allocation records have been corrupted."</span>);
00588       exitunlock();
00589       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00590     }
00591 
00592     <span class="keywordflow">if</span> (cleanedUp) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00593 
00594     <a class="code" href="namespacebase.html#a0">Byte</a>* addr = (<a class="code" href="namespacebase.html#a0">Byte</a>*)address;
00595     <span class="keywordtype">char</span> errstr[256];
00596     
00597 <span class="preprocessor">#if (_FULLCHECKFREQUENTY_ &gt; 0)</span>
00598 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((++fullCheckCounter % _FULLCHECKFREQUENTY_) == 0) {
00599       fullCheckCounter=0;
00600       checkAllMemory();
00601     }
00602 <span class="preprocessor">#endif</span>
00603 <span class="preprocessor"></span>
00604     AllocEntry* m = mlist.find(address);
00605     <span class="keywordtype">bool</span> found = (m!=0);
00606     <span class="keywordtype">char</span> name[128];
00607     strcpy(name, <span class="stringliteral">"&lt;unknown&gt;"</span>);
00608 
00609     <span class="keywordflow">if</span> (found) {
00610       
00611       <span class="keywordflow">if</span> (addr == m-&gt;address) {
00612         <span class="keywordflow">if</span> ((size!=-1) &amp;&amp; (size!=m-&gt;size)) {
00613           sprintf(errstr,<span class="stringliteral">"size given (%d) doesn't match that validated (%d)."</span>,size,m-&gt;size);
00614           Logerr(errstr);
00615         }
00616 
00617         <span class="comment">// remove from list </span>
00618 <span class="preprocessor">#ifdef _MEMORYTRACEDEBUG_</span>
00619 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m-&gt;name)
00620           strncpy(name, m-&gt;name, 127);
00621 <span class="preprocessor">#endif</span>
00622 <span class="preprocessor"></span>        mlist.remove(m);
00623         <span class="keywordflow">if</span> (m-&gt;name != 0) free(m-&gt;name);
00624         free(m);
00625       }
00626       <span class="keywordflow">else</span> {
00627         <span class="keywordflow">if</span> ((addr == m-&gt;address+Filling) &amp;&amp; (!m-&gt;isExternal())) {
00628           sprintf(errstr,<span class="stringliteral">"memory at address %x was allocated with allocate(), not validated with validate()."</span>,(Int)address);
00629           Logerr(errstr);
00630         }
00631       }
00632       
00633     }
00634     <span class="keywordflow">else</span> { <span class="comment">// !found</span>
00635       sprintf(errstr,<span class="stringliteral">"no memory validated at address %x."</span>,(Int)address);
00636       Logerr(errstr);
00637       exitunlock();
00638       handleError();
00639       <span class="keywordflow">return</span> found;
00640     }
00641 
00642     exitunlock();
00643 
00644 <span class="preprocessor">#ifdef _MEMORYTRACEDEBUG_</span>
00645 <span class="preprocessor"></span>    <span class="keywordtype">char</span> logstr[80];
00646     sprintf(logstr, <span class="stringliteral">"invalidated(address:%x, size:%6d, name:%s)"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(address), size, name);
00647     Logerr(logstr);
00648 <span class="preprocessor">#endif</span>
00649 <span class="preprocessor"></span>
00650     <span class="keywordflow">return</span> found;
00651   }
00652   
00653   
00654   <span class="comment">// Check that addr &amp; addr+typesize-1 are within an </span>
00655   <span class="comment">//    allocated memory area</span>
00656   <span class="keywordtype">void</span>* MemoryTracer::checkAddrRange(<span class="keywordtype">void</span>* address, <span class="keywordtype">long</span> typesize) <span class="keywordflow">throw</span>(std::bad_alloc)
00657   {
00658     checkAddr(address, address, <span class="keyword">true</span>);
00659     <span class="keywordflow">if</span> (typesize&gt;0) checkAddr( ((<span class="keywordtype">char</span>*)address)+typesize-1, address, <span class="keyword">false</span>);
00660     <span class="keywordflow">return</span> address;
00661   }
00662 
00663 
00664   <span class="comment">// Check that addr is within an allocated memory area</span>
00665   <span class="keywordtype">bool</span> MemoryTracer::checkAddr(<span class="keywordtype">void</span>* address, <span class="keywordtype">void</span>* reportAddr, <span class="keywordtype">bool</span> checkAllMemory) <span class="keywordflow">throw</span>(std::bad_alloc)
00666   {
00667     <span class="keywordtype">bool</span> found=<span class="keyword">false</span>;
00668     <a class="code" href="namespacebase.html#a0">Byte</a> *addr = (<a class="code" href="namespacebase.html#a0">Byte</a>*)address;
00669     <span class="keywordtype">char</span> errstr[256];
00670     AllocEntry* m = mlist.front();
00671     
00672     <span class="keywordflow">if</span> (checkAllMemory) MemoryTracer::checkAllMemory();
00673 
00674     <span class="keywordflow">if</span> (reportAddr == 0) reportAddr = address;
00675     
00676     <span class="keywordflow">while</span> (m &amp;&amp; !found) {
00677       <span class="keywordflow">if</span> (!m-&gt;isExternal()) {
00678         
00679         <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling*2+m-&gt;size)) { <span class="comment">// it's within greater area </span>
00680           
00681           <span class="keywordflow">if</span> ((m-&gt;address+Filling &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling+m-&gt;size)) <span class="comment">// within valid area? </span>
00682             found=<span class="keyword">true</span>;
00683           <span class="keywordflow">else</span> { <span class="comment">// must be in one of filling areas </span>
00684             <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling)) {
00685               <span class="keywordflow">if</span> (address == reportAddr) {
00686                 sprintf(errstr,<span class="stringliteral">"reference address %x is before memory area at %x (size %d) (%s)."</span>,
00687                         <a class="code" href="namespacebase.html#a2">Int</a>(addr), <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling), m-&gt;size, m-&gt;name);
00688                 Logerr(errstr);
00689               }
00690               <span class="keywordflow">else</span> {
00691                 sprintf(errstr,<span class="stringliteral">"reference to address %x may allow to access address %x which is before memory area at %x (size %d) (%s)."</span>,
00692                         <a class="code" href="namespacebase.html#a2">Int</a>(reportAddr), <a class="code" href="namespacebase.html#a2">Int</a>(addr), <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling), m-&gt;size, m-&gt;name);
00693                 Logerr(errstr);
00694               }
00695             }
00696             <span class="keywordflow">else</span> { <span class="comment">// must be after then </span>
00697               <span class="keywordflow">if</span> (address == reportAddr) {
00698                 sprintf(errstr,<span class="stringliteral">"reference address %x is after memory area at %x (size %d) (%s)."</span>,
00699                         <a class="code" href="namespacebase.html#a2">Int</a>(addr), <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling), m-&gt;size, m-&gt;name);
00700                 Logerr(errstr);
00701               }
00702               <span class="keywordflow">else</span> {
00703                 sprintf(errstr,<span class="stringliteral">"reference to address %x may allow to access address %x which is after memory area at %x (size %d) (%s)\n"</span>,
00704                         <a class="code" href="namespacebase.html#a2">Int</a>(reportAddr), <a class="code" href="namespacebase.html#a2">Int</a>(addr), <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling), m-&gt;size, m-&gt;name);
00705                 Logerr(errstr);
00706               }
00707             }
00708             
00709           }
00710         }
00711       } <span class="keywordflow">else</span> { <span class="comment">// external </span>
00712         <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+m-&gt;size))
00713           found = <span class="keyword">true</span>;
00714       }
00715       
00716       m = m-&gt;next;
00717     }
00718     <span class="keywordflow">if</span> (!found) {
00719       <span class="keywordflow">if</span> (address == reportAddr) {
00720         sprintf(errstr,<span class="stringliteral">"reference to invalid memory address %x detected."</span>,<a class="code" href="namespacebase.html#a2">Int</a>(addr));
00721         Logerr(errstr);
00722       }
00723       <span class="keywordflow">else</span> {
00724         sprintf(errstr,<span class="stringliteral">"detected reference to address %x that may allow access to invalid address %x."</span>,<a class="code" href="namespacebase.html#a2">Int</a>(reportAddr), <a class="code" href="namespacebase.html#a2">Int</a>(addr));
00725         Logerr(errstr);
00726       }
00727       handleError();
00728       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00729   }
00730     
00731     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00732   }
00733   
00734 
00735   <span class="keywordtype">char</span>* MemoryTracer::getName(<span class="keywordtype">void</span>* addr) 
00736   {
00737     AllocEntry* m = mlist.front();
00738     <span class="keywordtype">bool</span> found=<span class="keyword">false</span>;
00739     AllocEntry* entry = 0;
00740     <span class="keywordflow">while</span> (m &amp;&amp; !found) {
00741       <span class="keywordflow">if</span> (!m-&gt;isExternal()) {
00742         
00743         <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling*2+m-&gt;size)) { <span class="comment">// it's within greater area </span>
00744           
00745           <span class="keywordflow">if</span> ((m-&gt;address+Filling &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling+m-&gt;size)) { <span class="comment">// within valid area? </span>
00746             found=<span class="keyword">true</span>;
00747             entry = m;
00748           }
00749         }
00750       } <span class="keywordflow">else</span> { <span class="comment">// external </span>
00751         <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+m-&gt;size)) {
00752           found = <span class="keyword">true</span>;
00753           entry=m;
00754         }
00755       }
00756       
00757       m = m-&gt;next;
00758     }
00759     
00760     <span class="keywordflow">if</span> (found)
00761       <span class="keywordflow">return</span> entry-&gt;name;
00762     <span class="keywordflow">else</span>
00763       <span class="keywordflow">return</span> 0;
00764   }
00765 
00766 
00767   <span class="keywordtype">long</span> MemoryTracer::getOffset(<span class="keywordtype">void</span>* addr) 
00768   {
00769     AllocEntry* m = mlist.front();
00770     <span class="keywordtype">bool</span> found=<span class="keyword">false</span>;
00771 
00772     <span class="keywordtype">long</span> offset=-1;
00773     <span class="keywordflow">while</span> (m &amp;&amp; !found) {
00774       <span class="keywordflow">if</span> (!m-&gt;isExternal()) {
00775         
00776         <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling*2+m-&gt;size)) { <span class="comment">// it's within greater area </span>
00777           
00778           <span class="keywordflow">if</span> ((m-&gt;address+Filling &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+Filling+m-&gt;size)) { <span class="comment">// within valid area? </span>
00779             found=<span class="keyword">true</span>;
00780             offset = (<a class="code" href="namespacebase.html#a0">Byte</a>*)addr - (m-&gt;address+Filling);
00781           }
00782         }
00783       } <span class="keywordflow">else</span> { <span class="comment">// external </span>
00784         <span class="keywordflow">if</span> ((m-&gt;address &lt;= addr) &amp;&amp; (addr &lt; m-&gt;address+m-&gt;size)) {
00785           found = <span class="keyword">true</span>;
00786           offset = (<a class="code" href="namespacebase.html#a0">Byte</a>*)addr - m-&gt;address;
00787         }
00788       }
00789       
00790       m = m-&gt;next;
00791     }
00792     
00793     <span class="keywordflow">return</span> offset;
00794   }
00795 
00796 
00797   <span class="comment">// free all allocated memory</span>
00798   <span class="keywordtype">bool</span> MemoryTracer::cleanup()
00799   {
00800 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00801 <span class="preprocessor"></span>    printf(<span class="stringliteral">"(Cleanup: %ld allocations, %ld deallocations, %ld integrity checks performed)\n"</span>,allocCount,deallocCount,checkCount);
00802 
00803     <span class="keywordtype">char</span> errstr[256];
00804     <span class="keywordflow">if</span> (mlist.size() &gt; 0) {
00805       dump();
00806       sprintf(errstr,<span class="stringliteral">"Freeing %d leaked memory allocations"</span>,mlist.size());
00807       Logerr(errstr);
00808       <span class="keywordflow">while</span> (mlist.size() &gt; 0) {
00809         AllocEntry* m = mlist.pop_front();
00810         <span class="keywordflow">if</span> (m-&gt;name != 0) free(m-&gt;name);
00811         <span class="keywordflow">if</span> (!m-&gt;isExternal()) free(m-&gt;address);
00812         free(m);
00813       }
00814     }
00815 
00816     <span class="keywordflow">while</span> (dlist.size() &gt; 0) {
00817       AllocEntry* m = dlist.pop_front();
00818       <span class="keywordflow">if</span> (m-&gt;name != 0) free(m-&gt;name);
00819       free(m);
00820     }
00821 <span class="preprocessor">#endif    </span>
00822 <span class="preprocessor"></span>    cleanedUp = <span class="keyword">true</span>;
00823     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00824   }
00825 
00826   <span class="comment">// display allocated memory areas</span>
00827   <span class="keywordtype">void</span> MemoryTracer::dump() 
00828   {
00829 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00830 <span class="preprocessor"></span>    AllocEntry* m = mlist.front();
00831     
00832     checkAllMemory();
00833     
00834     printf(<span class="stringliteral">"\nValid memory regions (%d):\n"</span>,mlist.size());
00835     printf(<span class="stringliteral">"(%ld allocations, %ld deallocations, %ld integrity checks performed)\n"</span>,allocCount,deallocCount,checkCount);
00836     printf(<span class="stringliteral">"----------------------------------------------------------------------------------\n"</span>);
00837     
00838     <span class="keywordflow">while</span>(m) {
00839       <span class="keywordflow">if</span> (m-&gt;isOK()) {
00840         printf(<span class="stringliteral">"%52s: %10x (%9d) %s %s\n"</span>, (m-&gt;name==0)?<span class="stringliteral">"&lt;unnamed&gt;"</span>:m-&gt;name, <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling), 
00841                m-&gt;size,(m-&gt;isArray()?<span class="stringliteral">"[]"</span>:<span class="stringliteral">"  "</span>),m-&gt;isExternal()?<span class="stringliteral">"EXT"</span>:<span class="stringliteral">""</span>);
00842         m = m-&gt;next;
00843       }
00844       <span class="keywordflow">else</span> {
00845         Logerr(<span class="stringliteral">"Memory allocation structure corrupted!"</span>);
00846         m=0;
00847       }
00848     }
00849     printf(<span class="stringliteral">"----------------------------------------------------------------------------------\n\n"</span>);
00850 <span class="preprocessor">#endif</span>
00851 <span class="preprocessor"></span>  }
00852 
00853 
00854   <span class="comment">// display allocated memory areas reciently deallocated</span>
00855   <span class="keywordtype">void</span> MemoryTracer::dumpDeallocated() 
00856   {
00857 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00858 <span class="preprocessor"></span>    AllocEntry* m = dlist.front();
00859     
00860     printf(<span class="stringliteral">"\nReciently deallocated memory regions (%d):\n"</span>,dlist.size());
00861     printf(<span class="stringliteral">"(%ld allocations, %ld deallocations, %ld integrity checks performed)\n"</span>,allocCount,deallocCount,checkCount);
00862     printf(<span class="stringliteral">"----------------------------------------------------------------------------------\n"</span>);
00863     
00864     <span class="keywordflow">while</span>(m) {
00865       <span class="keywordflow">if</span> (m-&gt;isOK()) {
00866         printf(<span class="stringliteral">"%52s: %10x (%9d) %s %s\n"</span>, (m-&gt;name==0)?<span class="stringliteral">"&lt;unnamed&gt;"</span>:m-&gt;name, <a class="code" href="namespacebase.html#a2">Int</a>(m-&gt;address+Filling), 
00867                m-&gt;size,(m-&gt;isArray()?<span class="stringliteral">"[]"</span>:<span class="stringliteral">"  "</span>),m-&gt;isExternal()?<span class="stringliteral">"EXT"</span>:<span class="stringliteral">""</span>);
00868         m = m-&gt;next;
00869       }
00870       <span class="keywordflow">else</span> {
00871         Logerr(<span class="stringliteral">"Memory allocation structure corrupted!"</span>);
00872         m=0;
00873       }
00874     }
00875     printf(<span class="stringliteral">"----------------------------------------------------------------------------------\n\n"</span>);
00876 <span class="preprocessor">#endif</span>
00877 <span class="preprocessor"></span>  }
00878 
00879 
00880   <span class="comment">// display named allocated memory areas only</span>
00881   <span class="keywordtype">void</span> MemoryTracer::dumpNamed() 
00882   {
00883 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00884 <span class="preprocessor"></span>    AllocEntry* m = mlist.front();
00885     
00886     checkAllMemory();
00887     
00888     printf(<span class="stringliteral">"\nValid named memory regions (from %d total):\n"</span>,mlist.size());
00889     printf(<span class="stringliteral">"(%ld allocations, %ld deallocations, %ld integrity checks performed)\n"</span>,allocCount,deallocCount,checkCount);
00890     printf(<span class="stringliteral">"----------------------------------------------------------------------------------\n"</span>);
00891     
00892     <span class="keywordtype">int</span> e=0;
00893     <span class="keywordflow">while</span>(m) {
00894       <span class="keywordflow">if</span> (m-&gt;isOK()) {
00895         <span class="keywordflow">if</span> (m-&gt;name!=0)
00896           printf(<span class="stringliteral">"%4d %52s: %10x (%9d) %s %s\n"</span>,e,m-&gt;name, (Int)(m-&gt;address+Filling),
00897                  m-&gt;size,(m-&gt;isArray()?<span class="stringliteral">"[]"</span>:<span class="stringliteral">"  "</span>),m-&gt;isExternal()?<span class="stringliteral">"EXT"</span>:<span class="stringliteral">""</span>);
00898         ++e; 
00899         m = m-&gt;next;
00900       }
00901       <span class="keywordflow">else</span> {
00902         Logerr(<span class="stringliteral">"Memory allocation structure corrupted!"</span>);
00903         m=0;
00904       }
00905     }
00906     printf(<span class="stringliteral">"----------------------------------------------------------------------------------\n\n"</span>);
00907 <span class="preprocessor">#endif    </span>
00908 <span class="preprocessor"></span>  }
00909 
00910 
00911 
00912 
00913 
00914 
00915 
00916 <span class="preprocessor">#include &lt;list&gt;</span>
00917 
00918 <span class="keyword">namespace </span>{
00919 
00920 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a0">base::Byte</a>;
00921 <span class="keyword">using</span> <a class="code" href="namespacebase.html#a2">base::Int</a>;
00922 
00923 std::list&lt;Byte*&gt; delayedDeletes;
00924 <a class="code" href="namespacebase.html#a2">Int</a> count = 0;
00925 <a class="code" href="namespacebase.html#a2">Int</a> maxDepth = 0;
00926 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacebase.html#a2">Int</a> maxCount = 5000;
00927 
00928 <span class="keywordtype">void</span> stressTestAllocatorRecurse(Int depth)
00929 {
00930   <a class="code" href="namespacebase.html#a2">Int</a> size = (rand() &amp; 0xff)+1;
00931   <a class="code" href="namespacebase.html#a0">Byte</a>* mem = <span class="keyword">new</span> <a class="code" href="namespacebase.html#a0">Byte</a>[size];
00932   ++count;
00933 
00934   <span class="keywordflow">if</span> (depth &gt; maxDepth) 
00935     maxDepth = depth;
00936 
00937   <a class="code" href="namespacebase.html#a2">Int</a> r = (rand() &amp; 0xc0) &gt;&gt; 6; <span class="comment">// 0-2</span>
00938   <span class="keywordflow">if</span> (r &amp;&amp; (count &lt; maxCount))
00939     stressTestAllocatorRecurse(depth+1);
00940 
00941   <a class="code" href="namespacebase.html#a2">Int</a> d = (rand() &amp; 0x80) &gt;&gt; 7; <span class="comment">// 0 or 1</span>
00942   <span class="keywordflow">if</span> (d)
00943     <span class="keyword">delete</span>[] mem;
00944   <span class="keywordflow">else</span>
00945     delayedDeletes.push_back(mem);
00946 }
00947 
00948 } <span class="comment">// namespace</span>
00949 
00950 <span class="keyword">using</span> std::list;
00951 
<a name="l00952"></a><a class="code" href="namespacebase.html#a132">00952</a> <span class="keywordtype">void</span> <a class="code" href="namespacebase.html#a132">base::stressTestAllocator</a>()
00953 {
00954   <a class="code" href="base.html#a7">Logfln</a>(<span class="stringliteral">"Performing memory allocator test..."</span>);
00955   <span class="keywordflow">while</span> (count &lt; maxCount) {
00956     stressTestAllocatorRecurse(1);
00957     MemoryTracer::checkAllMemory();
00958 
00959     <span class="comment">// delete half of the delayed delete's</span>
00960     <a class="code" href="namespacebase.html#a2">base::Int</a> c = delayedDeletes.size()/2;
00961     std::list&lt;Byte*&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> s = delayedDeletes.begin();
00962     std::list&lt;Byte*&gt;<a class="code" href="classstd_1_1iterator.html">::iterator</a> end = delayedDeletes.end();
00963     <span class="keywordflow">while</span> (s != end) {
00964       <span class="keywordflow">if</span> (--c &gt; 0) 
00965         <span class="keywordflow">if</span> (*s) <span class="keyword">delete</span>[] (*s);
00966       (*s) = 0;
00967       ++s;
00968     }
00969     MemoryTracer::checkAllMemory();
00970   }
00971   
00972   <span class="comment">// delete remaining delayed delete's</span>
00973   std::list&lt;Byte*&gt;::const_iterator s = delayedDeletes.begin();
00974   std::list&lt;Byte*&gt;::const_iterator end = delayedDeletes.end();
00975   <span class="keywordflow">while</span> (s != end) {
00976     <span class="keywordflow">if</span> (*s) <span class="keyword">delete</span>[] (*s);
00977     ++s;
00978   }
00979   delayedDeletes.clear();
00980   MemoryTracer::checkAllMemory();
00981 
00982   <a class="code" href="base.html#a7">Logfln</a>(<span class="stringliteral">"Done. "</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">" allocations ("</span> &lt;&lt; maxDepth &lt;&lt; <span class="stringliteral">" recursion depth)"</span>)
00983 }
00984 
00985 
00986 
00987 
00988 
00989 <span class="comment">// global</span>
00990 
00991 
00992 <span class="preprocessor">#ifdef _TRACEMEMORY_</span>
00993 <span class="preprocessor"></span>
00994 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a3">operator new</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc)
00995 {
00996   <span class="keywordtype">void</span>* p = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere0">base::MemoryTracer::allocate</a>(size,<span class="stringliteral">""</span>);
00997 <span class="preprocessor">#ifdef _TRACEOUTPUT_</span>
00998 <span class="preprocessor"></span><span class="preprocessor">#ifndef _NAMEDOUTPUTONLY_</span>
00999 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">"new(%d) = %x\n"</span>,size,Int(p));
01000 <span class="preprocessor">#endif</span>
01001 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01002 <span class="preprocessor"></span>  <span class="keywordflow">return</span> p;
01003 }
01004 
01005 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a3">operator new</a>(size_t size, <span class="keyword">const</span> string&amp; name) <span class="keywordflow">throw</span> (std::bad_alloc)
01006 {
01007   <span class="keywordtype">void</span>* p = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere0">base::MemoryTracer::allocate</a>(size,name);
01008 <span class="preprocessor">#ifdef _TRACEOUTPUT_</span>
01009 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">"new(%d,%s) = %x\n"</span>,size,name.c_str(),<a class="code" href="namespacebase.html#a2">Int</a>(p));
01010 <span class="preprocessor">#endif</span>
01011 <span class="preprocessor"></span>  <span class="keywordflow">return</span> p;
01012 }
01013 
01014 <span class="keywordtype">void</span> operator delete(<span class="keywordtype">void</span>* p) <span class="keywordflow">throw</span>()
01015 {
01016 <span class="preprocessor">#ifdef _TRACEOUTPUT_</span>
01017 <span class="preprocessor"></span>  <span class="keywordtype">char</span>* name = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere7">base::MemoryTracer::getName</a>(p);
01018   <span class="keywordflow">if</span> (name)
01019     fprintf(stderr, <span class="stringliteral">"delete[](%x,%s)\n"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(p),name);
01020 <span class="preprocessor">#ifndef _NAMEDOUTPUTONLY_</span>
01021 <span class="preprocessor"></span>  <span class="keywordflow">else</span>
01022     fprintf(stderr, <span class="stringliteral">"delete[](%x)\n"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(p));
01023 <span class="preprocessor">#endif</span>
01024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01025 <span class="preprocessor"></span>  <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere1">base::MemoryTracer::release</a>(p);
01026 }
01027 
01028 
01029 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a4">operator new[]</a>(size_t size) <span class="keywordflow">throw</span> (std::bad_alloc)
01030 {
01031   <span class="keywordtype">void</span>* p = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere0">base::MemoryTracer::allocate</a>(size,<span class="stringliteral">""</span>,<span class="keyword">true</span>);
01032 <span class="preprocessor">#ifdef _TRACEOUTPUT_</span>
01033 <span class="preprocessor"></span><span class="preprocessor">#ifndef _NAMEDOUTPUTONLY_</span>
01034 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">"new[](%d) = %x\n"</span>,size,<a class="code" href="namespacebase.html#a2">Int</a>(p));
01035 <span class="preprocessor">#endif</span>
01036 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01037 <span class="preprocessor"></span>  <span class="keywordflow">return</span> p;
01038 }
01039 
01040 <span class="keywordtype">void</span>* <a class="code" href="MemoryTracer.html#a4">operator new[]</a>(size_t size, <span class="keyword">const</span> string&amp; name) <span class="keywordflow">throw</span> (std::bad_alloc)
01041 {
01042   <span class="keywordtype">void</span>* p = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere0">base::MemoryTracer::allocate</a>(size,name,<span class="keyword">true</span>);
01043 <span class="preprocessor">#ifdef _TRACEOUTPUT_</span>
01044 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">"new[](%d,%s) = %x\n"</span>,size,name.c_str(),<a class="code" href="namespacebase.html#a2">Int</a>(p));
01045 <span class="preprocessor">#endif</span>
01046 <span class="preprocessor"></span>  <span class="keywordflow">return</span> p;
01047 }
01048 
01049 <span class="keywordtype">void</span> operator delete[](<span class="keywordtype">void</span>* p) <span class="keywordflow">throw</span>()
01050 {
01051 <span class="preprocessor">#ifdef _TRACEOUTPUT_</span>
01052 <span class="preprocessor"></span>  <span class="keywordtype">char</span>* name = <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere7">base::MemoryTracer::getName</a>(p);
01053   <span class="keywordflow">if</span> (name)
01054     fprintf(stderr, <span class="stringliteral">"delete[](%x,%s)\n"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(p),name);
01055 <span class="preprocessor">#ifndef _NAMEDOUTPUTONLY_</span>
01056 <span class="preprocessor"></span>  <span class="keywordflow">else</span>
01057     fprintf(stderr, <span class="stringliteral">"delete[](%x)\n"</span>, <a class="code" href="namespacebase.html#a2">Int</a>(p));
01058 <span class="preprocessor">#endif</span>
01059 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01060 <span class="preprocessor"></span>  <a class="code" href="classbase_1_1MemoryTracer.html#base_1_1MemoryTracere1">base::MemoryTracer::release</a>(p,<span class="keyword">true</span>);
01061 }
01062 
01063 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 29 15:56:08 2004 for OpenSim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
